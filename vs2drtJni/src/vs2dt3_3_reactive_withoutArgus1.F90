    Program Main
    USE vs2dt_rm
    USE PhreeqcRM
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit
    COMMON/JCON/JSTOP,JFLAG,jflag1
    character*80 filen
    integer :: clock0, clock1, clockmax, clockrate, ticks
    real    :: secs
    integer :: i, count_args
    character(len=32) :: arg

    !     Argument is number of threads for OpenMP
#ifdef USE_OPENMP      
    count_args = command_argument_count()  
    if (count_args .ge. 1) then
        call get_command_argument(1, arg)
        if (len_trim(arg) > 0) then
            READ(arg,"(I5)",err=5) i
            if (i > 0) then
                nthreads = i
                nthreads_transport = i
            endif
5           continue            
        endif
    endif
#else
    nthreads = 1
    nthreads_transport = 1
#endif  
#ifdef USE_MPI
    nthreads = 1
    ! MPI
    call MPI_INIT(status)
    if (status .ne. MPI_SUCCESS) then
        stop "Failed to get mpi_myself"
    endif
    call MPI_Comm_rank(MPI_COMM_WORLD, mpi_myself, status)
    call MPI_Comm_size(MPI_COMM_WORLD, mpi_tasks, status)
    if (mpi_myself > 0) then
        rm_id = RM_Create(nxyz, MPI_COMM_WORLD)
        status = RM_MpiWorker(rm_id)
        status = RM_Destroy(rm_id)
        call MPI_FINALIZE(status)
        stop
    endif
#endif

    filen = 'vs2drt.fil'
    JSTOP = 0
    !     SET UP TO READ FROM DATA FILE GENERATED BY VS2DTI
    call system_clock(count_max=clockmax, count_rate=clockrate)
    call system_clock(clock0)
    !      call SETUP(filen)
    call SETUP(0, 0, 0, filen)
10  CALL STEP()
    IF (JSTOP.EQ.0) GOTO 10  
    ! call system_clock(clock1)

    !ticks = clock1-clock0
    !ticks = mod(ticks+clockmax, clockmax)   ! reset negative numbers
    !secs = float(ticks)/float(clockrate)
#ifdef USE_MPI
    status = RM_MpiWorkerBreak(rm_id)
#endif
    CALL FH_FinalizeFiles
    status = RM_CloseFiles(rm_id)
    status = RM_Destroy(rm_id)
#ifdef USE_MPI
    call MPI_FINALIZE(status)
#endif
    call system_clock(clock1, clockrate, clockmax)
    secs = real( clock1 - clock0) / real(clockrate)
    write(stderr,*) 'JSTOP = ',JSTOP
    write(stderr,*) 'Code took ', secs, ' seconds' 
    stop
    end
    !include 'd_modules.inc'
    !      SUBROUTINE SETUP( filen)
    SUBROUTINE SETUP(iold, ihydr, isorp, filen)
    ! *** THIS SUBROUTINE IS THE FIRST HALF OF THE ORIGINAL MAIN CODE
    ! *** THAT READS THE SIMULATION DATA
    !***    12/1/98
    !
    !
    !******
    !VSEXEC
    !******
    !-----------------------------------------------------------------
    !         ************ PROGRAM VS2DRT *********************
    !
    !   PROGRAM TO SOLVE FOR:
    !      TWO DIMENSIONAL VERTICAL SECTION OR CYLINDRICAL THREE
    !          DIMENSIONAL FLUID FLOW AND REACTIVE TRANSPORT UNDER
    !         VARIABLY SATURATED CONDITIONS
    !
    !       FLUID FLOW IS SOLVED FOR BY AN IMPLICIT FINITE DIFFERENCE
    !          FORMULATION OF THE COMBINED RICHARDS AND COOPER-JACOB
    !          EQUATIONS FOR FLUID CONTINUITY.
    !
    !.................................................................
    !
    !      SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use BF
    use COORDIN
    use DISCH
    use DUMM
    use DUMM1
    use DUMM2
    use DUMM3
    use EQUAT
    use EQUATS
    use HCON
    use IDUMM
    use IHDUMM
    use ISDUMM
    use ITEMBLO
    use ITEMTXB
    use JTXX
    use KCON
    use MPROP
    use PHREECC
    use PIT
    use PLOTT
    use PRESS
    use PRICON
    use PTET
    use RPROPSH
    use RSPAC
    use SCON
    use SIP
    use SOLINDEX
    use SOLMASS
    use SPFC
    use TEMP
    use TEMPCC
    use TRXV
    use TRXX
    use TRXXH
    use TRXY1
    use TRXY2

    use rspac
    use kcon
    use mprop
    use press
    use disch
    use hcon
    use equat
    use jtxx
    use dumm
    use ptet
    use trxx
    use trxy1
    use pit
    use sip
    use plott
    use spfc
    use rpropsh
    use scon
    use equats
    use trxy2
    use trxxh
    use trxv
    use temp
    use solmass
    use tempcc
    use compnam
    use pricon
    use coordin
    use solindex    
    use phreecc
    use react
    USE vs2dt_rm
    USE PhreeqcRM
    use gmres1, only : a_gmr, ia_gmr, ja_gmr, rhs_gmr
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !{{
    !!      INTEGER, INTENT(IN) :: iold
    !!      INTEGER, INTENT(OUT) :: ihydr, isorp
    INTEGER :: iold
    INTEGER :: ihydr, isorp
    !}}
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/PND/POND
    COMMON/WGT/WUS,WDS
    COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p,F14P, &
    F15P,F16P,F17P,F18P,F19P
    LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p,F14P, &
    F15P,F16P,F17P,F18P,F19P
    COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
    !      CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11,f12,f14, &
    !      f15,f16,f17,blank,f18,f19
    CHARACTER*80 TITL,f5,f6,f7,f8,f9,f10,f11,f12,f14, &
    f15,f16,f17,blank,f18,f19
    CHARACTER(*), INTENT(IN) :: filen
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT,  &
    bl95I,bl95IT,bl95o,bl95OT
    integer hydraulicFunctionType,iuTemperature,iuHead,iuConcentration
    common/functiontype/ hydraulicFunctionType
    !      COMMON/VERSION/VER2P5
    !     LOGICAL VER2P5
    common/iuNumber/ iuHead, iuConcentration,iuTemperature
    ! *** NEXT STATEMENT CHANGED FROM SAVE TO COMMON
    COMMON/TTT/IFET,IFET1,NITT,NITT1,NITT2
    common/elimit/elimit1,elimit2
    real*8 ang
    integer NHTPROP,NSTPROP
    COMMON/TRANNSPROP/NHTPROP,NSTPROP
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/TTT1/NISS,NISS1,NISS2
    COMMON/FLO/FLOW
    COMMON/SCON1/ITESTS
    CHARACTER*80 CHEMFILE,DATABASEFILE,PREFIX
    COMMON/SOLCHAR/CHEMFILE,DATABASEFILE,PREFIX
    logical axes(2) 
    common/axis/axes
    common/conversion/CNVTM,CNVTMI     
    character(len=:), dimension(:), allocatable   :: SCOMPNAME
    common/ITEMK/KNLY,KNXR,KNNODE
    !!@@include 'd_kdum.inc'
    integer, allocatable::KDUM(:,:)
    integer       :: myerr
    !     include 'c_kdum.inc'
    ! *** Set version, hydraulic function type, and sorption type
    !--------------------------------------------------------------------------------------------
    !

    !   open files 
    !
    iuHead = 5
    iuConcentration = 5
    GRAV = .FALSE.
    blank = ' '
    open(12,file='fort.12',FORM='UNFORMATTED',ACTION='WRITE',  &
    POSITION='REWIND')
    !{{      
    !      write(*,*) "file=", trim(filen)
    !}}
    !      open(2,file=trim(filen))
    open(2,file=filen)
    read(2,9090)f5
    read(2,9090)f6
    read(2,9090)f7
    read(2,9090)f8
    read(2,9090)f9
    read(2,9090)f11
    !      read(2,9090)f14
    !      read(2,9090)f15
    !      read(2,9090)f16
    !      read(2,9090)f17
    !      read(2,9090)f18
    !      read(2,9090)f19
    read(2,9090,end=9088)f10
    iInitial = index(f10,'#')
    if (iInitial.ne.0) go to 9088
    if(f5.ne.f10.and.f10.ne.blank) then
        open(13,file='fort.13',FORM='UNFORMATTED')
        open(10,file=f10)
        !       iuHead = 10
    end if
    read(2,9090,end=9089)f12
9089 continue     
9088 open(5,file=f5)
    open(6,file=f6)
    open(7,file=f7)
    open(8,file=f8)
    open(9,file=f9)
    open(11,file=f11)
    !      open(14,file=f14)
    !      open(15,file=f15)
    !      open(16,file=f16)
    !      open(17,file=f17)
    !      open(18,file=f18)
    !      open(19,file=f19)
9090 format(a80)
    !
    !-------------------------------------------------------------------
    !
    !  ---- READ AND WRITE PROBLEM TITLE AND SPACE AND TIME CONSTANTS
    !
    JSTOP=0
    RM_OK=.TRUE.
    ! Line A-1
    READ(5,4000,IOSTAT=myerr) TITL
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-1:  TITL'
        flush(6)
        JSTOP = 201
        return
    endif
    ! Line A-2
    READ(5,*,IOSTAT=myerr) TMAX,STIM,ANG
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-2:  TMAX,STIM,ANG'
        flush(6)
        JSTOP = 202
        return
    endif
    ! Line A-3
    READ(5,4010,IOSTAT=myerr) ZUNIT,TUNIT,CUNX,HUNX
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-3:  ZUNIT,TUNIT,CUNX,HUNX'
        flush(6)
        JSTOP = 203
        return
    endif
    !      READ(5,4011) TUNIT
    !      READ(5,4010) CUNX
    !      READ(5,4010) HUNX
    CNVTM = 1.D0
    IF(TUNIT.EQ.'s'.or.TUNIT.EQ.'seconds')then
        CNVTM= 1.D0
    ELSE IF (TUNIT.EQ.'min'.or.TUNIT.EQ.'minutes')then
        CNVTM=60.D0
    ELSE IF (TUNIT.EQ.'h'.or.TUNIT.EQ.'hours')then
        CNVTM=3600.D0
    ELSE IF (TUNIT.EQ.'d'.or.TUNIT.EQ.'days')then
        CNVTM=864000.D0
    ELSE IF (TUNIT.EQ.'yr'.or.TUNIT.EQ.'years')then
        CNVTM=3.155815D7
    END IF
    CNVTMI= 1.D0/ CNVTM    
    ! Line A-4
    READ(5,*,IOSTAT=myerr) NXR,NLY
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-4:  NXR,NLY'
        flush(6)
        JSTOP = 204
        return
    endif
    if(NXR .GT. 2) THEN 
        axes(1)= .true.
    ELSE IF (NXR .EQ. 2)then
        axes(1)= .false.
    END IF
    if(NLY .GT. 2) THEN 
        axes(2)= .true.
    ELSE IF (NLY.EQ. 2)then
        axes(2)= .false.
    END IF
    ! Line A-5
    READ(5,*,IOSTAT=myerr) NRECH,NUMT
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-5:  NRECH,NUMT'
        flush(6)
        JSTOP = 205
        return
    endif
    !
    !  o13p triggers high precisions output
    !  o12p triggers p,c unformatted output to file 12
    !  o9p = t for MB output only at specified times
    !  o11p = t for obsPoint output only at specified times
    !
    if(NUMT.lt.0) then
        numt = -numt
        o13p = .TRUE.
    else
        o13p = .FALSE.
    end if
    if (nrech.lt.0) then
        nrech = -nrech
        o12p = .TRUE.
    else
        o12p = .FALSE.
    end if
    WRITE (06,4060)
    WRITE (06,4070) TITL,TMAX,TUNIT,STIM,NRECH,NUMT,NLY,NXR
    WRITE(06,4080) ANG
    IF(ANG.GT.90.0D0.OR.ANG.LT.-90.0D0)THEN
        WRITE(06,4090)
        jstop=2
        return
    END IF
    ! Line A-6
    READ(5,*,IOSTAT=myerr) RAD,ITSTOP,HEAT,SOLUTE
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-6:  RAD,ITSTOP,HEAT,SOLUTE'
        flush(6)
        JSTOP = 206
        return
    endif
    IF (SOLUTE) then
    ! Line A-7
        READ(5,4001,IOSTAT=myerr) CHEMFILE
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-7:  CHEMFILE'
            flush(6)
            JSTOP = 207
            return
        endif
    ! Line A-8
        READ(5,4001,IOSTAT=myerr) DATABASEFILE
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-8:  DATABASEFILE'
            flush(6)
            JSTOP = 208
            return
        endif
    ! Line A-9
        READ(5,4001,IOSTAT=myerr) PREFIX
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-9:  PREFIX'
            flush(6)
            JSTOP = 209
            return
        endif
    End if
    IF(HEAT.OR.SOLUTE) then 
        TRANS = .TRUE.
        FLOW = .FALSE.
    else
        TRANS = .FALSE.
        FLOW = .TRUE.
    END IF
    IF(TRANS) then
    ! Line A-10
        READ(5,*,IOSTAT=myerr)CIS,CIT
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-10: CIS,CIT'
            flush(6)
            JSTOP = 210
            return
        endif
    endif
    INPRXZ = 0
    IF(SOLUTE)THEN
    ! Line A-11
        READ(5,*,IOSTAT=myerr)INPRXZ
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-11: INPRXZ'
            flush(6)
            JSTOP = 211
            return
        endif
    END IF    
    ! Line A-12 
    READ(5,*,IOSTAT=myerr) F11P,F7P,F8P,F9P,F6P
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-12:  F11P,F7P,F8P,F9P,F6P'
        flush(6)
        JSTOP = 212
        return
    endif
    ! Line A-13
    READ(5,*,IOSTAT=myerr) THPT,SPNT,PPNT,HPNT,VPNT
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-13:  THPT,SPNT,PPNT,HPNT,VPNT'
        flush(6)
        JSTOP = 213
        return
    endif
    WRITE (06,4100) F8P,ITSTOP,F7P,F11P,F9P,F6P
    WRITE (06,4110) THPT,SPNT,PPNT,HPNT,VPNT   
    NLYY=NLY-1
    NXRR=NXR-1
    NNODES=NLY*NXR
    Nsol=0
    IF (SOLUTE)then
        CALL CreateRM(SOLUTE, NNODES,  PREFIX, DATABASEFILE, CHEMFILE, nSol)
        if (nSol .eq. 0) then
            RM_OK = .FALSE. 
        end if
        !#CALL PHREEQC_MAIN(SOLUTE,CHEMFILE,DATABASEFILE,PREFIX)
        !#SCOMPNAME= "          "
        !#CALL COUNT_ALL_COMPONENTS(Nsol, SCOMPNAME)
        status = RM_GetComponents(rm_id, scompname)
        Nodesol= NNODES*Nsol  
    END IF
    IF(PPNT.OR.HPNT)THEN
        F14P=.TRUE.
    ELSE
        F14P=.false.
    END IF    
    IF(SOLUTE)THEN
        F15P=.TRUE.
    ELSE
        F15P=.false.
    END IF
    IF(HEAT)THEN
        F16P=.TRUE.
    ELSE
        F16P=.false.
    END IF  
    IF(VPNT)THEN
        F17P=.TRUE.
    ELSE
        F17P=.false.
    END IF
    IF(THPT)THEN
        F18P=.TRUE.
    ELSE
        F18P=.false.
    END IF
    IF(SPNT)THEN
        F19P=.TRUE.
    ELSE
        F19P=.false.
    END IF
    KNLY=NlY-2
    KNXR=NXR-2
    KNNODE=KNLY*KNXR
    !!@@include 'd_arrays.inc' 
    !     allocate arrays
    allocate(DELZ(NLY),DZZ(NLY),DXR(NXR),RX(NXR))
    allocate(HX(NNODES),NTYP(NNODES))
    allocate(THETA(NNODES),THLST(NNODES),SATUR(NNODES),POROSITY(NNODES))
    allocate(P(NNODES),PXXX(NNODES),THEAD(NNODES))
    allocate(Q(NNODES),QQ(NNODES))
    allocate(HCND(NNODES),HKLL(NNODES),HKTT(NNODES))
    allocate(A(NNODES),B(NNODES),C(NNODES),D(NNODES),E(NNODES),  &
    RHS(NNODES),XI(NNODES))
    allocate(AS(NNODES),BS(NNODES),CS(NNODES),DS(NNODES),ES(NNODES),  &
    RHSS(NNODES),XIS(NNODES))
    allocate(JTEX(NNODES))
    allocate(DUM(NNODES),PDUM(KNXR))
    allocate(DPTH(NNODES),RT(NNODES))
    allocate(DX1(NNODES),DX2(NNODES),DZ1(NNODES),DZ2(NNODES),  &
    TT(NNODES),TTOLD(NNODES),TS(NNODES),  &
    QT(NNODES),NHTYP(NNODES))
    allocate(VX(NNODES),VZ(NNODES))
    allocate(RHO(NNODES),RHOOLD(NNODES))
    allocate(DXS1(NNODES),DXS2(NNODES),DZS1(NNODES),DZS2(NNODES),  &
    CC(Nsol,NNODES),CCOLD(Nsol,NNODES),CSS(Nsol,NNODES),  &
    QS(NNODES),NCTYP(NNODES),CONC(Nsol))
    allocate(AO(NNODES),BO(NNODES),CO(NNODES),DO(NNODES),EO(NNODES))
    allocate(AOC(NNODES),BOC(NNODES),COC(NNODES),DOC(NNODES),EOC(NNODES))
    allocate(PITT(NNODES))
    allocate(DEL(NNODES),ETA(NNODES),V(NNODES))
    allocate(TempC(NNODES))
    allocate(XNODE(NNODES),ZNODE(NNODES))
    allocate(phreeC(Nodesol))
    allocate(CMIXFARC(7,NNODES),BCSOL(Nsol),INDSOL1(7,NNODES),INDSOL2(7,NNODES))
    allocate(ic1_reordered(nnodes,7))
    allocate(NPRCHEM(NNODES),NPRCHXZ(NNODES),NPRCHOBS(NNODES))
    allocate(BLSOL(Nsol,36),bl62I(Nsol),bl62IT(Nsol),bl62O(Nsol),bl62OT(Nsol), &
    bcmtt(Nsol),bcmt(Nsol),bcmtr(Nsol),bltemp36(Nsol),bltemp39(Nsol), &
    bltemp42(Nsol),bltemp45(Nsol),bltemp60(Nsol))
    allocate(COMPNAME(Nsol))       
    allocate(CCBR(Nsol,NNODES),CCAR(Nsol,NNODES))      
    
    allocate (a_gmr(5*nnodes))
    allocate (rhs_gmr(nnodes))
    !      allocate (x3(nnodes))
    allocate (ia_gmr(5*nnodes))
    allocate (ja_gmr(5*nnodes))
    
    IF (SOLUTE) THEN  
        DO 7 I=1,Nsol 
            compname(I)  = scompname(I)
            WRITE(06,4012)compname(I)
7       CONTINUE       
    END IF 
    !      include 'c_arrays.inc'
    elimit1 = 1.0d-70
    elimit2 = 0.0d0
    ! *** SET ALL ARRAYS TO ZERO
    DO 710 I=1, NLY
        DELZ(I) = 0.0D0
        DZZ(I) = 0.0D0
710 CONTINUE
    DO 715 I=1, NXR
        DXR(I) = 0.0D0
        RX(I) = 0.0D0
715 CONTINUE
    do 8 I=1, Nodesol
        phreeC(I)=0.d0
8   continue
    DO 711 I=1, NNODES
        !XNODE(I)= 0.0D0
        !ZNODE(I)= 0.0D0  
        XNODE(I)= 0
        ZNODE(I)= 0
        HX(I) = 0.0D0
        NTYP(I) = 0
        THETA(I) = 0.0D0
        THLST(I) = 0.0D0
        SATUR(I)=0.0D0
        P(I) = 0.0D0
        PXXX(I) = 0.0D0
        THEAD(I)=0.0D0
        Q(I) = 0.0D0
        QQ(I) = 0.0D0
        HCND(I) = 0.0D0
        HKLL(I) = 0.0D0
        HKTT(I) = 0.0D0
        A(I) = 0.0D0
        B(I) = 0.0D0
        C(I) = 0.0D0
        D(I) = 0.0D0
        E(I) = 0.0D0
        RHS(I) = 0.0D0
        XI(I) = 0.0D0
        AS(I) = 0.0D0
        BS(I) = 0.0D0
        CS(I) = 0.0D0
        DS(I) = 0.0D0
        ES(I) = 0.0D0
        RHSS(I) = 0.0D0
        JTEX(I) = 0
        DUM(I) = 0.0D0
        DPTH(I) = 0.0D0
        RT(I) = 0.0D0
        DX1(I) = 0.0D0
        DX2(I) = 0.0D0
        DZ1(I) = 0.0D0
        DZ2(I) = 0.0D0
        DXS1(I) = 0.0D0
        DXS2(I) = 0.0D0
        DZS1(I) = 0.0D0
        DZS2(I) = 0.0D0
        VX(I) = 0.0D0
        VZ(I) = 0.0D0
        TT(I) = 0.0D0
        TTOLD(I) = 0.0D0
        TS(I) = 0.0D0
        QT(I) = 0.0D0
        QS(I) = 0.0D0
        TempC(I)=0.0D0
        NHTYP(I) = 0
        NCTYP(I) = 0
        AO(I) = 0.0D0
        BO(I) = 0.0D0
        CO(I) = 0.0D0
        DO(I) = 0.0D0
            EO(I) = 0.0D0
            AOC(I) = 0.0D0
            BOC(I) = 0.0D0
            COC(I) = 0.0D0
            DOC(I) = 0.0D0
            EOC(I) = 0.0D0
            PITT(I) = 0.0D0
            XIS(I)=0.0D0
            RHO(I) = 0.0D0
            RHOOLD(I) = 0.0D0
            NPRCHEM(I) = 0
            NPRCHXZ(I) = 0
            NPRCHOBS(I) = 0
711 CONTINUE
    DO 714 I=1, NNODES
        DO 713 M=1, Nsol
            CC(M,I) = 0.0D0
            CCOLD(M,I) = 0.0D0
            CSS(M,I) = 0.0D0
            CCBR(M,I)= 0.0D0
            CCAR(M,I)= 0.0D0
713     CONTINUE  
714 CONTINUE
    DO 801 J=1, NNODES
        DO 800 I=1, 7
            INDSOL1(I,J)= -1
            INDSOL2(I,J)= -1
            CMIXFARC(I,J) = 0.0D0
800     CONTINUE
801 CONTINUE
    DO 712 I=1,99
        BL(I)=0.0D0
712 CONTINUE
    bcmft = 0.0D0
    bcmht = 0.0D0
    bl29I = 0.0D0
    bl29IT = 0.0D0
    bl29O = 0.0D0
    bl29OT = 0.0D0
    bl95I = 0.0D0
    bl95IT = 0.0D0
    bl95O = 0.0D0
    bl95OT = 0.0D0
    DO 717 M=1,Nsol
        bl62I(M) = 0.0D0
        bl62IT(M) = 0.0D0
        bl62O(M)= 0.0D0
        bl62OT(M) = 0.0D0
        DO 716 J=1,36
            BLSOL(M,J)= 0.0D0
            bcmtt(M)=0.0D0
716     CONTINUE
717 CONTINUE

    DO 5 I=1,NNODES
        NPRCHEM(I)= 1
        NPRCHXZ(I)= INPRXZ
5   CONTINUE   

    !
    !   ESTABLISH HORIZONTAL OR RADIAL SPACING
    !
    ! Line A-14
    READ(5,*,IOSTAT=myerr) IFAC,FACX
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-14:  IFAC,FACX'
        flush(6)
        JSTOP = 214
        return
    endif
    IF(IFAC.GT.0) GO TO 20
    !
    !   READ IN SPACING FOR EACH COLUMN
    !
    ! Line A-15
    READ(5,*,IOSTAT=myerr) (DXR(K),K=1,NXR)
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-15: (DXR(K),K=1,NXR)'
        flush(6)
        JSTOP = 215
        return
    endif
    DO 10 K=1,NXR
10  DXR(K)=DXR(K)*FACX
    GO TO 60
20  IF(IFAC.EQ.2) GO TO 40
    DO 30 K=1,NXR
30  DXR(K)=FACX
    GO TO 60
    !
    !  IF IFAC=2, HORIZONTAL NODE SPACING IS INCREMENTED BY A CONSTANT
    !    MULTIPLIER UNTIL A USER-SPECIFIED MAXIMUM IS REACHED, WHERE-
    !    UPON THE SPACING BECOMES CONSTANT
    !
    ! Line A-16
40  READ(5,*,IOSTAT=myerr) XMULT,XMAX
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-16:  XMULT,XMAX'
        flush(6)
        JSTOP = 216
        return
    endif
    DXR(1)=FACX
    DXR(2)=FACX
    DO 50 K=3,NXRR
        DXR(K)=DXR(K-1)*XMULT
        IF(DXR(K) .GT. XMAX)DXR(K)=XMAX
50  CONTINUE
    DXR(NXR)=DXR(NXRR)
    !
    !   ESTABLISH VERTICAL SPACING
    !
    ! Line A-17
60  READ(5,*,IOSTAT=myerr) JFAC,FACZ
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-17:  JFAC,FACZ'
        flush(6)
        JSTOP = 217
        return
    endif
    IF(JFAC.GT.0) GO TO 80
    !
    !   READ IN VERTICAL SPACINGS INDIVIDUALLY
    !
    ! Line A-18
    READ(5,*,IOSTAT=myerr) (DELZ(K),K=1,NLY)
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-18:  (DELZ(K),K=1,NLY)'
        flush(6)
        JSTOP = 218
        return
    endif
    DO 70 K=1,NLY
70  DELZ(K)=DELZ(K)*FACZ
    GO TO 120
80  IF(JFAC.EQ.2) GO TO 100
    DO 90 K=1,NLY
90  DELZ(K)=FACZ
    GO TO 120
    !
    !   ESTABLISH VERTICAL SPACING BY PROGRESSION, AS ABOVE FOR HORIZ.
    !
    ! Line A-19
100 READ(5,*,IOSTAT=myerr) ZMULT,ZMAX
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading A-19:  ZMULT,ZMAX'
        flush(6)
        JSTOP = 219
        return
    endif
    DELZ(1)=FACZ
    DELZ(2)=FACZ
    DO 110 K=3,NLYY
        DELZ(K)=DELZ(K-1)*ZMULT
        IF(DELZ(K) .GT. ZMAX)DELZ(K)=ZMAX
110 CONTINUE
    DELZ(NLY)=DELZ(NLYY)
120 CONTINUE
    !
    !    DETERMINE HORIZONTAL AND VERTICAL COORDINATES
    !
    RX(1)=-0.5D0 *DXR(1)
    DO 130 N=2,NXR
        RX(N)=RX(N-1)+0.5D0 *(DXR(N-1)+DXR(N))
130 CONTINUE
    DZZ(1)=-0.5D0 *DELZ(1)
    DO 140 J=2,NLY
140 DZZ(J)=DZZ(J-1)+0.5D0 *(DELZ(J-1)+DELZ(J))
    DO 11 I=1,NNODES
        IMOD=MOD(I,NLY)
        XNODE(I)= (I-IMOD)/NLY + MIN(1,IMOD)
        IF(IMOD .EQ.0) THEN
            ZNODE(I)=NLY
        ELSE
            ZNODE(I)= IMOD
        END IF      
11  CONTINUE
    !      DO 12 I=1,NNODES 
    !      write(6,*)"XNODE(",I,")=", XNODE(I),"ZNODE(",I,")=", ZNODE(I)
    !  12  CONTINUE
    WRITE (06,4120) ZUNIT,(DELZ(K),K=1,NLY)
    WRITE (06,4130) ZUNIT,(DXR(K),K=1,NXR)
    PI=3.141592654D0
    PI2=PI+PI
    ANG=ANG/360.0D0
    IF(ANG.EQ.0.0D0) THEN
        CS1=1.0D0
        CS2=0.0D0
    ELSE
        IF(ANG.EQ.0.25D0.OR.ANG.EQ.-0.25D0) THEN
            CS1=0.0D0
        ELSE
            CS1=DCOS(ANG*PI2)
        END IF
        CS2=-DSIN(ANG*PI2)
    END IF
    !
    !    READ DATA FOR MONITORING TIMES AND POINTS
    !
    NPLT=0
    o9p = .false.
    o11p = o9p
    IF(F8P) THEN
    ! Line A-20
        READ(5,*,IOSTAT=myerr) NPLT
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-20:  NPLT'
            flush(6)
            JSTOP = 220
            return
        endif
        !!@@include 'd_obst.inc'
        allocate(PLTIM(NPLT+1))
        !      include 'c_obst.inc'
        IF(NPLT.EQ.0)NPLT=1
    ! Line A-21
        READ(5,*,IOSTAT=myerr) (PLTIM(K),K=1,NPLT)
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-21:  (PLTIM(K),K=1,NPLT)'
            flush(6)
            JSTOP = 221
            return
        endif
        WRITE (06,4140) (PLTIM(K),K=1,NPLT)
    else
        !!@@include 'd_obst.inc'
        allocate(PLTIM(NPLT+1))      
    END IF
    IF(F11P) THEN
    ! Line A-22
        READ(5,*,IOSTAT=myerr) NOBS
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-22:  NOBS'
            flush(6)
            JSTOP = 222
            return
        endif
        if (nobs.lt.0) then
            nobs = -nobs
            o11p = .true.
        end if
        !!@@include 'd_obsp.inc'
        allocate(IJOBS(NOBS))
        if (allocated(KDUM)) deallocate(KDUM)
        allocate(KDUM(NOBS,2))
    ! Line A-23  
        READ(5,*,IOSTAT=myerr) ((KDUM(K,J),J=1,2),K=1,NOBS)
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-23:  ((KDUM(K,J),J=1,2),K=1,NOBS)'
            flush(6)
            JSTOP = 223
            return
        endif
        WRITE (06,4150) ((KDUM(K,J),J=1,2),K=1,NOBS)
        !      include 'c_obsp.inc'
        DO 150 K=1,NOBS
            N=NLY*(KDUM(K,2)-1)+KDUM(K,1)
            IJOBS(K)=N
150     continue
    END IF
    IF (F9P) THEN
    ! Line A-24
        READ(5,*,IOSTAT=myerr)NMB9
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-24: NMB9'
            flush(6)
            JSTOP = 224
            return
        endif
        if (nmb9.lt.0) then
            nmb9 = -nmb9
            o9p = .true.
        end if
        if (nmb9.gt.99) nmb9 = 99
    ! Line A-25
        READ(5,*,IOSTAT=myerr) (MB9(K),K=1,NMB9)
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading A-25:  (MB9(K),K=1,NMB9)'
            flush(6)
            JSTOP = 225
            return
        endif
        WRITE(06,4160) (MB9(K),K=1,NMB9)
    END IF
    PLTIM(NPLT+1)=TMAX+TMAX
    !      WRITE (14,4002) NLY,NXR 
    !      WRITE (15,4002) NLY,NXR
    !      WRITE (16,4002) NLY,NXR
    !      WRITE (17,4002) NLY,NXR
    !      WRITE (18,4002) NLY,NXR
    !      WRITE (19,4002) NLY,NXR
    IF(RAD) THEN
        WRITE(06,4050)
    ELSE
        WRITE (06,4040)
    END IF
    IF(TRANS) THEN
        WRITE(06,4240)
        IF(CIS) THEN
            WRITE(6,4200)
        ELSE
            WRITE(6,4210)
        END IF
        IF(CIT) THEN
            WRITE(6,4220)
        ELSE
            WRITE(6,4230)
        END IF
    END IF
    IF(F11P) then
        if (o13p) then
            if(trans) then
                if(heat.AND.solute)then
                    WRITE (11,4033) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
                    (COMPNAME(M),M=1,Nsol)
                else if(heat.AND.(.NOT.solute))then
                    WRITE (11,4034) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
                else  
                    WRITE (11,4035) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
                    (COMPNAME(M),M=1,Nsol)
                end if 
            else
                WRITE (11,4031) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
            end if
        else
            if(trans) then
                if(heat.AND.solute)then
                    WRITE (11,4032) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT, &
                    (COMPNAME(M),M=1,Nsol)
                else if(heat.AND.(.NOT.solute))then
                    WRITE (11,4036) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
                else  
                    WRITE (11,4037) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT,  &
                    (COMPNAME(M),M=1,Nsol)
                end if 
            else
                WRITE (11,4030) TITL,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT
            end if
        end if
    end if
    !
    !     INITIALIZE CONSTANTS
    !
    ITEST=0
    ITESTS=0
    KTIM=0
    NITT=0
    NITT1=0
    NITT2=0
    NISS=0
    NISS1=0
    JFLAG=1
    KP=0
    JPLT=0
    WRITE (06,4170) 
    !
    !
    !   READ AND WRITE INITIAL VALUES OF PRESSURE HEAD, TOTAL HEAD,
    !    THETA, AND SATURATION
    !-------------------------------------------------------------
    !
    CALL VSREAD
    CALL VSSIP
    CALL VSSIPSOL
    IFET=0
    IFET2=0
    CALL VSOUTP
    !!@@include 'd_kdumDealloc.inc'
    if(allocated(kdum)) deallocate(kdum)
    RETURN
4000 FORMAT(A80)
4001 FORMAT(A15)
4002 FORMAT(I5,I5)
4010 FORMAT(4A4)
4011 FORMAT(A7) 
4012 FORMAT(A10)
4020 FORMAT(5X,20(1H*),1X,31HDIMENSIONS TOO LARGE FOR ARRAYS,  &
1   X,20(1H*)/5X,6HNLY = ,I6,2X,6H,NXR = ,I6)
4030 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
5   x,'NODE',3x,  &
6   H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
3   X,6H THETA,5X,8H     SAT,5x,'      VX',5x,'      VZ' &
5   x,'      ET')
4031 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
    'NODE',15x,  & 
6   H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
12  X,6H THETA,12X,8H     SAT,12x,'      VX',12x,'      VZ',  &
12  x,'      ET')
4032 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
5   x,'NODE',3x,  &
6   H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
3   X,6H THETA,5X,8H     SAT,10x,'TEMP',5x,'      VX',5x,  &
    '      VZ', 5x,'      ET',50(1x,A10))
4033 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
    'NODE',15x,  &
6   H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
12  X,6H THETA,12X,8H     SAT,17x,'TEMP',12x,'      VX',12x,  &
    '      VZ',12x,'      ET',50(1x,A10))
4034 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
    'NODE',15x,  &
6   H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
12  X,6H THETA,12X,8H     SAT,17x,'TEMP',12x,'      VX',12x,  &
    '      VZ',12x,'      ET')   
4035 FORMAT(A80/21HMONITORING POINT FILE/7X,6HTIME,  ,A7,6X,  &
    'NODE',15x,  &
6   H XR,  ,A6,10X,6H Z,    ,A6,10X,6H H,   ,A6,10X,6H  P,  ,A6,  &
12  X,6H THETA,12X,8H     SAT,17x,'      VX',12x,  &
    '      VZ',12x,'      ET',50(1x,A10))    
4036 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
5   x,'NODE',3x,  &
6   H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
3   X,6H THETA,5X,8H     SAT,10x,'TEMP',5x,'      VX',5x,  &
    '      VZ', 5x,'      ET') 
4037 FORMAT(A80/21HMONITORING POINT FILE/2X,6HTIME,  ,A7,2X,  &
5   x,'NODE',3x,  &
6   H XR,  ,A6,3X,6H Z,    ,A6,3X,6H H,   ,A6,3X,6H  P,  ,A6,  &
3   X,6H THETA,5X,8H     SAT,10x,'      VX',5x,  &
    '      VZ', 5x,'      ET',50(1x,A10))                 
4040 FORMAT(5X,32HCOORDINATE SYSTEM IS RECTANGULAR)
4050 FORMAT(5X,27HCOORDINATE SYSTEM IS RADIAL)
4060 FORMAT(35X,60('+')/35X,'+',26X,7H VS2DRT,25X,'+'/35X,  &
    '+',23x,' VERSION 1.1',23x,'+'/35x,  &
    '+',11X,'SIMULATION OF 2-DIMENSIONAL VARIABLY',11X,'+'/  &
35  X,'+',12X,'SATURATED REACTIVE TRANSPORT',18X,'+'  &
    /35X,'+',11X,'        THROUGH POROUS MEDIA.       ',11X,'+'  &
    /35X,60('+')//)
4070 FORMAT(//,1X,100(1H*)/5X,A80/1X,100(1H*)//10X,  &
24  HSPACE AND TIME CONSTANTS/10X,23(1H-)/  &
5   X,26HMAXIMUM SIMULATION TIME = ,E14.6,1X,A4/  &
5   X,'STARTING TIME = ',F10.4,/  &
5   X,28HNUMBER OF RECHARGE PERIODS =,I10/ &
4   X,32H MAXIMUM NUMBER OF TIME STEPS = ,I10/  &
5   X,17HNUMBER OF ROWS = ,I6/5X,20HNUMBER OF COLUMNS = ,I6)
4080 FORMAT(5X,'AXES TILTED BY ANGLE = ',F8.2)
4090 FORMAT(1X,'ANGLE OF AXES TILTING MUST BE BETWEEN -90 AND 90 ',  &
    'DEGREES',/,1X,'SIMULATION TERMINATED')
4100 FORMAT(10X,16HSOLUTION OPTIONS/10X,16(1H-)/ &
5   X,'WRITE ALL PRESSURE HEADS TO FILE 8',  &
23  H AT OBSERVATION TIMES? ,L1,/  &
5   X,'STOP SOLUTION IF MAXIMUM NO.',  &
    ' OF ITERATIONS EXCEEDED IN ANY TIME STEP? ',L1/5X,  &
    'WRITE BOUNDARY FLUXES TO FILE 7? ',  &
    L1/5X,'WRITE RESULTS AT SELECTED OBSERVATION POINTS TO ',  &
    'FILE 11? ', L1/,5X,'WRITE MASS BALANCE RATES TO FILE 9? ',L1/ &
5   X,'WRITE MASS BALANCE RATES TO FILE 6? ',L1)
4110 FORMAT(1H ,4X,35HWRITE MOISTURE CONTENTS TO FILE 6? ,L1/ &
5   X,29HWRITE SATURATIONS TO FILE 6? ,L1/ &
5   X,32HWRITE PRESSURE HEADS TO FILE 6? ,L1/  &
5   X,29HWRITE TOTAL HEADS TO FILE 6? ,L1/  &
5   X,'WRITE VELOCITIES TO FILE 6? ',L1)
4120 FORMAT(50X,39HGRID SPACING IN VERTICAL DIRECTION, IN ,A4/ &
    (10(F10.3)))
4130 FORMAT(50X,47HGRID SPACING IN HORIZONTAL OR RADIAL DIRECTION,  &
    ,3H IN,1X,A4/(10F10.3))
4140 FORMAT(5X,43HTIMES AT WHICH H WILL BE WRITTEN TO FILE 08 &
    /10(5X,10E12.5,/))
4150 FORMAT(5X,37HROW AND COLUMN OF OBSERVATION POINTS:/ &
10  (2X,2I5))
4160 FORMAT(5X,'MASS BALANCE COMPONENTS WRITTEN TO FILE 9',  &
    /,5X,24I4)
4170 FORMAT(5X,36HMATRIX EQUATIONS TO BE SOLVED BY SIP)
4180 FORMAT(5X,100(1H*)/5X,17HEND OF SIMULATION/ &
5   X,100(1H*))
4190 FORMAT(5X,'TOTAL NUMBER OF ITERATIONS FOR FLOW EQUATION = ',I6  &
    /5X,'TOTAL NUMBER OF ITERATIONS FOR TRANSPORT EQUATION = ',I6)
4200 FORMAT(5X,'CENTRAL DIFFERENCING IN SPACE USED FOR TRANSPORT',  &
    ' EQUATION')
4210 FORMAT(4X,' BACKWARD DIFFERENCING IN SPACE USED FOR TRANSPORT',  &
    ' EQUATION')
4220 FORMAT(4X,' CENTRAL DIFFERENCING IN TIME USED FOR TRANSPORT',  &
    ' EQUATION')
4230 FORMAT(4X,' BACKWARD DIFFERENCING IN TIME USED FOR TRANSPORT',  &
    ' EQUATION')
4240 FORMAT(4X,' TRANSPORT TO BE SIMULATED')
4250 FORMAT(4X,' NONLINEAR SORPTION TO BE SIMULATED')
    END
    SUBROUTINE STEP()
    !*** THIS IS THE SECOND HALF OF THE ORIGINAL MAIN CODE. THIS
    !*** PERFORMS A SINGLE TIME STEP. THE LOOPING IS DONE IN THE CALLING
    ! *** PROGRAM. THE SUBROUTINE RETURNS THE SIMULATION TIME, TIME STEP,
    ! *** AND THE FLAG JSTP. WHEN JSTP EQUALS 1, THIS SIGNIFIES
    ! *** END OF SIMULATION.
    use rspac
    use kcon
    use mprop
    use press
    use disch
    use hcon
    use equat
    use jtxx
    use dumm
    use ptet
    use trxx
    use trxy1
    use plott
    use spfc
    use rpropsh
    use scon
    use equats
    use trxy2
    use trxxh
    use trxv
    use temp
    use tempcc   
    use pricon
    use coordin
    use solindex
    use phreecc
    use react
    use SCON
    USE vs2dt_rm
    USE PhreeqcRM  
    USE reduce_time
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    common/conversion/CNVTM,CNVTMI 
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/PND/POND
    COMMON/WGT/WUS,WDS
    COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
    CHARACTER*80 TITL,filen,f5,f6,f7,f8,f9,f10,f11
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType      
    COMMON/TTT/ IFET,IFET1,NITT,NITT1,NITT2
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/TTT1/NISS,NISS1,NISS2
    COMMON/FLO/FLOW
    COMMON/SCON1/ITESTS
    character(100) msg
    integer :: iPRNT
    integer :: ifet2 = 0
    integer :: numReductions

    !
    ! -------------------------------------------------------------
    !       START OF TIME LOOP
    ! -------------------------------------------------------------
    !
160 IF(JFLAG.EQ.1)IFET1=1
    IF (JSTOP.GT.1) THEN
        RETURN
    ENDIF
    IF(.NOT.RM_OK) THEN
        JSTOP=12
        RETURN
    ENDIF
    CALL VSTMER
    !
    ! *** IF NO MORE PERIODS TO SIMULATE, JSTOP IS SET TO 1 IN VSTMER,
    ! *** WE JUST RETURN AND LET THE CALLING PROGRAM TERMINATE THE
    !*** THE EXECUTION
    IF (JSTOP.GT.1) THEN
        RETURN
    ENDIF
    
    write(stderr,"(A,F12.4)") "Beginning time: ", stim
    !
    TRANS1=.FALSE.
    !     IF(.NOT.SSTATE) THEN
    !
    !   SET UP AND SOLVE MATRIX EQUATIONS FOR FLOW
    !
    numReductions = 0
    NIT3=0
    TRANS2=.FALSE.
170 TRANS1=.FALSE.
    !
    !   SET UP AND SOLVE MATRIX EQUATIONS FOR FLOW
    !
    if((nit3.gt.100) .or. (jstop .eq.10)) then
        nit3=0
        reduce_time_step = .true.
        jstop = 0
        if (numReductions.ge.3) then
          write(6,4000)
          jstop = 13
          return
        end if
        numReductions = numReductions + 1
        write(stderr,*) "WARNING: Reducing time step."        !jstop = 11
        !return
    else
        reduce_time_step = .false.
    end if
    nit=0
    CALL VSMGEN
    IF (JSTOP.GT.1) THEN
        RETURN
    ENDIF
    !
    !   CHECK FOR PONDING DURING THIS TIME STEP
    !
    CALL VSPOND(IFET,IFET1,IFET2)
    !
    !   IF PONDING HAS OCCURRED, EQUATIONS NEED TO BE SOLVED AGAIN
    !
    IF(IFET.NE.0) THEN
        IF(NIT.LT.ITMAX) THEN
            DO 50 II=1,NNODES
                IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) P(II)=PXXX(II)
50          CONTINUE
            nit = 1
            GO TO 170
        ELSE
            WRITE(6,4260)
        END IF
    END IF
    !
    !   REEVALUATE NONLINEAR COEFFICIENTS
    !
    CALL VSCOEF
    NITT=NITT+NIT
    !     END IF
    !      IF((TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO
    IF(TRANS.OR.VPNT) CALL VTVELO
    !
    !  Heat transport
    !        
    IF(HEAT) THEN
        !      IF(.NOT.SSTATE) THEN
        !
        !   DETERMINE VELOCITIES AND DISPERSION TENSOR
        !
        CALL VTDCOEF
        !      END IF
        TRANS1=.TRUE.
        !
        !   SET UP AND SOLVE MATRIX EQUATION FOR TRANSPORT
        !
        CALL VTSETUP
        NITT1=NITT1+NIT1
        DMAX1=0.0D0
        NIT3=NIT3+1
        IF(NIT3.LT.2.OR.RHOMAX.GT.EPS2) GO TO 170
        DO 190 N=1,NNODES
            RHOOLD(N)=RHO(N)
190     CONTINUE
        NITT2=NITT2+NIT3
    END IF

    !
    ! Reactive solute transport      
    !      
    IF(SOLUTE) THEN
        !     
        !      IF(.NOT.SSTATE) THEN
        !
        !   DETERMINE VELOCITIES AND DISPERSION TENSOR
        !
        CALL VTDCOEFSOL
        ! 
        !     END IF
        TRANS2=.TRUE.

        !
        !   SET UP AND SOLVE MATRIX EQUATION FOR TRANSPORT
        !
        CALL VTSETUPSOL
        if (jstop .eq. 10) goto 170
        !      NISS=NISS+ NIS1
        !
        !   PRINT RESULTS AND COMPUTE MASS BALANCE COMPONENTS
        !
        DO 202 I=1, NNODES
            DO 201 J=1, Nsol
                !      K=Nsol*(I-1)+J
                !      phreeC(K)=CC(J,I)
                CCBR(J,I)=CC(J,I)
201         CONTINUE
202     CONTINUE
        !      write(*,*)'beforereactionnnnnnnnnnnnnnnnnnn'
        !      CALL VSOUTS(1,CC)
        do 161 J=1,NLY
            do 150 N=1,NXR
                IN=NLY*(N-1)+1
                IF(HX(IN).GT.0.0D0) THEN
                    if(hydraulicFunctionType.eq.0)then
                        THETA(IN)=VSTHUBC(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.1)then
                        THETA(IN)=VSTHUVG(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.2)then
                        THETA(IN)=VSTHUHK(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.4)then
                        THETA(IN)=VSTHUOT(P(IN),JTEX(IN))
                    end if
                ENDIF
150         CONTINUE
161     CONTINUE 
        iprrestartflag = 0 
        istopmsg = 0
        !#if (HEAT.AND.SOLUTE)THEN
        !#CALL EQUILIBRATEWHEAT( cc,hx,tt,NNODES,heat,nprconc,xnode,znode,  &
        !#tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
        !#theta,iprrestartflag)
        !#ELSE if((.not.heat).and.solute)then
        !#call EQUILIBRATE( cc,hx,NNODES,nprconc,xnode,znode,  &
        !#tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
        !#theta,iprrestartflag)  
        !#END IF
        IF (SOLUTE) THEN
            !call SetConcentrationsRM(cc)
            IF (JSTOP.GT.1) THEN
                RETURN
            ENDIF 
            IF (HEAT) THEN
                status = RM_SetTemperature(rm_id, tt)
            endif
            status = RM_SetTime(rm_id, stim)
            status = RM_SetTimeStep(rm_id, delt)
            status = RM_SetTimeConversion(rm_id, cnvtmi)
            status = RM_SetPrintChemistryMask(rm_id, nprchem)
            iPRNT = 0
            if (PRNT) iPRNT = 1
            status = RM_SetPrintChemistryOn(rm_id, iPRNT, 0, 0)
            DO J=1,NLY
                DO N=1,NXR
                    IN=NLY*(N-1)+J
                    SATUR(IN) = 0.0d0
                    IF(POROSITY(IN).GT.0.0D0.AND.HX(IN).GT.0.0D0.AND.NCTYP(IN).NE.1) THEN
                        SATUR(IN)=THETA(IN)/POROSITY(IN)
                    END IF
                enddo
            enddo
            status = RM_SetSaturation(rm_id, satur)
            call SetConcentrationsRM(cc)
            !if (npscrn .ne. 0) then
            !write(msg,"(A)") "   Chemistry"
            !status = RM_SetScreenOn(rm_id, 1)
            !status = RM_ScreenMessage(rm_id, msg)
            !status = RM_SetScreenOn(rm_id, 0)
            !endif
            write(stderr,"(A)") "   Chemistry"
            status = RM_RunCells(rm_id)
            call GetConcentrationsRM(cc)
            IF (JSTOP.GT.1) THEN
                RETURN
            ENDIF 
        END IF      
        if (solute) then
            if (heat) then
            endif
        endif
        !      write(*,*)'after...reactionnnnnnnnnnnnnnnnnnn'
        !      CALL VSOUTS(1,CC)
        DO 204 I=1, NNODES
            DO 203 J=1, Nsol
                K=Nsol*(I-1)+J
                CCAR(J,I)=CC(J,I)
203         CONTINUE
204     CONTINUE
    END IF
    !
    !   PRINT RESULTS AND COMPUTE MASS BALANCE COMPONENTS
    !
    CALL VSOUTP
    CALL VSFLUX
    !     IF(JSTOP.NE.1) GO TO 160
    !
    !-------------------------------------------------------------------
    !     END OF TIME LOOP
    !-------------------------------------------------------------------
    RETURN
4000 FORMAT(5x,'  Maximum number of time step reductions for transport' &
     ' (3) exceeded. Simulation stopped.')
4260 FORMAT(5X,'-- WARNING --  INFILTRATION/PONDING BOUNDARY WAS NOT',  &
    ' SOLVED ACCURATELY FOR THIS TIME STEP')
    END

    SUBROUTINE VSREAD
    !******
    !VSREAD
    !******
    !
    !   PURPOSE: TO READ INITIAL HEAD AND SATURATION DATA
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use jtxx
    use dumm
    use ptet
    use trxx
    use idumm
    use rpropsh
    use scon
    use equat
    use BF
    use equats
    use trxy2
    use trxxh
    use trxv
    use temp
    use coordin
    use solindex
    use phreecc
    use compnam
    use itemblo
    use itemtxb
    use react
    USE vs2dt_rm
    USE PhreeqcRM
    USE PRICON
    use SCON
    use ITEXS
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    common/conversion/CNVTM,CNVTMI 
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/WGT/WUS,WDS
    COMMON/JCON/JSTOP,JFLAG,jflag1
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL PHRD
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    CHARACTER*80 TITL
    CHARACTER*80 IFMT,FREE,UNFORMATTED
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT      
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    integer hydraulicFunctionType,iuTemperature,iuHead,iuConcentration
    common/functiontype/ hydraulicFunctionType
    !      COMMON/VERSION/VER2P5
    !     LOGICAL VER2P5
    common/iuNumber/ iuHead, iuConcentration,iuTemperature
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    integer NHTPROP,NSTPROP
    COMMON/TRANNSPROP/NHTPROP,NSTPROP
    COMMON/FLO/FLOW
    !      LOGICAL VER1P0
    !      COMMON/VERSION/VER1P0   
    !DIMENSION Solcomp(50)
    common/solind/ INSOL1(7),INSOL2(7),Solcomp(50)
    logical axes(2) 
    common/axis/axes
    common/ITEMK/KNLY,KNXR,KNNODE
    integer :: iu = 101
    INTEGER       :: myerr, iPRNT
    INTEGER, DIMENSION(:), ALLOCATABLE :: IIDUM

    !!@@include 'd_idummAlloc.inc'
    allocate(IDUM(NXR))
    !!@@include 'd_itembloAlloc.inc'
    allocate(ITEMBL(KNNODE),ITBDUM(KNXR))
    !!@@include 'd_itemtxbAlloc.inc'
    allocate(ITEMTX(KNNODE),ITDUM(KNXR))

    !-----------------------------------------------------------------------
    !
    !   READ AND WRITE INITIAL DATA FOR SIMULATION
    !
    FREE = 'free'
    UNFORMATTED = 'unformatted'
    !
    !     modified for reactive transport
    !     
    ! Line B-1
    READ(5,*,IOSTAT=myerr) EPS,HMAX,WUS
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-1:  EPS,HMAX,WUS'
        flush(6)
        JSTOP = 226
        return
    endif
    EPS1=0.0D0
    EPS2=0.0D0
    EPS3=0.0D0
    IF(HEAT) then
    ! Line B-2
        READ(5,*,IOSTAT=myerr)EPS1,EPS2
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-2: EPS1,EPS2'
            flush(6)
            JSTOP = 227
            return
        endif
    endif
    IF(SOLUTE) then
    ! Line B-3
        READ(5,*,IOSTAT=myerr)EPS3
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-3: EPS3'
            flush(6)
            JSTOP = 228
            return
        endif
    endif
    ! Line B-4
    READ(5,*,IOSTAT=myerr) MINIT,ITMAX
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-4:  MINIT,ITMAX'
        flush(6)
        JSTOP = 229
        return
    endif
    ! Line B-5
    READ(5,*,IOSTAT=myerr) PHRD
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-5:  PHRD'
        flush(6)
        JSTOP = 230
        return
    endif
    ! Line B-6
    READ(5,*,IOSTAT=myerr) NTEX,NPROP
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-6:  NTEX,NPROP'
        flush(6)
        JSTOP = 231
        return
    endif
    ! Line B-7
    READ(5,*,IOSTAT=myerr) hydraulicFunctionType
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-7:  hydraulicFunctionType'
        flush(6)
        JSTOP = 232
        return
    endif
    !      READ(5,*) iuTemperature
    NHTPROP = 0
    NSTPROP = 0
    IF(HEAT) NHTPROP=6
    IF(SOLUTE) NSTPROP=3
    !
    !  revision for Rossi-Nimmo
    !
    if (hydraulicFunctionType.eq.4) nprop = 19
    !!@@include 'd_rpropshAlloc.inc'
    allocate(HK(NTEX,NPROP))
    allocate(HT(NTEX,6))
    allocate(HS(NTEX,3))
    allocate(ANIZ(NTEX))
    allocate (ITEXSOL(NTEX,7))      
    if (hydraulicFunctionType.eq.4) nprop = 6
    !
    !  end revision
    !
    !
    !   CHECK THAT SUM OF WEIGHTING FACTORS IS EQUAL TO ONE
    !
    WRITE (6,4000) EPS,ZUNIT,EPS1,EPS2,EPS3,HMAX
    IF(WUS.EQ.1.0D0) THEN
        WDS=0.0D0
        WRITE(06,4020)
    ELSE
        IF(WUS.EQ.0.5D0) THEN
            WDS=0.5D0
            WRITE(06,4070)
        ELSE
            WUS=0.0D0
            WRITE(06,4010)
        END IF
    END IF
    WRITE (6,4080) NTEX,NPROP,NHTPROP,NSTPROP,MINIT,ITMAX
    !!@@include 'd_sconAlloc.inc'
    allocate (DHMX(ITMAX+1))
    !      include 'c_sconItmax
    WRITE (06,4100)
    IF (HEAT) WRITE(06,4110)
    IF (SOLUTE) WRITE(06,4111)
    !
    !   READ AND WRITE MATERIAL PROPERTIES FOR EACH TEXTURAL CLASS
    !

    DO 22 J22=1,NTEX
        DO 10 J23=1,NPROP
10      HK(J22,J23)=0.0D0
        DO 20 J23=1,NHTPROP
20      HT(J22,J23)=0.0D0
        DO 21 J23=1,NSTPROP
21      HS(J22,J23)=0.0D0
        DO 22 J23=1,7
22  ITEXSOL(J22,J23) = -1  

    DO 30 J22=1,NTEX
    ! Line B-8
        READ(5,*,IOSTAT=myerr) J
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-8:  ITEX'
            flush(6)
            JSTOP = 233
            return
        endif
    ! Line B-9
        READ(5,*,IOSTAT=myerr) ANIZ(J),(HK(J,I),I=1,NPROP)
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-9:  ANIZ(J),(HK(J,I),I=1,NPROP)'
            flush(6)
            JSTOP = 234
            return
        endif
        WRITE (6,4120) J,ANIZ(J),(HK(J,I),I=1,NPROP)
        IF(HEAT) THEN
            !
            !  modification to read for heat transport 
            !
    ! Line B-10
            read(5,*,IOSTAT=myerr) (HT(j,I),I=1,6)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-10:  (HT(j,I),I=1,6)'
                flush(6)
                JSTOP = 235
                return
            endif
            write(6,4130) (HT(j,I),I=1,6)
            HT(J,3)=HT(J,3)*(1.-HK(J,3))
        END IF
        IF(SOLUTE) THEN
            !
            !  modification to read for solute transport
            !
    ! Line B-11
            read(5,*,IOSTAT=myerr) (HS(j,I),I=1,3)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-11:  (HS(j,I),I=1,3),(ITEXSOL(J,I),I=1,7)'
                flush(6)
                JSTOP = 236
                return
            endif
            write(6,4131)(HS(j,I),I=1,3)
        END IF
        !
        !  revsion for Rossi-Nimmo
        !
        if(j.ne.1) then
            if (hydraulicFunctionType.eq.4) then
                hk(j,7) = hk(j,4)*(2.0D0/(2.0D0+hk(j,6)))**(-1.0D0/hk(j,6))
                hk(j,8) = .50D0*hk(j,6)*(2.0D0/(2.0D0+hk(j,6)))**((2.0D0+hk(j,6)/hk(j,6)))
                hk(j,9) =  hk(j,6)*exp(1.0D0)*(hk(j,4)/hk(j,5))**hk(j,6)
                hk(j,10) = hk(j,5)*exp(-1.0D0/hk(j,6))
                hk(j,11) = VSTHUOT(-hk(j,7),j)
                hk(j,12) = VSTHUOT(-hk(j,10),j)
                hk(j,14) = (hk(j,6) + 1.0D0)/hk(j,6)
                hk(j,15) = (hk(j,12)/hk(j,3))**hk(j,14)
                hk(j,16) = 2.0D0*(hk(j,8))**(.50D0)/hk(j,4)
                hk(j,17) = (1.0D0 - hk(j,11)/hk(j,3))**(0.50D0)
                hk(j,18) = hk(j,9)*(exp(hk(j,12)/(hk(j,9)*hk(j,3)))-1.0D0)/hk(j,5)
                hk(j,19) = hk(j,18)+((hk(j,11)/hk(j,3))**hk(j,14)-hk(j,15))/(hk(j,4)*hk(j,14))
                hk(j,13) = hk(j,19) + hk(j,16)*hk(j,17)
                hk(j,13) = hk(j,13)*hk(j,13)  
                !      pt = 0.0D0

            end if
        end if
        !
        !  end revisions
        !
30  CONTINUE

    !     convert alpha parameter if reading version 2.5 data set
    !      IF (VER2P5.AND.(hydraulicFunctionType.EQ.1)) THEN
    !         DO 31 J=1,NTEX
    !            IF (HK(J,4).NE.0) THEN
    !               HK(J,4) = -1.D0/HK(J,4)  
    !            END IF
    !   31    CONTINUE
    !     ENDIF
    WRITE (06,4140)
    !
    !    READ TEXTURAL CLASS INDEX MAP
    !
    ! Line B-12
    READ(5,*,IOSTAT=myerr) IROW
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-12:  IROW'
        flush(6)
        JSTOP = 237
        return
    endif
    IF(IROW.EQ.0) THEN
        !      DO 54 K=1,NNODES
        !        JTEX(K)=1
        !        J22=JTEX(K)
        !        HX(K)=HK(J22,1)
        !  54  CONTINUE        
        !      WRITE(06,4090)
        !      DO 51 J=1,KNLY
        !      READ(5,*)(ITBDUM(N),N=1,KNXR)
        !      DO 41 N=1,KNXR
        !      IN=KNLY*(N-1)+J
        !      I22=ITBDUM(N)
        !  41  ITEMBL(IN)=I22
        !  51  CONTINUE 
        !      DO 52 J=1,KNLY
        !      READ(5,*) (ITDUM(N),N=1,KNXR)
        !      DO 42 N=1,KNXR
        !      IN=KNLY*(N-1)+J
        !      NI=NLY*N+J+1
        !      NTEMBX=ITDUM(N)
        !      ITEMTX(IN)=NTEMBX
        !      if(ITEMBL(IN).EQ.0)ITEMTX(IN)=1
        !      ITBDUM(N)=ITEMTX(IN) 
        !      ITEMTX(IN)=ITBDUM(N)
        !      JTEX(NI)=ITEMTX(IN)
        !      J22=JTEX(NI)
        !      HX(NI)=HK(J22,1)
        !  42  CONTINUE
        !  52  CONTINUE

        !      DO 55 J=1,NLY
        !      DO 45 N=1,NXR
        !      IN=NLY*(N-1)+J
        !      IDUM(N)=JTEX(IN)
        !  45  CONTINUE
        !      if (ntex.gt.9) then
        !       write (06,4151) j,(idum(n),n=1,nxr)
        !      else
        !       WRITE (06,4150) J,(IDUM(N),N=1,NXR)
        !      end if
        !  55 CONTINUE      
        !      ELSE
        !Uncoment the next lines until the else statement located below label 50 contiune statement line
        ! and remove or coment the lines between if you are not using inputfile generated by Argus ONE GUI
        WRITE(06,4090)
        DO 50 J=1,NLY
    ! Line B-13
            READ(5,*,IOSTAT=myerr) (IDUM(N),N=1,NXR)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-13:  (JTEX(N),N=1,NXR)'
                flush(6)
                JSTOP = 238
                return
            endif
            if (ntex.gt.9) then
                write (06,4151) j,(idum(n),n=1,nxr)
            else
                WRITE (06,4150) J,(IDUM(N),N=1,NXR)
            end if
            DO 40 N=1,NXR
                IN=NLY*(N-1)+J
                J22=IDUM(N)
                HX(IN)=HK(J22,1)
40          JTEX(IN)=J22
50      CONTINUE
    ELSE
        !
        !    READ TEXTURE CLASSES BY BLOCK--EITHER CONTINUOUS LAYERS OR
        !    LAYERS BOUNDED BY VERTICAL DISCONTINUITIES.
        !
        WRITE (06,4040)
        JTP=1
    ! Line B-14
60      READ(5,*,IOSTAT=myerr) IL,IR,JBT,JRD
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-14:  IL,IR,JBT,JRD'
            flush(6)
            JSTOP = 239
            return
        endif
        DO 70 N=IL,IR
            IDUM(N)=JRD
70      CONTINUE
        IF(IR.LT.NXR) GO TO 60
        DO 80 J=JTP,JBT
            if (ntex.gt.9) then
                write (06,4151) j,(idum(n),n=1,nxr)
            else
                WRITE (06,4150) J,(IDUM(N),N=1,NXR)
            end if
80      continue
        DO 90 J=JTP,JBT
            DO 90 N=1,NXR
                IN=NLY*(N-1)+J
                J22=IDUM(N)
                HX(IN)=HK(J22,1)
                JTEX(IN)=J22
90      CONTINUE
        IF(JBT.EQ.NLY) GO TO 100
        JTP=JBT+1
        GO TO 60
    END IF
100 CONTINUE
    !
    !   BORDERS OF DOMAIN ARE ALL SET TO NO FLOW BOUNDARIES
    !
    DO 110 I=1,NLY
        I1=NNODES-I+1
        HX(I)=0.0D0
110 HX(I1)=0.0D0
    DO 120 I=2,NXR
        I1=(I-1)*NLY
        HX(I1)=0.0D0
120 HX(I1+1)=0.0D0
    !
    !   READ INITIAL HEADS OR MOISTURE CONTENTS
    !
    ! Line B-15
    READ(5,*,IOSTAT=myerr) IREAD,FACTOR
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-15:  IREAD,FACTOR'
        flush(6)
        JSTOP = 240
        return
    endif
    IF(IREAD.EQ.2) THEN
    ! Line B-16
        READ(5,*,IOSTAT=myerr) DWTX,HMIN
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-16:  DWTX,HMIN'
            flush(6)
            JSTOP = 241
            return
        endif
        WRITE (06,4190) DWTX,ZUNIT,HMIN,ZUNIT,DWTX,ZUNIT
        !
        !  CALCULATE EQUILIBRIUM INITIAL HEAD PROFILE
        !
        DO 130 J=2,NLYY
            DO 130 N=2,NXRR
                IN=NLY*(N-1)+J
                IF(HX(IN).EQ.0.0D0) GO TO 130
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(N)*CS2
                END IF
                P1=Z1-DWTX
                IF(P1.LT.HMIN)P1=HMIN
                P(IN)=P1-Z1
                PXXX(IN)=P(IN)
130     CONTINUE
    ELSE
        IF(IREAD.EQ.0) THEN
            WRITE (6,4170) FACTOR
        ELSE 
            IF(IREAD.EQ.1) then
    ! Line B-17
                READ(5,*,IOSTAT=myerr)IU,IFMT
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading B-17: IU,IFMT'
                    flush(6)
                    JSTOP = 242
                    return
                endif
                WRITE (06,4180) IU,FACTOR
            endif
        END IF
        !      if(IFMT.eq.UNFORMATTED) then
        if(iread.eq.3) then
            stimStart = -1.d0
            write (6,4181) stim, TUNIT
            if (trans) then
                do 
                    READ(13,err = 131, end = 132) stimStart, p, cc
                    if (stimStart.ge.stim) EXIT
                end do
            else
                do
                    READ(13,err = 131, end = 132) stimStart, p
                    if (stimStart.ge.stim) EXIT
                end do
            end if
132         continue
            if (stimStart.ne.stim) then
                write (6,4183) stim, TUNIT, stimStart, TUNIT
                stim = stimStart
            end if
            go to 133
131         write (6,4182)
            jstop = 11
            return
        else
            !      WRITE (06,4180) IU,FACTOR

            DO 160 J=1,NLY
                do I=1,NXR
                    DUM(I)=0.0D0
                END DO   
                IF(IREAD.EQ.1) then
                    IF(IFMT.eq.FREE) THEN
                        !
                        !   READ INITIAL CONDITIONS FROM FILE IU
                        !
                        READ(iu,*) (dum(n),n=1,nxr)
                    ELSE
                        !      READ(iuHead,FMT=IFMT) (DUM(N),N=1,NXR)
                        READ(IU,FMT=IFMT) (DUM(N),N=1,NXR)
                    end if
                else
                    DO 140 N=1,NXR
140                 DUM(N)=FACTOR
                end if
                DO 150 N=1,NXR
                    IN=NLY*(N-1)+J
                    IF(IREAD.ne.0)DUM(N)=DUM(N)*FACTOR
                    IF(CS1.EQ.1.0D0) THEN
                        Z1=DZZ(J)
                    ELSE
                        Z1=DZZ(J)*CS1+RX(N)*CS2
                    END IF
                    IF(.NOT.PHRD) THEN
                        IF(DUM(N).LE.0.0D0) THEN
                            WRITE(6,4230) J,N
                            jstop=4
                            return
                        END IF
                        !
                        !   CONVERT INITIAL MOISTURE CONTENTS TO HEADS
                        !
                        if(hydraulicFunctionType.eq.1) then
                            P(IN)=VSTHNVVG(DUM(N),JTEX(IN))-Z1
                        else
                            if(hydraulicFunctionType.eq.2) then
                                P(IN)=VSTHNVHK(DUM(N),JTEX(IN))-Z1
                            else
                                if(hydraulicFunctionType.eq.0) then
                                    P(IN)=VSTHNVBC(DUM(N),JTEX(IN))-Z1
                                else
                                    if(hydraulicFunctionType.eq.3) then
                                        P(IN)=VSTHNVTAB(DUM(N),JTEX(IN))-Z1
                                    else
                                        P(IN)=VSTHNVOT(DUM(N),JTEX(IN))-Z1
                                    end if
                                end if
                            end if
                        end if
                        THETA(IN)=DUM(N)
                    ELSE
                        P(IN)=DUM(N)-Z1
                    END IF
                    PXXX(IN)=P(IN)
150             CONTINUE
160         CONTINUE
        end if
        if(jstop.gt.1) return
        !
        !   COMPUTE INITIAL NONLINEAR COEFFICIENT VALUES
        !
    END IF

133 CALL VSCOEF
    !
    !   IF ET IS TO BE SIMULATED, ALL VARIABLES MUST BE ENTERED HERE.
    !
    ! Line B-18
    READ(5,*,IOSTAT=myerr) BCIT,ETSIM
    if (myerr .ne. 0) then
        write(6,'(A)') 'Error reading B-18:  BCIT,ETSIM'
        flush(6)
        JSTOP = 243
        return
    endif
    IF(BCIT .OR. ETSIM) THEN
        !
        !   COMPUTE DEPTHS FOR ET CALCULATIONS
        !
        DPTH(1)=-0.5D0 *DELZ(1)
        DO 170 J=2,NLYY
            DO 170 N=2,NXRR
                IN=NLY*(N-1)+J
                JM1=IN-1
                IF(HX(IN).NE.0.0D0) THEN
                    IF(HX(JM1).EQ.0.0D0) THEN
                        DPTH(IN)=0.0D0
                    ELSE
                        DPTH(IN)=DPTH(JM1)+DELZ(J-1)
                    END IF
                END IF
170     CONTINUE
        WRITE (6,4200)
        CALL VSOUT(2,DPTH)
        !
        !   READ EVAPORATION VARIABLES
        !
    ! Line B-19
        READ(5,*,IOSTAT=myerr)NPV,ETCYC
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-19: NPV,ETCYC'
            flush(6)
            JSTOP = 244
            return
        endif
        npv1 = npv
        if(npv.lt.0) npv = -npv
        !!@@include 'd_ptetAlloc.inc'
        allocate(PEVAL(NPV))
        allocate(PTVAL(NPV))
        allocate(RDC(6,NPV))
        DO 713 I=1,NPV
            PEVAL(I) = 0.0D0
            PTVAL(I) = 0.0D0
            DO 714 J=1,6
                RDC(J,I) = 0.0D0
714         CONTINUE
713     CONTINUE
        WRITE(6,4030) NPV,ETCYC,TUNIT
        IF(BCIT) THEN
    ! Line B-20
            READ(5,*,IOSTAT=myerr)(PEVAL(I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-20: (PEVAL(I),I=1,NPV)'
                flush(6)
                JSTOP = 245
                return
            endif
    ! Line B-21
            READ(5,*,IOSTAT=myerr)(RDC(1,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-21: (RDC(1,I),I=1,NPV)'
                flush(6)
                JSTOP = 246
                return
            endif
    ! Line B-22
            READ(5,*,IOSTAT=myerr)(RDC(2,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-22: (RDC(2,I),I=1,NPV)'
                flush(6)
                JSTOP = 247
                return
            endif
            WRITE (06,4050)ZUNIT,TUNIT,ZUNIT,ZUNIT,(I,PEVAL(I),RDC(1,I),  &
            RDC(2,I),I=1,NPV)
        END IF
        IF (ETSIM )THEN
            !
            !   READ TRANSPIRATION VARIABLES
            !
    ! Line B-23
            READ(5,*,IOSTAT=myerr)(PTVAL(I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-23: (PTVAL(I),I=1,NPV)'
                flush(6)
                JSTOP = 248
                return
            endif
    ! Line B-24
            READ(5,*,IOSTAT=myerr) (RDC(3,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-24:  (RDC(3,I),I=1,NPV)'
                flush(6)
                JSTOP = 249
                return
            endif
    ! Line B-25
            READ(5,*,IOSTAT=myerr) (RDC(4,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-25:  (RDC(4,I),I=1,NPV)'
                flush(6)
                JSTOP = 250
                return
            endif
    ! Line B-26
            READ(5,*,IOSTAT=myerr) (RDC(5,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-26:  (RDC(5,I),I=1,NPV)'
                flush(6)
                JSTOP = 251
                return
            endif
    ! Line B-27
            READ(5,*,IOSTAT=myerr) (RDC(6,I),I=1,NPV)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-27:  (RDC(6,I),I=1,NPV)'
                flush(6)
                JSTOP = 252
                return
            endif
            WRITE(06,4060)ZUNIT,TUNIT,ZUNIT,ZUNIT,ZUNIT,ZUNIT,(I,PTVAL(I),  &
            (RDC(J,I),J=3,6),I=1,NPV)
            NPV = npv1
        END IF
    END IF
    DO 180 IN=1,NNODES
        NTYP(IN)=0
        IF(SOLUTE) NCTYP(IN)=0
        IF(HEAT) NHTYP(IN)=0
        IF(HX(IN).GT.0.0D0) THLST(IN)=THETA(IN)
180 CONTINUE
    !
    !    READ INITIAL TEMPERATURES IF TRANSPORT EQUATION IS TO
    !    BE SOLVED
    !
    IF (HEAT) THEN
    ! Line B-28
        READ(5,*,IOSTAT=myerr) IREAD,FACTOR
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-28:  IREAD,FACTOR'
            flush(6)
            JSTOP = 253
            return
        endif
        IF(IREAD.EQ.0) THEN
            WRITE(6,4210) FACTOR
            DO 190 N=1,NNODES
                IF(HX(N).GT.0.0D0) THEN
                    TT(N) = FACTOR
                    TTOLD(N)= FACTOR
                ELSE
                    TT(N) = 0.0D0
                    TTOLD(N)= 0.0D0
                END IF
                RHO(N)=VTRHO(TT(N),JTEX(N))
                RHOOLD(N)=RHO(N)
190         CONTINUE
        ELSE
    ! Line B-29
            READ(5,*,IOSTAT=myerr)IU,IFMT
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-29: IU,IFMT'
                flush(6)
                JSTOP = 254
                return
            endif
            if (IFMT.NE.UNFORMATTED) then
                WRITE(06,4220) IU,FACTOR
                DO 202 J=1,NLY
                    if (IFMT.EQ.FREE) then
                        read(iu,*) (dum(n),n=1,nxr)
                    else
                        !       READ(iuConcentration,FMT=IFMT) (DUM(N),N=1,NXR)
                        READ(iu,FMT=IFMT) (DUM(N),N=1,NXR)
                    end if
                    DO 202 N=1,NXR 
                        IN=NLY*(N-1)+J
                        IF(HX(IN).GT.0.0D0) THEN
                            TT(IN)=DUM(N)*FACTOR
                            TTOLD(IN)=TT(IN)
                        ELSE
                            TT(IN)=0.0D0
                            TTOLD(IN)= 0.0D0   
                        end if
                        RHO(IN)=VTRHO(TT(IN),JTEX(IN))
                        RHOOLD(IN)=RHO(IN) 
202             CONTINUE   
            end if
        end if
    else
        do 210 n = 1,nnodes    
            RHO(N)=VTRHO(TT(N),JTEX(N))
            RHOOLD(N)=RHO(N)
210     CONTINUE
    END IF
    !
    !    READ INITIAL MULTI-SOLUTE CONCENTRATION IF SOLUTE TRANSPORT EQUATION IS TO
    !    BE SOLVED
    !      
    IF (SOLUTE .and. RM_OK) THEN
        !
        ! ASSIGN INDSOL1(1-7) BY TEXTURAL CLASS
        !
        DO 277 K=1,7
            DO 277 J=1,NLY
                DO 277 N=1,NXR
                    IN = NLY*(N-1) + J
                    INDSOL1(K,IN) = ITEXSOL(JTEX(IN),K)
277     CONTINUE
    ! Line B-30
        READ(5,*,IOSTAT=myerr) IREAD
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-30:  IREAD'
            flush(6)
            JSTOP = 255
            return
        endif
        insol2 = -1
        indsol2 = -1
        cmixfarc = 1.0d0
        !INSOL2(1)=2
        !DO  I=1,7
        !    INSOL2(I)=-1
        !    DO J=1,NNODES
        !        INDSOL2(I,J) = INSOL2(I)
        !        CMIXFARC(I,J) = 1.0d0
        !    END DO
        !END DO  
        IF(IREAD.EQ.0) THEN
    ! Line B-31
            READ(5,*,IOSTAT=myerr)(INSOL1(I),I=1,7)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-31:  INSOL1'
                flush(6)
                JSTOP = 256
                return
            endif            
            INSOL2(1)=2
            DO 212 I=2,7
                INSOL2(I)=-1
212         CONTINUE       
            DO 182 I=1,7
                DO 181 J=1,NNODES
                    INDSOL1(I,J) = INSOL1(I)
                    !      INDSOL2(I,J) = INSOL2(I)
                    !      CMIXFARC(I,J) = 1.0d0
181             CONTINUE
182         CONTINUE
        ELSE if (IREAD.EQ.1)then
            allocate(iidum(nxr))
            DO 403 K=1,7
                DO 402 J=1,NLY
    ! Line B-32
                    READ(5,*,IOSTAT=myerr)(IIDUM(N),N=1,NXR)
                    if (myerr .ne. 0) then
                        write(6,'(A)') 'Error reading B-32:  INDSOL'
                        flush(6)
                        JSTOP = 257
                        return
                    endif   
                    DO 401 N=1,NXR
                        IN=NLY*(N-1)+J
                        INDSOL1(K,IN)=IIDUM(N)
                        !      write(*,*)"INDSOL1(",K,",",NI,")=ITEMTX(",IN,")=",INDSOL1(K,NI),ITEMTX(IN)
401                 continue
402             continue
403         continue
            deallocate(iidum)
        END IF  
        DO 185 I=1, Nsol
            Solcomp(I)=0.0d0
185     continue  
        DO 187 I=1, NLY
            DO 186 J=1, NXR
                IN=NLY*(J-1)+I  
                if (I.eq.1.or.I.eq.NLY)then
                    INDSOL1(1,IN)=-1
                    NPRCHEM(IN)=0
                    NPRCHXZ(IN)=0
                    NPRCHOBS(IN)=0
                else 
                    if (J.eq.1.or.J.eq.NXR)then
                        INDSOL1(1,IN)=-1
                        NPRCHEM(IN)=0
                        NPRCHXZ(IN)=0
                        NPRCHOBS(IN)=0
                    else 
                        if (HX(IN).LE.0.0D0) then
                            INDSOL1(1,IN)=-1
                            NPRCHEM(IN)=0
                            NPRCHXZ(IN)=0
                            NPRCHOBS(IN)=0
                        end if
                    end if 
                end if    
186         continue      
187     continue 
        !      do 184 I=1,7
        !      do 183 J=1, NNODES  
        !     write(6,*)"INDSOL1(",I,",",J,")=",INDSOL1(I,J)
        ! 183  continue
        ! 184  continue   
        do 205 I=1, Nodesol
            phreeC(I)= 0.0d0
205     continue

        CALL CreateMappingRM(INDSOL1, axes, NXR, NLY) 
        if (JSTOP .gt. 1) then
            return
        endif  
        ! Set porosity
        do i = 1, nnodes            
            porosity(i) = HK(jtex(i),3)
        enddo
        status = RM_SetPorosity(rm_id, porosity) 
        CALL InitializeRM(cmixfarc, indsol1, indsol2, ic1_reordered)
        if (JSTOP .gt. 1) then
            return
        endif        
        CALL GetConcentrationsRM(cc)
        IF (JSTOP.GT.1) THEN
            RETURN
        ENDIF 
        ! Set SolComp
        !status = RM_InitialPhreeqc2Concentrations(rm_id, Solcomp(1), 1, INSOL1(1))  
        do i = 1, Nsol
            WRITE(06,4012)COMPNAME(I), Solcomp(I)
        enddo  

        ! Set ccold
        do 203 J=1,NLY
            DO 203 N=1,NXR
                DO 201 M=1,Nsol
                    IN=NLY*(N-1)+J
                    CCOLD(M,IN)=CC(M,IN)
201             CONTINUE
203     CONTINUE
        do 162 J=1,NLY
            do 156 N=1,NXR
                IN=NLY*(N-1)+1
                IF(HX(IN).GT.0.0D0) THEN
                    if(hydraulicFunctionType.eq.0)then
                        THETA(IN)=VSTHUBC(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.1)then
                        THETA(IN)=VSTHUVG(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.2)then
                        THETA(IN)=VSTHUHK(P(IN),JTEX(IN))
                    else if(hydraulicFunctionType.eq.4)then
                        THETA(IN)=VSTHUOT(P(IN),JTEX(IN))
                    end if
                ENDIF
156         CONTINUE
162     CONTINUE 
        iprrestartflag = 0 
        istopmsg = 0

        !if (HEAT.AND.SOLUTE)THEN
        !CALL EQUILIBRATEWHEAT( cc,hx,tt,NNODES,heat,nprconc,xnode,znode,  &
        !tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
        !theta,iprrestartflag)
        !ELSE IF ((.NOT.HEAT).AND.SOLUTE)THEN
        !call EQUILIBRATE( cc,hx,NNODES,nprconc,xnode,znode,  &
        !tper,delt,npscrn,cnvtmi,nprchem,nprchxz,ipout,istopmsg,  &
        !theta,iprrestartflag)   
        !ENDIF
        IF (SOLUTE .and. RM_OK) THEN
            call SetConcentrationsRM(cc)
            IF (JSTOP.GT.1) THEN
                RETURN
            ENDIF 
            IF (HEAT) THEN
                status = RM_SetTemperature(rm_id, tt)
            endif

            status = RM_SetTime(rm_id, 0.0d0)
            status = RM_SetTimeStep(rm_id, delt)
            status = RM_SetTimeConversion(rm_id, cnvtmi)
            status = RM_SetPrintChemistryMask(rm_id, nprchem)
            iPRNT = 0
            if (PRNT) iPRNT = 1
            status = RM_SetPrintChemistryOn(rm_id, iPRNT, 0, 0)
            status = RM_SetSaturation(rm_id, theta)
            status = RM_RunCells(rm_id)
            call GetConcentrationsRM(cc)
            IF (JSTOP.GT.1) THEN
                RETURN
            ENDIF 
            call FH_SetPointers(RX(1), DZZ(1), xnode(1), znode(1), ic1_reordered(1,1), theta(1), forward1(1))
        END IF
    END IF
    !
    !   COMPUTE INTERCELL CONDUCTANCES
    !   

    CALL VSHCMP
    !
    !  modifications Aug 2008 to allow output of
    !   fluxes along boundary segment.  Read in
    !   cells on selected boundary faces here.
    !
    if (f7p) then
    ! Line B-33
        read(5,*,IOSTAT=myerr) numBF, maxnumcells
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading B-33:  numBF, maxnumcells'
            flush(6)
            JSTOP = 258
            return
        endif
        !!@@include 'd_BFAlloc.inc'
        !      if (allocated(idBF)) deallocate(idBF)
        !      if (allocated(numcellsBF)) deallocate(numcellsBF)
        !      if (allocated(nodenum)) deallocate(nodenum)
        !      if (allocated(totalBF)) deallocate(totalBF)
        !      if (allocated(currentBF)) deallocate(currentBF)
        allocate(idBF(numBF))
        allocate(numcellsBF(numBF))
        allocate(nodenum(numBF,maxnumcells))
        allocate(totalBF(numBF,2))
        allocate(currentBF(numBF,4))       
        do 250 i = 1,numBF
    ! Line B-34
            read(5,*,IOSTAT=myerr) idBF(i), numcellsBF(i)
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading B-34:  idBF(i), numcellsBF(i)'
                flush(6)
                JSTOP = 259
                return
            endif
            do 250 j = 1,numcellsBF(i)
    ! Line B-35
                READ(5,*,IOSTAT=myerr) jj,nn
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading B-35:  jj,nn'
                    flush(6)
                    JSTOP = 260
                    return
                endif
                nodenum(i,j) = nly*(nn-1) + jj
250     continue
    end if
    !!@@include 'd_itembloDealloc.inc'
    if(allocated(itembl)) deallocate(ITBDUM)
    if(allocated(itbdum)) deallocate(itbdum)
    !!@@include 'd_itemtxbDealloc.inc'
    deallocate(ITEMTX,ITDUM)
    IF (ALLOCATED(ITEXSOL)) DEALLOCATE(ITEXSOL)
    !     write(*,*)"Finshed reading initial data................................"    
    RETURN
4000 FORMAT(10X,27HINITIAL MOISTURE PARAMETERS/10X,27(1H_)// &
5   X,'CONVERGENCE CRITERION FOR SIP FOR FLOW (EPS) =',1PE12.3,1X,A4/ &
5   X,'CONVERGENCE CRITERION FOR SIP FOR HEAT TRANSPORT (EPS1) =' ,  &
1   PE12.3,1X,/5X,'CONVERGENCE CRITERION FOR OUTER'& 
    'ITERATION (EPS2)  = ',1PE12.3,1X,/5X,'CONVERGENCE CRITERION'&  
    'FOR SIP FOR SOLUTE TRANSPORT(EPS3) =',1PE12.3,1X,/5X,  &
23  HDAMPING FACTOR,HMAX = ,1PE12.3)
    ! 4001 FORMAT(I1,A80)   
4010 FORMAT(5X,46HGEOMETRIC MEAN USED FOR INTERCELL CONDUCTIVITY)
4012 FORMAT(4X,A10,F10.6)
4020 FORMAT(5X,50HUPSTREAM WEIGHTING USED FOR INTERCELL CONDUCTIVITY)
4030 FORMAT(//15X,'NUMBER OF EVAPORATION AND/OR EVAPOTRASPIRATION PERIODS= ',  &
    I6,/,15X,'LENGTH OF EACH PERIOD = ',F10.4,2X,A4)
4040 FORMAT(5X,'TEXTURAL CLASSES READ IN BY BLOCK')
4050 FORMAT(//5X,'EVAPORATION   POTENTIAL      SURFACE   ATMOSHERIC', &
    /'       PERIOD        RATE       RESISTANCE    PRESSURE', &
    /19X,A4,'/',A4,3X,A4,'**(-1)',5X,A4,/,1X,90('-'),  &
25  (/,5X,I6,4X,3E14.5))
4060 FORMAT(//,3X,'TRANSPIRATION   POTENTIAL         ROOT       ACTIVITY &
    ACTIVITY        ROOT', &
    /'       PERIOD        RATE            DEPTH     AT BOTTOM       A&
    T TOP       PRESSURE',/,19X,A4,'/',A4,9X,A4,5X,A4,'**(-2)',4X,A4,&
    '**(-2)',8X,A4,/,1X,90('-'),25(/,5X,I6,4X,5E14.5))
4070 FORMAT(5X,47HARITHEMTIC MEAN USED FOR INTERCELL CONDUCTIVITY)
4080 FORMAT(5X,34HNUMBER OF SOIL TEXTURAL CLASSES = ,I10/  &
5   X,43HNUMBER OF SOIL PARAMETERS FOR EACH CLASS = ,I10/  &
5   X,'NUMBER OF HEAT TRANSPORT PARAMETERS FOR EACH CLASS = ',I10/  &
5   X,'NUMBER OF SOLUTE TRANSPORT PARAMETERS FOR EACH CLASS = ' &
    ,I10/5X,47HMINIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10/  &
5   X,47HMAXIMUM PERMITTED NO. OF ITERATIONS/TIME STEP =,I10)
4090 FORMAT(5X,41HTEXTURAL CLASS TO BE READ IN FOR EACH ROW)
4100 FORMAT(41X,35HCONSTANTS FOR SOIL TEXTURAL CLASSES// &
10  X,10HANISOTROPY,7X,4HKSAT,5X,8HSPECIFIC,4X,8HPOROSITY,/,&
36  X,7HSTORAGE)
4110 FORMAT(12X,'ALPHAL',8X,'ALPHAT',6X,'Cs',9X,'KT MIN',  &
4   X,' KT MAX ',4X,'   Cw   ')
4111 FORMAT(12X,'ALPHAL',8X,'ALPHAT',6X,'DM',8X,'SOLUTION',4X, &
    'EQ_PHASE',4X,'EXCHANGE',4X,'SURFACE ',4X,'GAS_PHAS',4X &
    'SOLID_SO',4X,'KINETICS')
4120 FORMAT(1X,7HCLASS #,I2,/9X,3(1PD12.3),14(7(1PD12.3),/))
4130 FORMAT(9X,10(1PD12.3))
4131 FORMAT(9X,3(1PD12.3),7(I4,8X))
4140 FORMAT(6X,24HTEXTURAL CLASS INDEX MAP//   )
4150 FORMAT(1H ,5X,I5,2X,100(99999I1))
4151 FORMAT(1H ,5X,I5,2X,100(99999I2))
4160 FORMAT(5X,24H ****** VALUE OF ITMAX =,I5,8HEXCEEDS , &
44  HDIMENSION OF DHMX, PROGRAM TERMINATED ******)
4170 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS SE, &
24  HT TO A CONSTANT VALUE OF,1PE12.3)
4180 FORMAT(5X,48HINITIAL PRESSURE HEAD OR MOISTURE CONTENT WAS RE, &
12  HAD FROM UNIT,I5, &
20  H A SCALING FACTOR OF,1PE12.3,9H WAS USED)
4181 FORMAT(5X,'Simulation restarted at time ', E15.7,1x, a4, & 
    '.  Initial conditions imported from previous run.')
4182 FORMAT('Error reading unformatted initial conditions.', &
    '  Simulation stopped.')
4183 FORMAT(5x,'WARNING ---- Requested start time ', E15.7,1x, a4,  & 
    ' differs from actual start time ', E15.7,1x, a4,'.')
4190 FORMAT(5X,'EQUILLIBRIUM PROFILE USED TO INITIALIZE PRESSURE',  &
27  H HEADS ABOVE WATER TABLE AT,F10.2,1X,A4,1X, &
12  HBELOW ORIGIN/5X, &
57  HEQUILLIBRIUM PROFILE ONLY USED UNTIL PRESSURE HEADS EQUAL, &
    F10.2,1X,A4/5X, &
20  HPRESSURE HEADS BELOW,F10.2,1X,A4,16H ARE HYDROSTATIC)
4200 FORMAT(1H ,50X,18HDEPTH FROM SURFACE)
4210 FORMAT('     INITIAL TEMPERATURE SET TO A CONSTANT VALUE OF ',  &
1   PE12.3)
4215 FORMAT('    INITIAL CONCENTRATION SET TO A CONSTANT VALUE OF ',  &
1   PE12.3,' GRAM')     
4220 FORMAT('     INITIAL TEMPERATURE WAS READ FROM UNIT',I5,  &
    ' A SCALING FACTOR OF, ',1PE12.3,' WAS USED')
4225 FORMAT('     INITIAL CONCENTRATION WAS READ FROM UNIT',I5,  &
    ' A SCALING FACTOR OF, ',1PE12.3,' WAS USED')    
4230 FORMAT('  INITIAL MOISTURE CONTENT AT ROW ',I3,' COLUMN ',  &
    I3,' IS LESS THAN OR EQUAL TO 0.',/'  PROGRAM TERMINATED')
    END
    SUBROUTINE VSTMER
    !******
    !VSTMER
    !******
    !
    !     PURPOSE: TO CONTROL THE TIME SEQUENCE OF SIMULATION
    !     AND TO READ NEW BOUNDARY CONDITION DATA
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use disch
    use trxx
    use plott
    use idumm
    use spfc
    use scon
    use isdumm
    use ihdumm
    use trxxh
    use solindex
    use PhreeqcRM
    use vs2dt_rm
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/PND/POND
    COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON /TRANSTYPE/HEAT,SOLUTE
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/FLO/FLOW
    common/thick/dely
    COMMON/JCONF/JFLAG2
    double precision, allocatable, dimension(:,:) :: bcsol1
    integer, allocatable, dimension(:) :: ibsol1
    INTEGER       :: myerr
    SAVE STERR
    !!@@include 'd_ihdummAlloc.inc'
    allocate(IHDUM(NXR))
    !!@@include 'd_isdummAlloc.inc'
    allocate(ISDUM(NXR))
    !-------------------------------------------------------------------
    !
    !   ADVANCE TO NEXT TIME STEP
    !
    KTIM=KTIM+1
    IF (KTIM.NE.1.AND.JSTOP.NE.0) RETURN
    JSTOP=0
    JPLT=0
    NIT=0
    NIT1=0
    NIS1=0
    IF(KTIM.EQ.1) then
        kplt = 1
        do
            if(pltim(kplt).gt.stim) EXIT
            kplt = kplt + 1
        end do
    end if
    IF(JFLAG.EQ.1) THEN
        !
        !................................................................
        !
        !    READ DATA FOR NEW RECHARGE PERIOD
        ! ................................................................
        !
    ! Line C-1
        READ(5,*,IOSTAT=myerr) TPER,DELT
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-1:  TPER,DELT'
            flush(6)
            JSTOP = 261
            return
        endif
        !
        !   CHECK FOR END OF SIMULATION
        !
        jflag1 = 1
        jflag2 = 1
        IF(TPER.LT.0) THEN
            WRITE (06,4070) TMAX,STIM
            jstop=5
            return
        END IF
    ! Line C-2
        READ(5,*,IOSTAT=myerr) TMLT,DLTMX,DLTMIN,TRED
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-2:  TMLT,DLTMX,DLTMIN,TRED'
            flush(6)
            JSTOP = 262
            return
        endif
        KP=KP+1
        SSTATE=.FALSE.
        if(delt.lt.dltmin) then
            delt = dltmin
        else
            if(delt.gt.dltmx) delt = dltmx
        end if
        WRITE (06,4000) KP,TPER,TUNIT,DELT,TUNIT,TMLT,DLTMX,TUNIT,DLTMIN, &
        TUNIT,TRED
    ! Line C-3
        READ(5,*,IOSTAT=myerr) DSMAX,STERR
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-3:  DSMAX,STERR'
            flush(6)
            JSTOP = 263
            return
        endif
    ! Line C-4
        READ(5,*,IOSTAT=myerr) POND
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-4:  POND'
            flush(6)
            JSTOP = 264
            return
        endif
        WRITE (06,4020) DSMAX,STERR,POND
    ! Line C-5
        READ(5,*,IOSTAT=myerr) PRNT
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-5:  PRNT'
            flush(6)
            JSTOP = 265
            return
        endif
    ! Line C-6
        READ(5,*,IOSTAT=myerr) BCIT,ETSIM,SEEP
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-6:  BCIT,ETSIM,SEEP'
            flush(6)
            JSTOP = 266
            return
        endif
        WRITE (06,4010) PRNT,BCIT,ETSIM,SEEP
        DSMAX=DABS(DSMAX)
        ETOUT=0.0D0
        ETOUT1=0.0D0
        !
        !    READ SEEPAGE FACE DATA
        !
        IF(SEEP) THEN
    ! Line C-7
            READ(5,*,IOSTAT=myerr) NFCS
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading C-7:  NFCS'
                flush(6)
                JSTOP = 267
                return
            endif
            !!@@include 'd_spfcAlloc.inc'
            if (allocated(JSPX)) deallocate(JSPX)
            if (allocated(NFC)) deallocate(NFC)
            if (allocated(JLAST)) deallocate(JLAST)
            allocate(JSPX(3,NXR+NLY,NFCS))
            allocate(NFC(NFCS))
            allocate(JLAST(NFCS))
            DO 50 K=1,NFCS 
    ! Line C-8
                READ(5,*,IOSTAT=myerr) JJ,JLAST(K) 
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-8:  JJ,JLAST(K) '
                    flush(6)
                    JSTOP = 268
                    return
                endif
                NFC(K)=JJ 
    ! Line C-9
                READ(5,*,IOSTAT=myerr) ((JSPX(L,J,K),L=2,3),J=1,JJ)
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-9:  ((JSPX(L,J,K),L=2,3),J=1,JJ)'
                    flush(6)
                    JSTOP = 269
                    return
                endif
                !      DO 40 M=1,Nsol
                DO 40 J=1,JJ 
                    J1=JSPX(2,J,K) 
                    N1=JSPX(3,J,K) 
                    N2=NLY*(N1-1)+J1 
                    JSPX(1,J,K)=N2 
                    Q(N2)=0.0D0 
                    QQ(N2)=0.0D0
                    IF(HEAT)THEN
                        NHTYP(N2)=0
                        TS(N2)=0.0D0
                    END IF   
                    IF(SOLUTE)THEN
                        NCTYP(N2)=0
                        Do 41 M = 1, Nsol
41                      CSS(M,N2)=0.0D0
                    END IF 
                    IF(J.GT.JLAST(K)) THEN 
                        NTYP(N2)=3 
                    ELSE 
                        NTYP(N2)=1  
                        IF(CS1.EQ.1.0D0) THEN
                            Z1=DZZ(J1)
                        ELSE
                            Z1=DZZ(J1)*CS1+RX(N1)*CS2
                        END IF
                        P(N2)=-Z1 
                    END IF
40              CONTINUE 
50          CONTINUE 
        END IF
        !
        !   READ IN NEW BOUNDARY CONDITIONS FOR RECHARGE PERIOD
        !    IF IBC=0, POINT BOUNDARY CONDITIONS ARE READ IN.
        !    IF IBC=1, LINE BOUNDARY CONDITIONS ARE READ IN, AND IT IS NECESSARY
        !     TO SPECIFY FOUR POINTS ON THE LINE--THIS ALLOWS VERTICAL OR HORI-
        !     ZONTAL LINES TO BE READ IN INDISCRIMINATELY.  THE SEQUENCE IS:
        !     TOP ROW, BOTTOM ROW, LEFT COLUMN, RIGHT COLUMN, CODE, AND FLUX OR
        !     PRESSURE HEAD FOR BOUNDARY CONDITION.
        !
    ! Line C-10
        READ(5,*,IOSTAT=myerr) IBC 
        if (myerr .ne. 0) then
            write(6,'(A)') 'Error reading C-10:  IBC '
            flush(6)
            JSTOP = 270
            return
        endif
        IF(IBC.GT.0) GO TO 80 
70      IF (TRANS)THEN
    ! Line C-11
            READ(5,*,IOSTAT=myerr) JJ,NN,NTX,PFDUM
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading C-11:  JJ,NN,NTX,PFDUM'
                flush(6)
                JSTOP = 271
                return
            endif
            IF(JJ.LT.0) GO TO 130 
            IF(HEAT) THEN
    ! Line C-12
                READ(5,*,IOSTAT=myerr)NTT,TF
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-12: NTT,TF'
                    flush(6)
                    JSTOP = 272
                    return
                endif
            ELSE
                NTT=0
                TF=0
            END IF
            IF(solute)  then
    ! Line C-13
                READ(5,*,IOSTAT=myerr)NTC,INSBC1 !,INSBC2,SBFRAC
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-13: NTC,INSBC1'
                    flush(6)
                    JSTOP = 273
                    return
                endif
                ! dlp
                if ((ntc .eq. 0) .and. ((ntx .eq.0).or.(ntx .eq.3).or. &
                  (ntx .eq.4).or.(ntx.eq.5).or.(ntx.eq.7))) then
                    bcsol = 0.0D0
                else
                    !#CALL SETUP_BOUNDARY_CONDITIONS(INSBC1,INSBC2,SBFRAC,BCSOL)
                    allocate(bcsol1(1,nSol), ibsol1(1))
                    ibsol1(1) = insbc1
                    status = RM_InitialPhreeqc2Concentrations(rm_id, bcsol1, 1, ibsol1)
                    do i = 1, nsol
                        bcsol(i) = bcsol1(1,i)
                    enddo
                    deallocate(bcsol1, ibsol1)
               endif
            ELSE
                NTC=0
            END IF
        ELSE
    ! Line C-14
            READ(5,*,IOSTAT=myerr) JJ,NN,NTX,PFDUM
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading C-14:  JJ,NN,NTX,PFDUM'
                flush(6)
                JSTOP = 274
                return
            endif
        END IF
        IF(JJ.LT.0) GO TO 130 
        JJT=JJ 
        JJB=JJ 
        NNL=NN 
        NNR=NN 
        GO TO 90 
80      IF(TRANS)THEN
    ! Line C-15
            READ(5,*,IOSTAT=myerr) JJT,JJB,NNL,NNR,NTX,PFDUM
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading C-15:  JJT,JJB,NNL,NNR,NTX,PFDUM'
                flush(6)
                JSTOP = 275
                return
            endif
            IF(JJT.LT.0) GO TO 130
            IF(HEAT) THEN
    ! Line C-16
                READ(5,*,IOSTAT=myerr)NTT,TF
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-16: NTT,TF'
                    flush(6)
                    JSTOP = 276
                    return
                endif
            ELSE
                NTT=0
                TF=0.0d0
            END IF
            IF (SOLUTE)THEN
    ! Line C-17
                READ(5,*,IOSTAT=myerr)NTC,INSBC1 ! ,INSBC2,SBFRAC 
                if (myerr .ne. 0) then
                    write(6,'(A)') 'Error reading C-17: NTC,INSBC1 '
                    flush(6)
                    JSTOP = 277
                    return
                endif
                ! dlp
                if ((ntc .eq. 0) .and. ((ntx .eq.0).or.(ntx .eq.3).or. &
                  (ntx .eq.4).or.(ntx.eq.5).or.(ntx.eq.7))) then
                    bcsol = 0.0D0
                else
                 !#CALL SETUP_BOUNDARY_CONDITIONS(INSBC1,INSBC2,SBFRAC,BCSOL)
                 allocate(bcsol1(1,nSol), ibsol1(1))
                 ibsol1(1) = insbc1
                 status = RM_InitialPhreeqc2Concentrations(rm_id, bcsol1, 1, ibsol1)
                 do i = 1, nsol
                     bcsol(i) = bcsol1(1,i)
                 enddo
                 deallocate(bcsol1, ibsol1)
                end if
            ELSE
                NTC=0
            END IF
        ELSE
    ! Line C-18
            READ(5,*,IOSTAT=myerr) JJT,JJB,NNL,NNR,NTX,PFDUM
            if (myerr .ne. 0) then
                write(6,'(A)') 'Error reading C-18:  JJT,JJB,NNL,NNR,NTX,PFDUM'
                flush(6)
                JSTOP = 278
                return
            endif
            IF(JJT.LT.0) GO TO 130
        END IF 
        !
90      CONTINUE 
        IF (SOLUTE)THEN
            DO 92 JJ=JJT,JJB 
                DO 92 NN=NNL,NNR 
                    DO 91 M=1,Nsol
                        IN=NLY*(NN-1)+JJ
                        CSS(M,IN)=BCSOL(M)
                        !
                        !  change made 99-12-16 so that ntc = 2 conductive heat flux is
                        !   in terms of energy per time per length of boundary (i.e.,
                        !   a line source) , as 
                        !   opposed to energy per time (which is for point source)
                        !     
                        !      DO 450 I=1, Nsol
                        !      BCSOL(I)=I
                        ! 450  CONTINUE   
                        if (ntc.eq.2) then
                            area = dxr(nn)
                            if(rad) area = pi2*rx(nn)*dxr(nn)
                            CSS(M,IN) = BCSOL(M)*area
                        end if
                        IF(NTC.EQ.1) CC(M,IN)=BCSOL(M)
                        NCTYP(IN)=NTC
91                  CONTINUE
92          CONTINUE
        END IF
        DO 120 JJ=JJT,JJB 
            DO 120 NN=NNL,NNR 
                IN=NLY*(NN-1)+JJ 
                IF(HEAT) then
                    TS(IN)=TF
                    if (NTT.eq.2) then
                        area = dxr(nn)
                        if(rad) area = pi2*rx(nn)*dxr(nn)
                        TS(IN) = Tf*area
                    end if
                    IF(NTT.EQ.1) TT(IN)=TF
                    NHTYP(IN)=NTT
                END IF
                !      if(ntx.eq.5.and.hx(in-1).gt.0.0d0) go to 80
                IF(NTX.NE.6) GO TO 100 
                NTYP(IN)=2 
                QQ(IN)=PFDUM 
                GO TO 120 
100             NTYP(IN)= NTX 
                IF(NTX.EQ.4)NTYP(IN)=1 
                IF(NTX.EQ.0) WRITE (06,4030) JJ,NN 
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(JJ)
                ELSE
                    Z1=DZZ(JJ)*CS1+RX(NN)*CS2
                END IF
                IF(NTX.EQ.1) P(IN)=PFDUM-Z1 
                IF(NTX.EQ.4) P(IN)=PFDUM 
                IF(NTX.EQ.2) GO TO 110 
                QQ(IN)=0.0d0 
                !
                !  modifications for gravity drainage BC
                !
                if (ntx.eq.7) then
                    if(hx(in+1).gt.0.d0.or.hx(in-1).le.0.d0) then
                        WRITE(6,4012)  JJ,NN
                        ntyp(in)=0
                    else
                        !        nctyp(in) = 7
                        ntyp(in) = 7
                    end if
                end if
                !
                !  end modifications
                ! 
                GO TO 120 
110             CONTINUE 
                !  SET QQ TO RAINFALL RATE 
                AREA=DXR(NN) 
                IF(RAD)AREA=PI2*RX(NN)*DXR(NN) 
                QQ(IN)=PFDUM*AREA 
120     CONTINUE 
        IF(IBC.EQ.0) GO TO 70 
        GO TO 80 
130     CONTINUE
        !      if (SOLUTE)then
        !      do  I=1, Nsol
        !      WRITE (6,*)'BCSOL(',I,')=',BCSOL(I)
        !      END DO
        !      END IF
        write(6,*)"temerature setting at the boundary"
        !      CALL VSOUT(1,TT)
        !      CALL VSOUTS(1,CC)
        !
        !     WRITE INITIAL BOUNDARY CONDITIONS FOR THIS PERIOD
        !
        GRAV = .FALSE.
        WRITE (06,4040) KP
        DO 111 J=1,NLY
            DO 109 N=1,NXR
                IN=NLY*(N-1)+J
                Q(IN)=0.0D0
                if(ntyp(in).eq.7) GRAV = .TRUE.
109         IDUM(N)=NTYP(IN)
111     WRITE (06,4050) J,(IDUM(I),I=1,NXR)
        IF(HEAT) THEN
            DO 151 J=1,NLY 
                DO 141 N=1,NXR 
                    IN=NLY*(N-1)+J 
                    Q(IN)=0.0D0 
141             IHDUM(N)= NHTYP(IN)
                !      WRITE (06,4081) J,(IHDUM(I),I=1,NXR)
151         continue
        END IF
        IF(SOLUTE)THEN
            DO 152 J=1,NLY 
                DO 142 N=1,NXR 
                    IN=NLY*(N-1)+J 
                    Q(IN)=0.0D0 
142             ISDUM(N)= NCTYP(IN)
                !   WRITE (06,4081) J,(ISDUM(I),I=1,NXR)
152         continue
        END IF
        TMPX=STIM+TPER
        IF(TMPX+0.5D0*DLTMIN.GT.TMAX) TMPX=TMAX
        !
        !   CALCULATE NEW COEFFICIENTS
        !
        IF(KTIM.NE.1)CALL VSCOEF
    END IF
    !
    !   INITIALIZE REQUIRED ARRAYS FOR NEW BOUNDARY CONDITION, UPDATE
    !   PXXX,THLST.  COMPUTE MAXIMUM HEAD CHANGE DURING LAST TIME STEP
    !
    PDIF=0.0D0
    IF(.NOT.SSTATE) THEN
        DO 121 J=2,NLYY
            DO 121 N=2,NXRR
                IN=NLY*(N-1)+J
                IF(HX(IN).EQ.0.0D0) GO TO 121
                P12=P(IN)-PXXX(IN)
                PTMP=DABS(P12)
                IF(PTMP.GT.PDIF)PDIF=PTMP
                PXXX(IN)=P(IN)
                THLST(IN)=THETA(IN)
                IF(HEAT)TTOLD(IN)=TT(IN)
                IF(SOLUTE)THEN
                    DO 119 M=1,Nsol   
                        CCOLD(M,IN)=CC(M,IN) 
119                 CONTINUE
                END IF
121     CONTINUE
        !
        !    CHECK FOR STEADY STATE
        !
        IF(jflag.ne.1.and.PDIF.LE.STERR) THEN
            SSTATE=.TRUE.
            WRITE(6,4060) STIM,KTIM
        END IF
    END IF
    JFLAG=0
    !
    !   INITIALIZE DHMX
    !
    DO 131 K=1,itmax
131 DHMX(K)=0.0D0
    !
    !    ADVANCE DELT AND RESET TO PROPER LENGTH IF NECESSARY
    !
    if (delt.lt.dltmin) delt = dltmin
    DLTOLD=DELT
    DELT= TMLT*DELT
    !
    !    MAXIMUM PERMISSABLE HEAD CHANGE CHECK
    !
    IF(KTIM.GE.2) THEN
        IF((PDIF*DELT/DLTOLD).GT.DSMAX)DELT=DLTOLD*DSMAX*0.98D0/PDIF
    END IF
    T1=DMIN1(TMPX,PLTIM(KPLT))
    T2=T1-STIM
    !
    !  changes made 6-12-02 for calculating delt.  This new
    !  version will allow delt<dltmin only to match obs times
    !  or end of recharge period.
    !  THESE NEED TO BE CHECKED CAREFULLY
    !
    !      IF(DELT.GT.(T2-DLTMIN)) DELT=T2
    !      IF(DELT.LT.DLTMIN)DELT=DLTMIN
    if(delt.gt.t2) then
        delt = t2
    else
        if(delt.lt.dltmin) delt = dltmin
    end if
    !      IF(DELT.GT.DLTMX)DELT=DLTMX
    if(delt-dltmx.ge.0.000001D0*dltmin) delt = dltmx
    !      IF(T1.NE.PLTIM(KPLT).OR.T2-DELT.GT.0.5D0*DLTMIN) GO TO 140
    IF(T1.NE.PLTIM(KPLT).or.t2-delt.gt.0.d0) GO TO 140
    KPLT=KPLT+1
    JPLT=1
    !  140 IF(DELT.LT.DLTMIN)DELT=DLTMIN
140 continue
    STIM=STIM+DELT
    !      IF (TMPX-STIM.LT.0.5D0*DLTMIN) JFLAG=1
    !      IF(TMAX-STIM.LT.0.5D0*DLTMIN) THEN
    !      IF (TMPX-STIM.LT.0.000001D0*DLTMIN) JFLAG=1
    IF (TMPX-STIM.LT.0.000001D0*DLTMIN) then
        JFLAG=1
        JPLT=1
        delt = delt + (tmpx - stim)
        stim = tmpx
        do
            if (stim.lt.pltim(kplt)) exit
            kplt = kplt + 1
        end do
    end if
    IF(TMAX-STIM.LT.0.000001*DLTMIN) THEN
        !
        !  end changes of 6-12-02
        !
        JSTOP=1
        JPLT=1
    ELSE
        IF(KTIM.GT.NUMT) THEN
            JSTOP=8
            JPLT=1
            write(stderr,*) 'Maximum number of time steps exceeded' &
            , ' Simulation terminated'
            WRITE(6,4080)
        END IF
    END IF
    !!@@include 'd_ihdummDealloc.inc'
    deallocate(IHDUM)
    !!@@include 'd_isdummDealloc.inc'
    deallocate(ISDUM)
    RETURN
4000 FORMAT(6X,'DATA FOR RECHARGE PERIOD ',I9//10X, &
23  HLENGTH OF THIS PERIOD =,1PE14.5,1X,A4,/10X, &
45  HLENGTH OF INITIAL TIME STEP FOR THIS PERIOD =,1PE14.5,1X,A4/ &
10  X,27HMULTIPLIER FOR TIME STEP = ,1PE10.3,/10X, &
25  HMAXIMUM TIME STEP SIZE = ,1PE14.5,1X,A4/10X, &
25  HMINIMUM TIME STEP SIZE = ,1PE14.5,1X,A4, &
    /10X,'TIME STEP REDUCTION FACTOR = ',1PE10.3)
4010 FORMAT(15X,37HPRINT SOLUTION AFTER EVERY TIME STEP?,1X,L1/ &
15  X,'SIMULATE EVAPORATION? ',L1/ &
15  X,29HSIMULATE EVAPOTRANSPIRATION? ,L1/ &
15  X,24HSIMULATE SEEPAGE FACES? ,L1/)
4012 format(16x,'WARNING -- GRAVITY BOUNDARY NODE MUST LIE ABOVE ',  &
    'AN INACTIVE NODE.'/16X,'AND BELOW AN ACTIVE NODE.'/16X, &
    'GRAVITY BOUNDARY NOT APPLIED FOR CELL: ' &
    ,2I6/)
4020 FORMAT( &
15  X,55HMAXIMUM PRESSURE HEAD CHANGE ALLOWED IN ONE TIME STEP =, &
    F8.3/15X,'STEADY-STATE CLOSURE CRITERION = ',1PE10.3/ &
15  X,'MAXIMUM DEPTH OF PONDING = ',1PE10.3)
4030 FORMAT(1X,'******** WARNING --- NODE TYPE OF 0 ASSIGNED TO BO',  &
    'UNDARY NODE ',2I5)
4040 FORMAT(6X,41HNODE TYPE AND INITIAL BOUNDARY CONDITIONS, &
12  H FOR PERIOD ,I9/6X,8HLEGEND: /15X,17H0 = INTERIOR CELL/ &
15  X,32H1 = SPECIFIED PRESSURE HEAD CELL/15X, &
23  H2 = SPECIFIED FLUX CELL/ &
15  X,31H3 = POTENTIAL SEEPAGE FACE NODE/ &
15  X,43H5 = NODE FOR WHICH EVAPORATION IS PERMITTED/ &
15  x,'7 = GRAVITY DRAIN CELL'/) 
4050 FORMAT(1H ,I5,5X,100(99999I1))
4060 FORMAT(6X,100(1H*)/5X, &
    'STEADY STATE REACHED AT TIME = ',E14.6,'   TIME STEP NUMBER = ' &
    ,I9//)
4070 FORMAT(6X,100(1H*),/,5X,17HEND OF SIMULATION/,  &
5   X,33HMAXIMUM SIMULATION TIME (TMAX) = ,E15.6/, &
5   X,33HELAPSED SIMULATION TIME (STIM) = ,E15.6/, &
6   X,100(1H*))
4080 FORMAT(' Maximum number of time steps exceeded'/ &
    ' Simulation terminated')
4081 FORMAT(1H ,I5,5X,80I1)      
    END
    SUBROUTINE VSMGEN
    !******
    !VSMGEN
    !******
    !
    !    PURPOSE:  TO SET UP COEFFICIENT MATRICES AND CALL
    !          SOLUTION ALGORITHM
    !
    !-----------------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use disch
    use hcon
    use equat
    use jtxx
    use ptet
    use pit
    use plott
    use rpropsh
    use scon
    use equats
    use temp
    use TRXXH
    use REDUCE_TIME
    use TRXX
    use gmres1
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/WGT/WUS,WDS
    COMMON/SCN1/TMPX,TMLT,DLTMX,DLTMIN,TRED
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/FLO/FLOW
    COMMON/SCON1/ITESTS
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    logical solved, pmgmres_ilu_cr
    real ( kind = 8 ) xdiff, xdiffMax
    !
    ! ......................................................................
    !  START OF LINEARIZATION ITERATION LOOP
    ! .....................................................................
    !
    !    UPDATE COEFFICIENTS
    !
    I13=0
    !
    !     ESTABLISH TIME-DEPENDENT PARAMETERS GOVERNING EVAPORATION AND
    !     TRANSPIRATION.  DETERMINE ROOT ACTIVITY.
    !
    if (reduce_time_step) goto 1000
10  IF ( BCIT.OR. ETSIM) THEN
        CALL VSPET
        DO 20 J=2,NLYY
            DO 20 I=2,NXRR
                N=NLY*(I-1)+J
                IF(HX(N).GT.0.0D0) THEN
                    IF(ETSIM) RT(N)=VSRDF(DPTH(N),DELZ(J))
                    Q(N)=0.0D0
                END IF
20      CONTINUE
    END IF
30  IF (NIT.NE.0) CALL VSCOEF
    !
    ! --------------------  UPDATE BOUNDARY AND FLUX CONDITIONS ------------
    !
    IF(BCIT)CALL VSEVAP
    IF (ETSIM)CALL VSPLNT
    IF(SEEP) CALL VSSFAC
    if(GRAV.and.nit.eq.0) CALL vsgrav_dr
    xdiffMax = 0.0D0
    ITEST = 0
    !
    ! .....................................................................
    !
    !         LOOP TO CALCULATE COEFFICIENT MATRIX
    ! .....................................................................
    !
    DO 40 J=2,NLYY
        DO 40 I=2,NXRR
            N=NLY*(I-1)+J
            IF(HX(N).GT.0.0D0) THEN
                JM1=N-1
                JP1=N+1
                IM1=N-NLY
                IP1=N+NLY
                VOL=DXR(I)*DELZ(J)
                IF(RAD)VOL=PI2*RX(I)*DXR(I)*DELZ(J)
                JJ=JTEX(N)
                !
                !   CALCULATE STORAGE TERMS
                !
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(I)*CS2
                END IF
                PTMP=P(N)+Z1
                if(hydraulicFunctionType.eq.1) then
                    SCAP=VSDTHUVG(PTMP,JJ)
                else
                    if(hydraulicFunctionType.eq.2) then
                        SCAP=VSDTHUHK(PTMP,JJ)
                    else
                        if(hydraulicFunctionType.eq.0) then
                            SCAP=VSDTHUBC(PTMP,JJ)
                        else
                            if(hydraulicFunctionType.eq.3) then
                                SCAP=VSDTHUTAB(PTMP,JJ)
                            else
                                SCAP=VSDTHUOT(PTMP,JJ)
                            end if
                        end if
                    end if
                end if
                if(HEAT)THEN
                    GSF=VOL*SCAP*RHO(N)
                else
                    GSF=VOL*SCAP
                END IF 
                if (HK(JJ,3).ne. 0.0D0) then
                    SS=HK(JJ,2)/HK(JJ,3)
                else
                    SS=0.0D0
                end if
                IF (HEAT) THEN
                    GSS=VOL*THETA(N)*SS*RHO(N)
                ELSE
                    GSS=VOL*THETA(N)*SS
                END IF
                G1=0.0D0
                !
                !   APPLY NEWTON-RAPHSON LINEARIZATION TO STORAGE TERM.
                !   PITT HOLDS STORAGE TERMS FROM PREVIOUS ITERATION.
                !
                IF(NIT.GT.0.AND.XI(N).NE.0.0D0) G1=(P(N)-PXXX(N))*&
                (GSF+GSS-PITT(N))/XI(N)
                PITT(N)=GSF+GSS
                if (.not. use_gmres_flow) then
                 G1=-G1/DELT
                else
                 G1 = 0.0d0
                end if
                GSF=-GSF/DELT
                GSS=-GSS/DELT
                IF(WUS.EQ.0.0D0) THEN
                    !
                    !   USE GEOMETRIC MEAN OR WEIGHTS FOR INTERCELL K
                    !     
                    IF(HEAT)THEN
                        A(N)=HKLL(N)*DSQRT(HCND(IM1)*RHO(IM1)*HCND(N)*RHO(N))
                        B(N)=HKTT(N)*DSQRT(HCND(JM1)*RHO(JM1)*HCND(N)*RHO(N))
                        C(N)=HKLL(IP1)*DSQRT(HCND(IP1)*RHO(IP1)*HCND(N)*RHO(N))
                        D(N)=HKTT(JP1)*DSQRT(HCND(JP1)*RHO(JP1)*HCND(N)*RHO(N))
                    ELSE
                        A(N)=HKLL(N)*DSQRT(HCND(IM1)*HCND(N))
                        B(N)=HKTT(N)*DSQRT(HCND(JM1)*HCND(N))
                        C(N)=HKLL(IP1)*DSQRT(HCND(IP1)*HCND(N))
                        D(N)=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(N))
                    END IF
                ELSE
                    !
                    !  CHOOSE UPSTREAM WEIGHTING COEFFICIENTS
                    !
                    IF(P(IM1).LE.P(N).OR.HX(IM1).EQ.0.0D0) THEN
                        ALA=WDS
                        BTA=WUS
                    ELSE
                        ALA=WUS
                        BTA=WDS
                    END IF
                    IF(P(JM1).LE.P(N).OR.HX(JM1).EQ.0.0D0) THEN
                        ALB=WDS
                        BTB=WUS
                    ELSE
                        ALB=WUS
                        BTB=WDS
                    END IF
                    IF(P(IP1).LE.P(N).OR.HX(IP1).EQ.0.0D0) THEN
                        ALC=WDS
                        BTC=WUS
                    ELSE
                        ALC=WUS
                        BTC=WDS
                    END IF
                    IF(P(JP1).LE.P(N).OR.HX(JP1).EQ.0.0D0) THEN
                        ALD=WDS
                        BTD=WUS
                    ELSE
                        ALD=WUS
                        BTD=WDS
                    END IF
                    !
                    !   SET THE PENTA-DIAGNOL COEFFICIENT MATRIX (E IS MAIN DIAGNOL)
                    !   AND RIGHT HAND SIDE
                    !
                    IF(HEAT)THEN
                        A(N)=(ALA*HCND(IM1)*RHO(IM1)+BTA*HCND(N)*RHO(N))*HKLL(N)
                        B(N)=(ALB*HCND(JM1)*RHO(JM1)+BTB*HCND(N)*RHO(N))*HKTT(N)
                        C(N)=(ALC*HCND(IP1)*RHO(IP1)+BTC*HCND(N)*RHO(N))*HKLL(IP1)
                        D(N)=(ALD*HCND(JP1)*RHO(JP1)+BTD*HCND(N)*RHO(N))*HKTT(JP1)
                    ELSE
                        A(N)=(ALA*HCND(IM1)+BTA*HCND(N))*HKLL(N)
                        B(N)=(ALB*HCND(JM1)+BTB*HCND(N))*HKTT(N)
                        C(N)=(ALC*HCND(IP1)+BTC*HCND(N))*HKLL(IP1)
                        D(N)=(ALD*HCND(JP1)+BTD*HCND(N))*HKTT(JP1)
                    END IF
                END IF
                if(ntyp(n).eq.1) then
                    if(ntyp(im1).eq.1) a(n) = 0.0d0
                    if(ntyp(jm1).eq.1) b(n) = 0.0d0
                    if(ntyp(ip1).eq.1) c(n) = 0.0d0
                    if(ntyp(jp1).eq.1) d(n) = 0.0d0
                end if
                E(N)=-A(N)-B(N)-C(N)-D(N)
                IF(HEAT)THEN
                    RHS(N)=VOL*(THETA(N)*RHO(N)-THLST(N)*RHOOLD(N))/DELT-&
                    (Q(N)+QQ(N))*RHO(N)-(A(N)*P(IM1)+B(N)*P(JM1)+ &
                    C(N)*P(IP1)+D(N)*P(JP1)+(E(N)+GSS)*P(N))+GSS*PXXX(N) 
                ELSE    
                    RHS(N)=VOL*(THETA(N)-THLST(N))/DELT-(Q(N)+QQ(N))-(A(N)*P(IM1)+B(N)&
                    *P(JM1)+C(N)*P(IP1)+D(N)*P(JP1)+(E(N)+GSS)*P(N))+GSS*PXXX(N)
                END IF
                E(N)=E(N)+GSF+GSS+G1
            END IF
40  CONTINUE
    !
    !    CALL SOLUTION ALGORITHM
    !
    NIT=NIT+1
    !use_gmres_flow = .false.
    if (.not. use_gmres_flow) then
        CALL SLVSIP
    else
        !   installing gmress solver. No need for iterating on heat equation
        !    first step is to move coefficients into storate gmres storage
        !    arrays. We need to reorder nodes, numbering only the active
        !    nodes.
        ! 
        ia_gmr = 0
        ja_gmr = 0
        a_gmr = 0.0d0
        xi = 0.0d0
        rhs_gmr = 0.0d0       
        n_order = 0
        nz_num = 0
        nly2 = nly - 2
        DO 300 I=2,NXRR
            N1=NLY*(I-1)
            DO 300 J=2,NLYY
                N=N1+J
                if(hx(n).eq.0.0d0.or.ntyp(n).eq.1) then
                    n_order = n_order + 1
                    nz_num = nz_num + 1
                    a_gmr(nz_num) = 1.0d0
                    !       ia_gmr(nz_num) = n_order
                    ia_gmr(n_order) = nz_num
                    ja_gmr(nz_num) = n_order
                    rhs_gmr(n_order) = 0.0d0
                    xi(n_order) = 0.0d0
                else
                    n_order = n_order + 1
                    nz_num = nz_num + 1
                    a_gmr(nz_num) = e(n)
                    !       ia_gmr(nz_num) = n_order
                    ia_gmr(n_order) = nz_num
                    ja_gmr(nz_num) = n_order
                    rhs_gmr(n_order) = rhs(n)
                    xi(n_order) = 0.0d0      
                    if(a(n).ne.0.0d0) then
                        nz_num = nz_num + 1
                        a_gmr(nz_num) = a(n)
                        !         ia_gmr(nz_num) = n_order
                        ja_gmr(nz_num) = n_order - nly2
                    end if
                    if(b(n).ne.0.0d0) then
                        nz_num = nz_num +1
                        a_gmr(nz_num) = b(n)
                        !         ia_gmr(nz_num) = n_order
                        ja_gmr(nz_num) = n_order - 1
                    end if
                    if(c(n).ne.0.0d0) then
                        nz_num = nz_num +1
                        a_gmr(nz_num) = c(n)
                        !         ia_gmr(nz_num) = n_order
                        ja_gmr(nz_num) = n_order +  nly2
                    end if
                    if(d(n).ne.0.0d0) then
                        nz_num = nz_num +1
                        a_gmr(nz_num) = d(n)
                        !         ia_gmr(nz_num) = n_order
                        ja_gmr(nz_num) = n_order + 1
                    end if
                end if   
300     continue
        ia_gmr(n_order+1) = nz_num + 1
        itmax1 = itmax/10
        !      mr = n_order - 1
        !      mr = 200
        mr = MIN0(20,n_order-1)
        !call pmgmres_ilu_cr ( n, nz_num, ia, ja, a, x, rhs, itr_max, mr, &
        !   tol_abs, tol_rel )
        solved = pmgmres_ilu_cr ( n_order, nz_num, ia_gmr, ja_gmr, a_gmr, xi, rhs_gmr, itmax1, mr, &
        eps, eps )
        if (solved) then
        n_order = 0
        DO 301 I=2,NXRR
            N1=NLY*(I-1)
            DO 301 J=2,NLYY
                N=N1+J
                n_order = n_order + 1
                if(hx(n).ne.0.0d0.and.ntyp(n).ne.1) then
                    p(n) = p(n) + xi(n_order)
                    xdiff = dabs(xi(n_order))
                    if (xdiff.gt.xdiffMax) xdiffMax = xdiff
                end if
301     continue  
         else
            nit = itmax + 1
            xdiffMax = 2*eps
        endif
    endif
    
    IF(NIT.LT.MINIT) GO TO 30
    if(xdiffMax.gt.eps) ITEST = 1
    !
    !   IF SOLUTION HAS BEEN FOUND THEN RETURN
    !
    IF(ITEST.EQ.0) then
        write(stderr,*) "  Done with flow."
        RETURN
    endif
    
    IF(NIT.LE.ITMAX) GO TO 30
    !
    !   MAXIMUM NUMBER OF ITERATIONS EXCEEDED
    !     
    write(stderr,*) 'ERROR: EXCEEDED PERMITTED NUMBER OF ITERATIONS'
    WRITE (6,4000) NIT,KTIM,STIM,TUNIT
    !
    !   AUTOMATICALLY REDUCE TIME STEP SIZE, BUT NOT MORE
    !   THAN TWICE.
    !
1000 continue 
    !IF(DELT.LE.DLTMIN.OR.I13.GT.2.OR.TRED.LE.0.0D0) THEN
    IF(DELT.LE.DLTMIN.OR.TRED.LE.0.0D0) THEN
        IF(.NOT.ITSTOP)RETURN
        !
        !   TERMINATE SIMULATION.
        !
        JSTOP=9
        JFLAG=1
        WRITE(6,4020)
        RETURN
    ELSE
        I13=I13+1
        DELTT=DELT*TRED
        IF(DELTT.LT.DLTMIN) DELTT=DLTMIN
        if(delt-deltt.ge.dltmin) then
            jflag = 0
            if(jstop.eq.1) then
                jstop = 0
                jplt = 0
            else
                if(jplt.eq.1) then
                    jplt = 0
                    if(stim.eq.pltim(kplt)) kplt = kplt - 1
                end if
            end if
        end if
        WRITE(6,4010) DELTT
        STIM=STIM-DELT+DELTT
        DELT=DELTT
        !
        !   RESET HEADS TO VALUES AT END OF PREVIOUS TIME STEP.
        !
        if (solute) then
            do 203 J=1,NLY
                DO 203 N=1,NXR
                    DO 201 M=1,Nsol
                        IN=NLY*(N-1)+J
                        CC(M,IN) = CCOLD(M,IN)
201                 CONTINUE
203         CONTINUE
        endif
        DO 50 II=1,NNODES
            IF(NTYP(II).NE.1.AND.HX(II).GT.0.0D0) THEN
                P(II)=PXXX(II)
                IF (HEAT) TT(II) = TTOLD(II)
            ENDIF
50      CONTINUE
        NIT=1
        GO TO 10
    END IF
4000 FORMAT(5X,100(1H*)/5X,'EXCEEDED PERMITTED NUMBER OF ITERATIONS', &
    '  ( =',I9,')' &
    /5X,'TIME STEP NUMBER',I9/5X,'ELAPSED TIME = ', &
1   PE14.5,1X,A4  /5X,100(1H*))
4010 FORMAT(5X,'TIME STEP SIZE REDUCED TO ',E14.6)
4020 FORMAT('Simulation terminated')
    END
    SUBROUTINE VSSIP
    !
    !*****
    !VSSIP
    !*****
    !
    !     PURPOSE: TO SOLVE THE  MATRIX EQUATIONS USING THE
    !     STRONGLY IMPLICIT METHOD
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use press
    use equat
    use jtxx
    use trxxh
    use sip
    use rpropsh
    use scon
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    DIMENSION IORDER(21)
    DIMENSION TEMP(100),HM(30)
    SAVE HM,W1,W9,L2,NTH
    DATA W1/0.0D0/
    !
    !-------------------------------------------------------------------
    !
    DATA IORDER/1,2,3,4,5,1,2,3,4,5,11*1/
    !
    !     COMPUTE ITERATION PARAMETERS
    !
    J2=NXR-2
    I2=NLY-2
    L2=5
    PL2=L2-1
    W=0.0D0
    PIE=0.0D0
    W9=100.0D0
    !
    ! COMPUTE MAXIMUM PARAMETER
    !
    DO 10 I=2,NLYY
        DO 10 J=2,NXRR
            N=NLY*(J-1)+I
            IF(HX(N).GT.0.0D0) THEN
                IM1=JTEX(N)
                PIE=PIE+1.0D0
                DX=DXR(J)/RX(NXR)
                DY=DELZ(I)/DZZ(NLY)
                DX3=DX*DX
                DY2=DY*DY
                W=W+1.0D0-DMIN1((DX3+DX3)/(1.0D0+ANIZ(IM1)*DX3/DY2),(DY2+DY2)/&
                (1.0D0+DY2/(ANIZ(IM1)*DX3)))
            END IF
10  CONTINUE
    W=W/PIE
    !
    ! COMPUTE PARAMETERS IN GEOMETRIC SEQUENCE
    !
    PJ=-1.0D0
    DO 20 I=1,L2
        PJ=PJ+1.0D0
20  TEMP(I)=1.0D0 -(1.0D0 -W)**(PJ/PL2)
    !
    ! ORDER SEQUENCE OF PARAMETERS
    !
    DO 30 J=1,L2
30  HM(J)=TEMP(IORDER(J))
    !      WRITE (06,4000) L2,(HM(J),J=1,L2)
    RETURN
    !
    ! STRONGLY IMPLICIT ALGORITHM
    !
    ENTRY SLVSIP
    I2=NLY-2
    J2=NXR-2
    !      SELECT ITERATION PARAMETER.  INITIALIZE ARRAYS
    !
    IF(TRANS1) THEN
        !
        !  IF TRANS1=T  TRANSPORT EQUATION IS SOLVED
        !           =F  FLOW EQUATION IS SOLVED
        !
        NT=NIT1
    ELSE
        NT=NIT
    END IF
    IF(MOD(NT,L2).EQ.0.OR.NT.EQ.1)NTH=0
    NTH=NTH+1
    W=HM(NTH)
    CALL RANDOM_NUMBER(XF)
    XF = 1.0 - XF/10.0
    W = XF * W
    ITEST=0
    DO 40 I=1,NNODES
        DEL(I)=0.0D0
        ETA(I)=0.0D0
        V(I)=0.0D0
40  XI(I)=0.0D0
    BIGI=0.0D0
    BIGI1=0.0D0
    !
    ! CHOOSE SIP NORMAL OR REVERSE ALGORITHM
    !
    IF (NT < ITMAX/2) THEN
        IF(MOD(NT,2)) 50,80,50
    ELSE
        GOTO 50
    ENDIF
    ! ......................................................................
    ! ORDER EQUATIONS WITH ROW 1 FIRST  -  3X3 EXAMPLE:
    !    1 2 3
    !    4 5 6
    !    7 8 9
    ! ......................................................................
50  DO 60 I=2,NLYY
        DO 60 J=2,NXRR
            N=I+NLY*(J-1)
            !
            !   ---- SKIP COMPUTATIONS OF NODE IS OUTSIDE OF SOLUTION DOMAIN
            !
            IF(HX(N).EQ.0.0D0) GO TO 60
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 60
            NL=N-NLY
            NA=N-1
            NB=N+1
            !
            !     --- SIP "NORMAL" ALGORITHM-----
            !     --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V --
            !
            CH=DEL(NA)*B(N)/(1.0D0 +W*DEL(NA))
            GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
            BH=B(N)-W*CH
            DH=A(N)-W*GH
            EH=E(N)+W*CH+W*GH
            FH=C(N)-W*CH
            HH=D(N)-W*GH
            ALFA=BH
            BETA=DH
            GAMA=EH-ALFA*ETA(NA)-BETA*DEL(NL)
            DEL(N)=FH/GAMA
            ETA(N)=HH/GAMA
            RES=RHS(N)
            V(N)=(HMAX*RES-ALFA*V(NA)-BETA*V(NL))/GAMA
60  CONTINUE
    !
    !  ---BACK SUBSTITUTE FOR VECTOR XI
    !
    DO 70 I=1,I2
        I3=NLY-I
        DO 70 J=1,J2
            J3=NXR-J
            N=I3+NLY*(J3-1)
            IF(HX(N).EQ.0.0D0) GO TO 70
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 70
            XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N+1)
            !
            !      FIND MAXIMUM HEAD CHANGE
            !
            TCHK=DABS(XI(N))
            IF(TCHK.GE.BIGI) THEN
                BIGI=TCHK
                BIGI1=XI(N)
            END IF
70  CONTINUE
    GO TO 110
    !
    !.......................................................................
    !  ---ORDER EQUATIONS WITH THE LAST ROW FIRST  -  3X3 EXAMPLE
    !           7 8 9
    !           4 5 6
    !           1 2 3
    !......................................................................
    !
80  DO 90 II=1,I2
        I=NLY-II
        DO 90 J=2,NXRR
            N=I+NLY*(J-1)
            NL=N-NLY
            NA=N-1
            NB=N+1
            !
            !  -- SKIP COMPUTATIONS IF NODE IS OUTSIDE OF SOLUTION DOMAIN
            !
            IF(HX(N).EQ.0.0D0) GO TO 90
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 90
            !
            !------ SIP "REVERSE" ALGORITHM
            ! --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V
            !
            CH=DEL(NB)*D(N)/(1.0D0 +W*DEL(NB))
            GH=ETA(NL)*A(N)/(1.0D0 +W*ETA(NL))
            BH=D(N)-W*CH
            DH=A(N)-W*GH
            EH=E(N)+W*CH+W*GH
            FH=C(N)-W*CH
            HH=B(N)-W*GH
            ALFA=BH
            BETA=DH
            GAMA=EH-ALFA*ETA(NB)-BETA*DEL(NL)
            DEL(N)=FH/GAMA
            ETA(N)=HH/GAMA
            RES=RHS(N)
            V(N)=(HMAX*RES-ALFA*V(NB)-BETA*V(NL))/GAMA
90  CONTINUE
    !
    ! --- BACK SUBSTITUTE FOR VECTOR XI
    !
    DO 100 I3=2,NLYY
        DO 100 J=1,J2
            J3=NXR-J
            N=I3+NLY*(J3-1)
            IF(HX(N).EQ.0.0D0) GO TO 100
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS1)).OR.(TRANS1.AND.(NHTYP(N).EQ.1)))GO TO 100
            XI(N)=V(N)-DEL(N)*XI(N+NLY)-ETA(N)*XI(N-1)
            !
            !      FIND MAXIMUM HEAD CHANGE
            !
            TCHK=DABS(XI(N))
            IF(TCHK.GE.BIGI) THEN
                BIGI=TCHK
                BIGI1=XI(N)
            END IF
100 CONTINUE
    !
    !      COMPUTE RELAXATION PARAMETER W FOR HEAD CHANGES.  ALGORITHM
    !      IS FROM COOLEY (1983)
    !
110 S=1.0D0
    IF(NT.GT.1.AND.W1.NE.0.0D0) S=BIGI1/W1
    S1=DABS(S)
    IF(S.LT.-1.0D0) THEN
        W=1.0D0/(S1+S1)
    ELSE
        W=(3.0D0+S)/(3.0D0+S1)
    END IF
    IF(W.EQ.W9) W=0.9D0*W
    W1=W*BIGI
    IF(W1.GT.DSMAX) W=DSMAX/BIGI
    IF(BIGI1.LT.0.0D0) W1=-W1
    !
    !     ADD CHANGES TO MATRIX.
    !
    W9=W
    IF(TRANS1) THEN
        DO 120 N=NLY+1,NNODES
            IF(NHTYP(N).NE.1.AND.HX(N).GT.0.0D0) TT(N)=TT(N)+W*XI(N)
120     CONTINUE
        IF(BIGI.GT.EPS1) ITEST=1
    ELSE
        DO 130 N=NLY+1,NNODES
            IF(HX(N).GT.0.0D0.AND.NTYP(N).NE.1) P(N)=P(N)+W*XI(N)
130     CONTINUE
        !
        !      COMPARE MAXIMUM HEAD CHANGE TO CLOSURE CRITERION.
        !
        IF(BIGI.GT.EPS) ITEST=1
        DHMX(NIT)=BIGI
    END IF
    RETURN
    ! 4000 FORMAT(1X,I5,25HSIP ITERATION PARAMETERS:,6D15.7/(28X,6D15.7/))
    END
    SUBROUTINE VSSIPSOL
    !*****
    !VSSIPSOL
    !*****
    !
    !     PURPOSE: TO SOLVE THE  MATRIX EQUATIONS USING THE
    !     STRONGLY IMPLICIT METHOD
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use press
    use equats
    use jtxx
    use trxx
    use sip
    use rpropsh
    use scon
    use tempcc
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/SCON1/ITESTS
    DIMENSION IORDERS(21)
    DIMENSION TEMPS(100),HMS(30)
    SAVE HMS,W1S,WS9,LS2,NTHS
    DATA W1S/0.0D0/
    !
    !-------------------------------------------------------------------
    !
    DATA IORDERS/1,2,3,4,5,1,2,3,4,5,11*1/
    !
    !     COMPUTE ITERATION PARAMETERS
    !
    J2=NXR-2
    I2=NLY-2
    LS2=5
    PL2=LS2-1
    WS=0.0D0
    PIE=0.0D0
    WS9=100.0D0
    !
    !  COMPUTE MAXIMUM PARAMETER
    !
    DO 10 I=2,NLYY
        DO 10 J=2,NXRR
            N=NLY*(J-1)+I
            IF(HX(N).GT.0.0D0) THEN
                IM1=JTEX(N)
                PIE=PIE+1.0D0
                DX=DXR(J)/RX(NXR)
                DY=DELZ(I)/DZZ(NLY)
                DX3=DX*DX
                DY2=DY*DY
                WS=WS+1.0D0-DMIN1((DX3+DX3)/(1.0D0+ANIZ(IM1)*DX3/DY2),(DY2+DY2)/&
                (1.0D0+DY2/(ANIZ(IM1)*DX3)))
            END IF
10  CONTINUE
    WS=WS/PIE
    !
    ! COMPUTE PARAMETERS IN GEOMETRIC SEQUENCE
    !
    PJ=-1.0D0
    DO 20 I=1,LS2
        PJ=PJ+1.0D0
20  TEMPS(I)=1.0D0 -(1.0D0 - WS)**(PJ/PL2)
    !
    ! ORDER SEQUENCE OF PARAMETERS
    !
    DO 30 J=1,LS2
        HMS(J)=TEMPS(IORDERS(J))
30  CONTINUE 
    !      WRITE (06,4000) LS2,(HMS(J),J=1,LS2)
    RETURN
    !
    ! STRONGLY IMPLICIT ALGORITHM
    !
    ENTRY SLVSIPSOL
    I2=NLY-2
    J2=NXR-2
    !
    !      SELECT ITERATION PARAMETER.  INITIALIZE ARRAYS
    !      
    IF(TRANS2) THEN
        !
        !  IF TRANS =T  SOLUTE TRANSPORT EQUATION IS SOLVED
        !           =F  FLOW EQUATION IS SOLVED
        !
        NT=NIS1
    ELSE
        NT=NIT
    END IF
    IF(MOD(NT,LS2).EQ.0.OR.NT.EQ.1)NTHS=0
    NTHS=NTHS+1
    WS=HMS(NTHS)
    
    CALL RANDOM_NUMBER(XF)
    XF = 1.0 - XF/10.0
    WS = XF * WS
    
    ITESTS=0
    DO 40 I=1,NNODES
        DEL(I)=0.0D0
        ETA(I)=0.0D0
        V(I)=0.0D0
40  XIS(I)=0.0D0
    BIGIS=0.0D0
    BIGIS1=0.0D0
    !
    ! CHOOSE SIP NORMAL OR REVERSE ALGORITHM
    !
    IF (NT < ITMAX/2) THEN
        IF(MOD(NT,2)) 50,80,50
    ELSE
        GOTO 50
    ENDIF
    
    ! ......................................................................
    ! ORDER EQUATIONS WITH ROW 1 FIRST  -  3X3 EXAMPLE:
    !    1 2 3
    !    4 5 6
    !    7 8 9
    ! ......................................................................
50  DO 60 I=2,NLYY
        DO 60 J=2,NXRR
            N=I+NLY*(J-1)
            !
            !   ---- SKIP COMPUTATIONS OF NODE IS OUTSIDE OF SOLUTION DOMAIN
            !
            !1      IF(HX(N).EQ.0.0D0 .OR. NTYP(N).EQ.1.0) GO TO 60
            IF(HX(N).EQ.0.0D0) GO TO 60
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 60   
            NL=N-NLY
            !      NR=N+NLY 
            NA=N-1
            NB=N+1
            !
            !     --- SIP "NORMAL" ALGORITHM-----
            !     --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V --
            !
            CH=DEL(NA)*BS(N)/(1.0D0 +WS*DEL(NA))
            GH=ETA(NL)*AS(N)/(1.0D0 +WS*ETA(NL))
            BH=BS(N)-WS*CH
            DH=AS(N)-WS*GH
            EH=ES(N)+WS*CH+WS*GH
            FH=CS(N)-WS*CH
            HH=DS(N)-WS*GH
            ALFAS=BH
            BETAS=DH
            GAMAS=EH-ALFAS*ETA(NA)-BETAS*DEL(NL)
            DEL(N)=FH/GAMAS
            ETA(N)=HH/GAMAS
            RES=RHSS(N)
            V(N)=(HMAX*RES-ALFAS*V(NA)-BETAS*V(NL))/GAMAS

60  CONTINUE

    !
    !  ---BACK SUBSTITUTE FOR VECTOR XI
    !

    DO 70 I=1,I2
        I3=NLY-I
        DO 70 J=1,J2
            J3=NXR-J
            N=I3+NLY*(J3-1)
            IF(HX(N).EQ.0.0D0) GO TO 70
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 70
            XIS(N)=V(N)-DEL(N)*XIS(N+NLY)-ETA(N)*XIS(N+1)
            !
            !      FIND MAXIMUM HEAD CHANGE
            !
            TCHKS=DABS(XIS(N))
            IF(TCHKS.GE.BIGIS) THEN
                BIGIS=TCHKS
                BIGIS1=XIS(N)
            END IF
70  CONTINUE
    GO TO 110
    !
    !.......................................................................
    !  ---ORDER EQUATIONS WITH THE LAST ROW FIRST  -  3X3 EXAMPLE
    !           7 8 9
    !           4 5 6
    !           1 2 3
    !.......................................................................
    !
80  DO 90 II=1,I2
        I=NLY-II
        DO 90 J=2,NXRR
            N=I+NLY*(J-1)
            NL=N-NLY
            !      NR=N+NLY  
            NA=N-1
            NB=N+1
            !
            !  -- SKIP COMPUTATIONS IF NODE IS OUTSIDE OF SOLUTION DOMAIN
            !
            IF(HX(N).EQ.0.0D0) GO TO 90
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 90
            !
            ! ------ SIP "REVERSE" ALGORITHM
            ! --- FORWARD SUBSTITUTE, COMPUTING INTERMEDIATE VECTOR V
            !
            CH=DEL(NB)*DS(N)/(1.0D0 +WS*DEL(NB))
            GH=ETA(NL)*AS(N)/(1.0D0 +WS*ETA(NL))
            BH=DS(N)-WS*CH
            DH=AS(N)-WS*GH
            EH=ES(N)+WS*CH+WS*GH
            FH=CS(N)-WS*CH
            HH=BS(N)-WS*GH
            ALFAS=BH
            BETAS=DH
            GAMAS=EH-ALFAS*ETA(NB)-BETAS*DEL(NL)
            DEL(N)=FH/GAMAS
            ETA(N)=HH/GAMAS
            RES=RHSS(N)
            V(N)=(HMAX*RES-ALFAS*V(NB)-BETAS*V(NL))/GAMAS

90  CONTINUE
    !
    ! --- BACK SUBSTITUTE FOR VECTOR XI
    !
    DO 100 I3=2,NLY
        DO 100 J=1,J2
            J3=NXR-J
            N=I3+NLY*(J3-1)
            IF(HX(N).EQ.0.0D0) GO TO 100
            IF((NTYP(N).EQ.1.AND.(.NOT.TRANS2)).OR.(TRANS2.AND.(NCTYP(N).EQ.1)))GO TO 100  
            XIS(N)=V(N)-DEL(N)*XIS(N+NLY)-ETA(N)*XIS(N-1)
            !
            !      FIND MAXIMUM HEAD CHANGE
            !
            TCHKS=DABS(XIS(N))
            IF(TCHKS.GE.BIGIS) THEN
                BIGIS=TCHKS
                BIGIS1=XIS(N)
            END IF
100 CONTINUE
    !
    !      COMPUTE RELAXATION PARAMETER W FOR HEAD CHANGES.  ALGORITHM
    !      IS FROM COOLEY (1983)
    !
110 S=1.0D0
    IF(NT.GT.1.AND.W1S.NE.0.0D0) S=BIGIS1/W1S
    S1=DABS(S)
    IF(S.LT.-1.0D0) THEN
        WS=1.0D0/(S1+S1)
    ELSE
        WS=(3.0D0+S)/(3.0D0+S1)
    END IF
    IF(WS.EQ.WS9) WS=0.9D0*WS
    W1S=WS*BIGIS
    IF(.NOT.TRANS2.AND.W1S.GT.DSMAX) WS=DSMAX/BIGIS
    IF(BIGIS1.LT.0.0D0)W1S=-W1S
    !
    !      ADD CHANGES TO MATRIX.
    !
    WS9=WS
    IF(TRANS2) THEN

    DO 120 N=NLY+1,NNODES
        IF(NCTYP(N).NE.1.AND.HX(N).GT.0.0D0)TempC(N)= TempC(N)+WS*XIS(N)

120 CONTINUE
    !
    !      COMPARE MAXIMUM HEAD CHANGE TO CLOSURE CRITERION.
    !
    IF(BIGIS.GT.EPS3) ITESTS=1
    ELSE
        DO 130 N=NLY+1,NNODES
            IF(HX(N).GT.0.0D0 .AND.NTYP(N).NE.1)P(N)=P(N)+WS*XIS(N)
130     CONTINUE
        IF(BIGIS.GT.EPS)ITESTS=1
        DHMX(NIT)=BIGIS
    end if    
    RETURN
    ! 4000 FORMAT(1X,I5,25HSIPS ITERATION PARAMETER:,6D15.7/(28X,6D15.7/))
    END
    SUBROUTINE VSCOEF
    !******
    !VSCOEF
    !******
    !     PURPOSE: TO COMPUTE ALL VALUES OF NONLINEAR COEFFICIENTS
    !              USING THE MOST RECENT VALUES OF PRESSURE HEAD
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use hcon
    use jtxx
    use rpropsh
    use trxxh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    !
    !-------------------------------------------------------------------
    if(hydraulicFunctionType.eq.1) then
        !
        !       Van Genuchten functions are used
        !
        DO 10 J=2,NLYY
            DO 10 N=2,NXRR
                IN=NLY*(N-1)+J
                IF(HX(IN).GT.0.0D0) THEN
                    J1=JTEX(IN)
                    HCND(IN)=0.0D0
                    !
                    !       COMPUTE PRESSURE HEADS TO USE IN FUNCTIONS
                    !
                    IF(CS1.EQ.1.0D0) THEN
                        Z1=DZZ(J)
                    ELSE
                        Z1=DZZ(J)*CS1+RX(N)*CS2
                    END IF
                    PTMP=P(IN)+Z1
                    IF(HEAT)THEN
                        HCND(IN)=VSHKUVGH(PTMP,TT(IN),J1)
                    ELSE
                        HCND(IN)=VSHKUVG(PTMP,J1)
                    END IF
                    THETA(IN)=VSTHUVG(PTMP,J1)
                END IF
10      CONTINUE
        RETURN
    else
        if(hydraulicFunctionType.eq.2) then
            !
            !       Haverkamp functions
            !
            DO 11 J=2,NLYY
                DO 11 N=2,NXRR
                    IN=NLY*(N-1)+J
                    IF(HX(IN).GT.0.0D0) THEN
                        J1=JTEX(IN)
                        HCND(IN)=0.0D0
                        IF(CS1.EQ.1.0D0) THEN
                            Z1=DZZ(J)
                        ELSE
                            Z1=DZZ(J)*CS1+RX(N)*CS2
                        END IF
                        PTMP=P(IN)+Z1
                        IF(HEAT)THEN
                            HCND(IN)=VSHKUHKH(PTMP,TT(IN),J1)  
                        ELSE   
                            HCND(IN)=VSHKUHK(PTMP,J1)
                        END IF
                        THETA(IN)=VSTHUHK(PTMP,J1)
                    END IF
11          CONTINUE
            RETURN
        else
            !
            !       Brooks-Corey functions
            !
            if(hydraulicFunctionType.eq.0) then
                DO 12 J=2,NLYY
                    DO 12 N=2,NXRR
                        IN=NLY*(N-1)+J
                        IF(HX(IN).GT.0.0D0) THEN
                            J1=JTEX(IN)
                            HCND(IN)=0.0D0
                            IF(CS1.EQ.1.0D0) THEN
                                Z1=DZZ(J)
                            ELSE
                                Z1=DZZ(J)*CS1+RX(N)*CS2
                            END IF
                            PTMP=P(IN)+Z1
                            IF(HEAT)THEN
                                HCND(IN)=VSHKUBCH(PTMP,TT(IN),J1)
                            ELSE  
                                HCND(IN)=VSHKUBC(PTMP,J1)
                            END IF
                            THETA(IN)=VSTHUBC(PTMP,J1)
                        END IF
12              CONTINUE
                RETURN
                !
                !       Tabular functions
                !
            else
                if(hydraulicFunctionType.eq.3) then
                    DO 13 J=2,NLYY
                        DO 13 N=2,NXRR
                            IN=NLY*(N-1)+J
                            IF(HX(IN).GT.0.0D0) THEN
                                J1=JTEX(IN)
                                HCND(IN)=0.0D0
                                IF(CS1.EQ.1.0D0) THEN
                                    Z1=DZZ(J)
                                ELSE
                                    Z1=DZZ(J)*CS1+RX(N)*CS2
                                END IF
                                PTMP=P(IN)+Z1
                                IF(HEAT)THEN
                                    HCND(IN)=VSHKUTABH(PTMP,TT(IN),J1)
                                ELSE  
                                    HCND(IN)=VSHKUTAB(PTMP,J1)
                                END IF
                                THETA(IN)=VSTHUTAB(PTMP,J1)
                            END IF
13                  CONTINUE
                    RETURN
                else
                    !
                    !  user supplied other function type
                    !
                    DO 14 J=2,NLYY
                        DO 14 N=2,NXRR
                            IN=NLY*(N-1)+J
                            IF(HX(IN).GT.0.0D0) THEN
                                J1=JTEX(IN)
                                HCND(IN)=0.0D0
                                IF(CS1.EQ.1.0D0) THEN
                                    Z1=DZZ(J)
                                ELSE
                                    Z1=DZZ(J)*CS1+RX(N)*CS2
                                END IF
                                PTMP=P(IN)+Z1
                                !
                                !  revisions for Rossi-Nimmo
                                !
                                !      HCND(IN)=VSHKUOT(PTMP,J1)
                                THETA(IN)=VSTHUOT(PTMP,J1)
                                IF(HEAT)THEN
                                    HCND(IN)=VSHKUOTH(THETA(IN),TT(IN),J1)
                                ELSE
                                    HCND(IN) = VSHKUOT(THETA(IN),J1)
                                END IF      
                                !
                                !  end revsions
                                !
                            END IF
14                  CONTINUE
                    RETURN
                end if
            end if
        end if
    end if
    END

    SUBROUTINE VSHCMP
    !******
    !VSHCMP
    !******
    !
    !   PURPOSE: TO COMPUTE INTERCELL CONDUCTANCES
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use hcon
    use jtxx
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    !
    !----------------------------------------------------------------------
    !
    !    COMPUTE HARMONIC MEANS OF KSAT AND GRID SPACING
    !
    DO 10 J=2,NLY
        DO 10 N=2,NXR
            IN=NLY*(N-1)+J
            JM1=IN-1
            NM1=IN-NLY
            A1=ANIZ(JTEX(IN))
            A2=ANIZ(JTEX(JM1))
            IF(HX(IN).EQ.0.0D0) GO TO 10
            AREA=DXR(N)
            IF(RAD)AREA=PI2*RX(N)*DXR(N)
            !
            !   VERTICAL CONDUCTANCE
            !   THROUGH TOP
            !
            HKTT(IN)=2.0D0*A1*A2*AREA*HX(IN)*HX(JM1)/(A2*HX(JM1)*DELZ(J)+&
            A1*HX(IN)*DELZ(J-1))
            AREA=DELZ(J)
            IF(RAD)AREA=PI2*DELZ(J)*(RX(N)-0.5D0 *DXR(N))
            !
            !   HORIZONTAL OR RADIAL CONDUCTANCE
            !   THROUGH LEFT-HAND SIDE
            !
            HKLL(IN)=2.0D0*AREA*HX(IN)*HX(NM1)/(HX(NM1)*DXR(N)+HX(IN)*DXR(N-1))
10  CONTINUE
    RETURN
    END
    SUBROUTINE VSFLUX
    !******
    !VSFLUX
    !******
    !
    !      PURPOSE: TO COMPUTE FLUXES AND MASS BALANCE
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use disch
    use dumm
    use jtxx
    use equat
    use equats
    use trxx
    use trxy1
    use plott
    use rpropsh
    use scon
    use BF
    use ptet
    use temp
    use pit
    use trxy2
    use trxxh
    use solmass
    use compnam
    use react
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    character*20 label9(72,3),label9SOL(36,3)      
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    common/elimit/elimit1,elimit2
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    COMMON/JCONF/JFLAG2
    CHARACTER*10 SCOMPNAME(50)
    COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
    bl95I,bl95IT,bl95O,bl95OT
    common/massb1/bcmf,bcmh, &
    bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
    common/massb2/j91,j92,j93,indexBL(72),indexBLSOL(36),  &
    indexFLOW(33),indexHT(39),label9,label9SOL      

    !-------------------------------------------------------------------
    !
    !   INITIALIZE MASS BALANCE VARIABLES USED FOR
    !   ENTIRE SIMULATION.
    !
    !
    !  05/02 new variables created:
    !   bcmf is water mass added to system by change in flow BC
    !   bcmt is solute mass added to system by change in flow BC
    !

    IF(KTIM.EQ.1) THEN
        DO 10 I=1,99
            BL(I)=0.0D0
10      CONTINUE
        if(solute)then
            do 100 N = 1,Nsol
                dO 108 I = 1,36
                    BLSOL(N,I)=0.0D0
108             continue
                bl62I(N)=0.0d0
                bl62IT(N)=0.0d0
                bl62O(N)=0.0d0
                bl62OT(N)=0.0d0
                bcmtt(N)=0.0d0
                bcmt(N)=0.0d0
                bcmtr(N)=0.0d0
                bltemp36(N) = 0.0d0
                bltemp39(N) = 0.0d0
                bltemp42(N) = 0.0d0
                bltemp45(N) = 0.0d0
                bltemp60(N) = 0.0d0   
100         CONTINUE     
        end if 
        if (f7p) then
            do 11 i = 1,numBF
                totalBF(i,1) = 0.0d0
                totalBF(i,2) = 0.0d0
                currentBF(i,4) = 0.0d0
11          continue
        end if

        bltemp69 = 0.0d0
        bltemp72 = 0.0d0
        bltemp75 = 0.0d0
        bltemp78 = 0.0d0
        bltemp91 = 0.0d0
        bcmft = 0.0d0
        bcmht= 0.0d0    
        bl95I= 0.0d0
        bl95IT= 0.0d0
        bl95O= 0.0d0
        bl95OT= 0.0d0
        !
        !   label9 is array of headings for file 9 
        !
        label9(1,1) = ' FLOW IN '
        LABEL9(2,1) = LABEL9(1,1)
        LABEL9(3,1) = LABEL9(1,1)
        LABEL9(4,1) = ' FLOW OUT '
        LABEL9(5,1) = LABEL9(4,1)
        LABEL9(6,1) = LABEL9(4,1)
        LABEL9(7,1) = LABEL9(1,1)
        LABEL9(8,1) = LABEL9(1,1)
        LABEL9(9,1) = LABEL9(1,1)
        LABEL9(10,1) = LABEL9(4,1)
        LABEL9(11,1) = LABEL9(4,1)
        LABEL9(12,1) = LABEL9(4,1)
        LABEL9(13,1) = ' TOTAL '
        LABEL9(14,1) = LABEL9(13,1)
        LABEL9(15,1) = LABEL9(13,1)
        LABEL9(16,1) = LABEL9(13,1)
        LABEL9(17,1) = LABEL9(13,1)
        LABEL9(18,1) = LABEL9(13,1)
        LABEL9(19,1) = ' EVAP- '
        LABEL9(20,1) = LABEL9(19,1)
        LABEL9(21,1) = LABEL9(19,1)
        LABEL9(22,1) = ' TRANS- '
        LABEL9(23,1) = LABEL9(22,1)
        LABEL9(24,1) = LABEL9(22,1)
        LABEL9(25,1) = ' EVAP + '
        LABEL9(26,1) = LABEL9(25,1)
        LABEL9(27,1) = LABEL9(25,1)
        LABEL9(28,1) = ' FLUID '
        LABEL9(29,1) = LABEL9(28,1)
        LABEL9(30,1) = LABEL9(28,1)
        LABEL9(31,1) = LABEL9(28,1)
        LABEL9(32,1) = LABEL9(28,1)
        LABEL9(33,1) = LABEL9(28,1)
        LABEL9(34,1) = ' ENERGY IN '
        LABEL9(35,1) = LABEL9(34,1)
        LABEL9(36,1) = LABEL9(34,1)
        LABEL9(37,1) = ' ENERGY OUT'
        LABEL9(38,1) = LABEL9(37,1)
        LABEL9(39,1) = LABEL9(37,1)
        LABEL9(40,1) = LABEL9(34,1)
        LABEL9(41,1) = LABEL9(34,1)
        LABEL9(42,1) = LABEL9(34,1)
        LABEL9(43,1) = LABEL9(37,1)
        LABEL9(44,1) = LABEL9(37,1)
        LABEL9(45,1) = LABEL9(37,1)
        LABEL9(46,1) = ' DISPERSION'
        LABEL9(47,1) = LABEL9(46,1)
        LABEL9(48,1) = LABEL9(46,1)
        LABEL9(49,1) = LABEL9(46,1)
        LABEL9(50,1) = LABEL9(46,1)
        LABEL9(51,1) = LABEL9(46,1)
        LABEL9(52,1) = ' TOTAL '
        LABEL9(53,1) = LABEL9(52,1)
        LABEL9(54,1) = LABEL9(52,1)
        LABEL9(55,1) = LABEL9(52,1)
        LABEL9(56,1) = LABEL9(52,1)
        LABEL9(57,1) = LABEL9(52,1)
        LABEL9(58,1) = ' ENERGY OUT'
        LABEL9(59,1) = LABEL9(58,1)
        LABEL9(60,1) = LABEL9(58,1)
        LABEL9(61,1) = ' ENERGY '
        LABEL9(62,1) = LABEL9(61,1)
        LABEL9(63,1) = LABEL9(61,1)
        LABEL9(64,1) = LABEL9(61,1)
        LABEL9(65,1) = LABEL9(61,1)
        LABEL9(66,1) = LABEL9(61,1)
        LABEL9(67,1) = LABEL9(61,1)
        LABEL9(68,1) = LABEL9(61,1)
        LABEL9(69,1) = LABEL9(61,1)
        LABEL9(70,1) = LABEL9(61,1)
        LABEL9(71,1) = LABEL9(61,1)
        LABEL9(72,1) = LABEL9(61,1)
        !
        LABEL9(1,2) = ' SP HEAD '
        LABEL9(2,2) = LABEL9(1,2)
        LABEL9(3,2) = LABEL9(1,2)
        LABEL9(4,2) = LABEL9(1,2)
        LABEL9(5,2) = LABEL9(1,2)
        LABEL9(6,2) = LABEL9(1,2)
        LABEL9(7,2) = ' SP FLUX '
        LABEL9(8,2) = LABEL9(7,2)
        LABEL9(9,2) = LABEL9(7,2)
        LABEL9(10,2) = LABEL9(7,2)
        LABEL9(11,2) = LABEL9(7,2)
        LABEL9(12,2) = LABEL9(7,2)
        LABEL9(13,2) = ' FLOW IN '
        LABEL9(14,2) = LABEL9(13,2)
        LABEL9(15,2) = LABEL9(13,2)
        LABEL9(16,2) = ' FLOW OUT '
        LABEL9(17,2) = LABEL9(16,2)
        LABEL9(18,2) = LABEL9(16,2)
        LABEL9(19,2) = ' ORATION '
        LABEL9(20,2) = LABEL9(19,2)
        LABEL9(21,2) = LABEL9(19,2)
        LABEL9(22,2) = ' PIRATION '
        LABEL9(23,2) = LABEL9(22,2)
        LABEL9(24,2) = LABEL9(22,2)
        LABEL9(25,2) = ' TRANS '
        LABEL9(26,2) = LABEL9(25,2)
        LABEL9(27,2) = LABEL9(25,2)
        LABEL9(28,2) = ' STORAGE '
        LABEL9(29,2) = LABEL9(28,2)
        LABEL9(30,2) = LABEL9(28,2)
        LABEL9(31,2) = ' VOL BAL '
        LABEL9(32,2) = LABEL9(31,2)
        LABEL9(33,2) = LABEL9(31,2)
        LABEL9(34,2) = LABEL9(1,2)
        LABEL9(35,2) = LABEL9(1,2)
        LABEL9(36,2) = LABEL9(1,2)
        LABEL9(37,2) = LABEL9(1,2)
        LABEL9(38,2) = LABEL9(1,2)
        LABEL9(39,2) = LABEL9(1,2)
        LABEL9(40,2) = LABEL9(7,2)
        LABEL9(41,2) = LABEL9(7,2)
        LABEL9(42,2) = LABEL9(7,2)
        LABEL9(43,2) = LABEL9(7,2)
        LABEL9(44,2) = LABEL9(7,2)
        LABEL9(45,2) = LABEL9(7,2)
        LABEL9(46,2) = ' IN '
        LABEL9(47,2) = LABEL9(46,2)
        LABEL9(48,2) = LABEL9(46,2)
        LABEL9(49,2) = ' OUT '
        LABEL9(50,2) = LABEL9(49,2)
        LABEL9(51,2) = LABEL9(49,2)
        LABEL9(52,2) = LABEL9(34,1)
        LABEL9(53,2) = LABEL9(34,1)
        LABEL9(54,2) = LABEL9(34,1)
        LABEL9(55,2) = LABEL9(37,1)
        LABEL9(56,2) = LABEL9(37,1)
        LABEL9(57,2) = LABEL9(37,1)
        LABEL9(58,2) = ' ET '
        LABEL9(59,2) = LABEL9(58,2)
        LABEL9(60,2) = LABEL9(58,2)
        LABEL9(61,2) = ' DECAY '
        LABEL9(62,2) = LABEL9(61,2)
        LABEL9(63,2) = LABEL9(61,2)
        LABEL9(64,2) = ' ADSORPTION '
        LABEL9(65,2) = LABEL9(64,2)
        LABEL9(66,2) = LABEL9(64,2)
        LABEL9(67,2) = LABEL9(28,2)
        LABEL9(68,2) = LABEL9(28,2)
        LABEL9(69,2) = LABEL9(28,2)
        LABEL9(70,2) = ' BALANCE    '
        LABEL9(71,2) = LABEL9(70,2)
        LABEL9(72,2) = LABEL9(70,2)
        LABEL9(1,3) = ' TOTAL '
        LABEL9(2,3) = ' TIME STEP '
        LABEL9(3,3) = ' RATE '
        DO 771 K3 = 3,69,3
            LABEL9(K3+1,3) = LABEL9(1,3)
            LABEL9(K3+2,3) = LABEL9(2,3)
            LABEL9(K3+3,3) = LABEL9(3,3)
771     CONTINUE
        LABEL9SOL(1,1) = ' SOLUTE IN '
        LABEL9SOL(2,1) = LABEL9SOL(1,1)
        LABEL9SOL(3,1) = LABEL9SOL(1,1)
        LABEL9SOL(4,1) = ' SOLUTE OUT'
        LABEL9SOL(5,1) = LABEL9SOL(4,1)
        LABEL9SOL(6,1) = LABEL9SOL(4,1)
        LABEL9SOL(7,1) = LABEL9SOL(1,1)
        LABEL9SOL(8,1) = LABEL9SOL(1,1)
        LABEL9SOL(9,1) = LABEL9SOL(1,1)
        LABEL9SOL(10,1) = LABEL9SOL(4,1)
        LABEL9SOL(11,1) = LABEL9SOL(4,1)
        LABEL9SOL(12,1) = LABEL9SOL(4,1)
        LABEL9SOL(13,1) = ' DISPERSION'
        LABEL9SOL(14,1) = LABEL9SOL(13,1)
        LABEL9SOL(15,1) = LABEL9SOL(13,1)
        LABEL9SOL(16,1) = LABEL9SOL(13,1)
        LABEL9SOL(17,1) = LABEL9SOL(13,1)
        LABEL9SOL(18,1) = LABEL9SOL(13,1)
        LABEL9SOL(19,1) = ' TOTAL '
        LABEL9SOL(20,1) = LABEL9SOL(19,1)
        LABEL9SOL(21,1) = LABEL9SOL(19,1)
        LABEL9SOL(22,1) = LABEL9SOL(19,1)
        LABEL9SOL(23,1) = LABEL9SOL(19,1)
        LABEL9SOL(24,1) = LABEL9SOL(19,1)
        LABEL9SOL(25,1) = ' SOLUTE OUT'
        LABEL9SOL(26,1) = LABEL9SOL(25,1)
        LABEL9SOL(27,1) = LABEL9SOL(25,1)
        LABEL9SOL(28,1) = ' SOLUTE '
        LABEL9SOL(29,1) = LABEL9SOL(28,1)
        LABEL9SOL(30,1) = LABEL9SOL(28,1)
        LABEL9SOL(31,1) = LABEL9SOL(28,1)
        LABEL9SOL(32,1) = LABEL9SOL(28,1)
        LABEL9SOL(33,1) = LABEL9SOL(28,1)
        LABEL9SOL(34,1) = LABEL9SOL(28,1)
        LABEL9SOL(35,1) = LABEL9SOL(28,1)
        LABEL9SOL(36,1) = LABEL9SOL(28,1)    
        LABEL9SOL(1,2) = LABEL9(1,2)
        LABEL9SOL(2,2) = LABEL9(1,2)
        LABEL9SOL(3,2) = LABEL9(1,2)
        LABEL9SOL(4,2) = LABEL9(1,2)
        LABEL9SOL(5,2) = LABEL9(1,2)
        LABEL9SOL(6,2) = LABEL9(1,2)
        LABEL9SOL(7,2) = LABEL9(7,2)
        LABEL9SOL(8,2) = LABEL9(7,2)
        LABEL9SOL(9,2) = LABEL9(7,2)
        LABEL9SOL(10,2) = LABEL9(7,2)
        LABEL9SOL(11,2) = LABEL9(7,2)
        LABEL9SOL(12,2) = LABEL9(7,2)
        LABEL9SOL(13,2) = ' IN '
        LABEL9SOL(14,2) = LABEL9SOL(13,2)
        LABEL9SOL(15,2) = LABEL9SOL(13,2)
        LABEL9SOL(16,2) = ' OUT '
        LABEL9SOL(17,2) = LABEL9SOL(16,2)
        LABEL9SOL(18,2) = LABEL9SOL(16,2)
        LABEL9SOL(19,2) = LABEL9SOL(1,1)
        LABEL9SOL(20,2) = LABEL9SOL(1,1)
        LABEL9SOL(21,2) = LABEL9SOL(1,1)
        LABEL9SOL(22,2) = LABEL9SOL(4,1)
        LABEL9SOL(23,2) = LABEL9SOL(4,1)
        LABEL9SOL(24,2) = LABEL9SOL(4,1)
        LABEL9SOL(25,2) = ' ET '
        LABEL9SOL(26,2) = LABEL9SOL(25,2)
        LABEL9SOL(27,2) = LABEL9SOL(25,2)
        LABEL9SOL(28,2) = LABEL9(28,2)
        LABEL9SOL(29,2) = LABEL9SOL(28,2)
        LABEL9SOL(30,2) = LABEL9SOL(28,2)
        LABEL9SOL(31,2) = ' BALANCE    '
        LABEL9SOL(32,2) = LABEL9SOL(31,2)
        LABEL9SOL(33,2) = LABEL9SOL(31,2)
        LABEL9SOL(34,2) = ' REACTION '
        LABEL9SOL(35,2) = LABEL9SOL(34,2)
        LABEL9SOL(36,2) = LABEL9SOL(34,2)
        LABEL9SOL(1,3) = ' TOTAL '
        LABEL9SOL(2,3) = ' TIME STEP '
        LABEL9SOL(3,3) = ' RATE '
        DO 772 K3 = 3,33,3
            LABEL9SOL(K3+1,3) = LABEL9SOL(1,3)
            LABEL9SOL(K3+2,3) = LABEL9SOL(2,3)
            LABEL9SOL(K3+3,3) = LABEL9SOL(3,3)
772     CONTINUE      
    END IF
    !
    !   INITIALIZE MASS BALANCE VARIABLES USED FOR CURRENT
    !   TIME STEP
    !
    BLTEMP=0.0D0
    BL(3)=0.0D0
    BL(6)=0.0D0
    BL(9)=0.0D0
    BL(12)=0.0D0
    BL(27)=0.0D0
    BL(29)=0.0D0
    BL(36)=0.0D0
    BL(39)=0.0D0
    BL(42)=0.0D0
    BL(45)=0.0D0
    BL(60)=0.0D0
    BL(62)=0.0D0
    BL(51)=0.0D0
    BL(48)=0.0D0
    BL(69)=0.0D0
    BL(72)=0.0D0
    BL(75)=0.0D0
    BL(78)=0.0D0
    BL(81)=0.0D0
    BL(84)=0.0D0
    BL(92)=0.0D0
    BL(95)=0.0D0
    bcmf = 0.0D0
    bcmh = 0.0D0
    bltemp2 = 0.0D0
    bl29I = 0.0D0
    bl29O = 0.0D0
    bl95I = 0.0D0
    bl95O = 0.0D0
    Do 111 M=1,nsol
        BLSOL(M,3) = 0.0D0
        BLSOL(M,6) = 0.0D0
        BLSOL(M,9) = 0.0D0
        BLSOL(M,12) = 0.0D0
        BLSOL(M,15) = 0.0D0
        BLSOL(M,18) = 0.0D0
        BLSOL(M,27) = 0.0D0
        BLSOL(M,29) = 0.0D0
        BLSOL(M,35) = 0.0D0
        BCMT(M) = 0.0D0
        BL62I(M) = 0.0D0
        BL62O(M) = 0.0D0

111 continue
    if (f7p) then
        do 12 i=1,numBF
            currentBF(i,1) = 0.0d0
            currentBF(i,2) = 0.0d0
            currentBF(i,3) = 0.0d0
12      continue
    end if
    DO 21 J=2,NLYY
        DO 21 N=2,NXRR
            IN=NLY*(N-1)+J
            IF(HX(IN).EQ.0.0D0) GO TO 21
            JM1=IN-1
            JP1=IN+1
            NM1=IN-NLY
            NP1=IN+NLY
            VOL=DXR(N)*DELZ(J)
            IF(RAD)VOL=PI2*RX(N)*DXR(N)*DELZ(J)
            !
            !     SUM CHANGE IN STORAGE
            !
            IF(HEAT)THEN
                GSF=VOL*(THETA(IN)*RHO(IN)-THLST(IN)*RHOOLD(IN))
            ELSE  
                GSF=VOL*(THETA(IN)-THLST(IN))
            END IF
            JJ=JTEX(IN)
            SS=HK(JJ,2)/HK(JJ,3)
            IF(HEAT)THEN
                GSS=VOL*THETA(IN)*SS*RHO(IN) 
            ELSE  
                GSS=VOL*THETA(IN)*SS
            END IF
            bltemp2 = (GSF+GSS*(P(IN)-PXXX(IN)))
            bl(29) = bl(29) + bltemp2
            if(bltemp2.ge.0.0d0) then
                if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))&
                bl29I = bl29I + bltemp2
            else
                if (.not.(ntyp(in).eq.1.and.jflag1.eq.1))&
                bl29O = bl29O + bltemp2
            end if
            if(ntyp(in).eq.1.and.jflag1.eq.1)& 
            bcmf = bcmf + bltemp2

            IF(HEAT) THEN
                !
                !   FOR TRANSPORT SUM CHANGE IN STORAGE AND DIFFUSIVE/DISPERSIVE
                !   FLUXES
                !
                !     IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
                !
                !  CHANGE 8-12-91 FOR STORAGE
                !
                !    *CC(IN)*THETA(IN)*(1+SS*P(IN))-COLD(IN)*THLST(IN)*(1+SS*PXXX(IN)))
                !      bltemp2=VOL*(
                !      IF(NCTYP(IN).NE.1) BL(68)=BL(68)+VOL*(
                !     *CC(IN)*(HT(JJ,5)+THETA(IN)*RHO(IN)*HT(JJ,11)*(2.0d0+
                !     *SS*(P(IN)-PXXX(IN))))-cc(in)*thlst(in)*rho(in)*ht(jj,11)
                !     *-COLD(IN)*(theta(IN)*RHOOLD(IN)*HT(JJ,11)+ht(jj,5)))

                !*****************************
                ! following changes made 7-3-04 to correct way that dctheta/dt is
                ! calculated
                !*****************************
                bltemp2=VOL*( &
                TT(IN)*(HT(JJ,3)+THETA(IN)*RHO(IN)*HT(JJ,6)*(1.0d0+ &
                SS*(P(IN)-PXXX(IN))))-ttold(in)*(thlst(in)*RHO(IN)*ht(jj,6)&
                +ht(jj,3)))
                bl(95) = bl(95) + bltemp2
                if (jflag1.eq.1) then
                    if(ntyp(in).eq.1) bcmh = bcmh + TT(IN)*(theta(in) - thlst(in)) &
                    *RHOOLD(IN)*HT(JJ,6)*vol
                    if(nhtyp(in).eq.1) bcmh = bcmh + (theta(in)*RHOOLD(IN)*HT(JJ,6) &
                    +ht(jj,3))*(TT(IN) - TTOLD(IN))*vol
                end if
                if(bltemp2.ge.0.0D0) then
                    if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nhtyp(in).eq.1))) &
                    bl95I = bl95I + bltemp2
                else
                    if (.not.((jflag1.eq.1).and.(ntyp(in).eq.1.or.nhtyp(in).eq.1))) &
                    bl95O = bl95O + bltemp2
                end if
            END IF
            !
            !
            !   
            IF(SOLUTE) THEN
                DO 20 M=1,Nsol
                    bltemp2=VOL*(&
                    CC(M,IN)*THETA(IN)*(1.0d0+SS*(P(IN)-PXXX(IN)))-ccold(m,in)&
                    *thlst(in))
                    BLSOL(M,29)=BLSOL(M,29)+ bltemp2
                    BLSOL(M,35)= BLSOL(M,35)+ vol*theta(in)*(CC(M,IN)-CCBR(M,IN)) 
                    if (jflag2.eq.1) then
                        if(ntyp(in).eq.1.or.nctyp(in).eq.1) bcmt(M) =bcmt(M) + bltemp2
                        !      if(nctyp(in).eq.1)bcmt(N)=bcmt(N)+(theta(in)*(cc(m,in)- &
                        !       ccold(m,in)))*vol
                    end if
                    if(bltemp2.ge.0.0D0) then
                        if (.not.((jflag2.eq.1).and.(ntyp(in).eq.1.or.nctyp(in)&
                        .eq.1)))  bl62I(M) = bl62I(M) + bltemp2
                    else
                        if (.not.((jflag2.eq.1).and.(ntyp(in).eq.1.or.nctyp(in)&
                        .eq.1)))bl62O(M) = bl62O(M) + bltemp2
                    end if 
20              continue
            end if    
            IF(NHTYP(IN).EQ.2) THEN
                IF(TS(IN).LT.0.0D0) THEN
                    BL(84)=BL(84)+TS(IN)
                ELSE
                    BL(81)=BL(81)+TS(IN)
                END IF
            END IF
            IF(NCTYP(IN).EQ.2) THEN
                do 22 M1=1,Nsol
                    IF(CSS(M1,IN).LT.0.0D0) THEN
                        !      BL(51)=BL(51)+CSS(M1,IN)
                        BLSOL(M1,18)=BLSOL(M1,18)+ CSS(M1,IN)
                    ELSE
                        !      BL(48)=BL(48)+CSS(M1,IN)
                        BLSOL(M1,15)=BLSOL(M1,15)+CSS(M1,IN)
                    END IF
22              CONTINUE
            END IF
            IF(NHTYP(IN).EQ.1) THEN

            IF (CIT) THEN
                T5=A(IN)*(TT(IN)-TT(NM1))+ao(in)*(TTOLD(IN)-TTOLD(NM1))+&
                B(IN)*(TT(IN)-TT(JM1))+bo(in)*(TTOLD(IN)-TTOLD(JM1))+&
                C(IN)*(TT(IN)-TT(NP1))+co(in)*(TTOLD(IN)-TTOLD(NP1))+&
                D(IN)*(TT(IN)-TT(JP1))+do(in)*(TTOLD(IN)-TTOLD(JP1))

                ao(in) = a(in)
                bo(in) = b(in)
                co(in) = c(in)
                do(in) = d(in)

                IF(JFLAG1.EQ.1) THEN
                    AO(IN)=0.5D0*AO(IN)
                    BO(IN)=0.5D0*BO(IN)
                    CO(IN)=0.5D0*CO(IN)
                    DO(IN)=0.5D0*DO(IN)
                    END IF
                ELSE
                    T5=A(IN)*(TT(IN)-TT(NM1))+B(IN)*(TT(IN)-TT(JM1))+&
                    C(IN)*(TT(IN)-TT(NP1))+D(IN)*(TT(IN)-TT(JP1))
                END IF

                if (f7p) then
                    do 14 ib1 = 1,numBF
                        do 14 ib2 = 1,numcellsBF(ib1)
                            if (in.eq.nodenum(ib1,ib2)) then
                                currentBF(ib1,3) = currentBF(ib1,3) + T5
                                go to 13
                            end if
14                  continue
                end if
13              continue
                IF(T5.LT.0.0D0) THEN
                    BL(84)=BL(84)+T5
                ELSE
                    BL(81)=BL(81)+T5
                END IF
                END IF
                IF(NCTYP(IN).EQ.1) THEN
                    DO 23 M=1,Nsol
                        IF (CIT) THEN
                            T6=AS(IN)*(CC(M,IN)-CC(M,NM1))+aoc(in)*(CCOLD(M,IN)-&
                            CCOLD(M,NM1))+BS(IN)*(CC(M,IN)-CC(M,JM1))+boc(in)*(CCOLD(M,IN)-&
                            CCOLD(M,JM1))+CS(IN)*(CC(M,IN)-CC(M,NP1))+coc(in)*(CCOLD(M,IN)&
                            -CCOLD(M,NP1))+DS(IN)*(CC(M,IN)-CC(M,JP1))+doc(in)*(CCOLD(M,IN)&
                            -CCOLD(M,JP1))
                            if(M.EQ.Nsol) then
                                aoc(in) = as(in)
                                boc(in) = bs(in)
                                coc(in) = cs(in)
                                doc(in) = ds(in)
                                IF(JFLAG2.EQ.1) THEN
                                    AOC(IN)=0.5D0*AOC(IN)
                                    BOC(IN)=0.5D0*BOC(IN)
                                    COC(IN)=0.5D0*COC(IN)
                                    DOC(IN)=0.5D0*DOC(IN)          
                                END IF
                            END IF
                        ELSE
                            T6=AS(IN)*(CC(M,IN)-CC(M,NM1))+BS(IN)*(CC(M,IN)-CC(M,JM1))+&
                            CS(IN)*(CC(M,IN)-CC(M,NP1))+DS(IN)*(CC(M,IN)-CC(M,JP1))
                        END IF
                        if (f7p) then
                            do 16 ib1 = 1,numBF
                                do 16 ib2 = 1,numcellsBF(ib1)
                                    if (in.eq.nodenum(ib1,ib2)) then
                                        currentBF(ib1,3) = currentBF(ib1,3) + T6
                                        go to 15
                                    end if
16                          continue
                        end if
15                      continue 
                        IF(T6.LT.0.0D0) THEN
                            !      BL(51)=BL(51)+T6
                            BLSOL(M,18)=BLSOL(M,18)+ T6
                        ELSE
                            !      BL(48)=BL(48)+T6
                            BLSOL(M,15)=BLSOL(M,15)+T6 
                        END IF
23                  continue    
                END IF

                !
                !  FLUX FOR NEUMANN CELLS
                !
                IF(NTYP(IN).EQ.2.or.ntyp(in).eq.7) THEN
                    IF(QQ(IN).LE.0.0D0) THEN
                        IF((HEAT.AND.SOLUTE).OR.HEAT) THEN
                            BL(12)=BL(12)+QQ(IN)*RHO(IN)
                        ELSE  
                            BL(12)=BL(12)+QQ(IN)
                        END IF
                        IF(HEAT) BL(78)=BL(78)+QQ(IN)*TT(IN)*RHO(IN)*HT(JJ,6)
                        IF(SOLUTE)then
                            do 24 M2=1,Nsol  
                                !      BL(45)=BL(45)+QQ(IN)*CC(M2,IN)
                                BLSOL(M2,12)=BLSOL(M2,12)+QQ(IN)*CC(M2,IN)
24                          continue  
                        end if
                    ELSE
                        IF((HEAT.AND.SOLUTE).OR.HEAT) THEN  
                            BL(9)=BL(9)+QQ(IN)*RHO(IN)
                        ELSE
                            BL(9)=BL(9)+QQ(IN)
                        END IF
                        IF(HEAT)BL(75)=BL(75)+QQ(IN)*TS(IN)*RHO(IN)*HT(JJ,6)
                        IF(SOLUTE)THEN
                            do 25 M3=1,Nsol  
                                !      BL(42)=BL(42)+QQ(IN)*CSS(M3,IN)
                                BLSOL(M3,9)=BLSOL(M3,9)+ QQ(IN)*CSS(M3,IN)
                                ! dlp uses css
                                if (CSS(M3,IN) > 1e10) then
                                    stop "Stopping 1"
                                endif   
                                
25                          continue
                        END IF
                    END IF
                ELSE
                    !
                    !  FLUX FOR DIRICHLET CELLS
                    !
                    IF(NTYP(IN).EQ.1) THEN
                        !      IF(TRANS) THEN
                        !      QX=QT(IN)
                        !      ELSE
                        !      QX=VSFLX1(IN)
                        !      END IF
                        if (.not. trans) qt(in) = vsflx1(in)
                        !      qx = qt(in)
                        if(SOLUTE) then
                            qx = qs(in)
                            !qx = vsflx1(in)
                        else
                            qx = qt(in)
                        end if
                        IF(QX.LT.0.0D0) THEN  
                            BL(3)=BL(3)-QX
                            IF(HEAT) BL(69)=BL(69)-QX*TS(IN)*HT(JJ,6)
                            IF(SOLUTE)then
                                do 26 M4=1,Nsol  
                                    !      BL(36)=BL(36)-QX*CSS(M4,IN)
                                    BLSOL(M4,3)=BLSOL(M4,3)-QX*CSS(M4,IN)
                                    ! dlp uses css
                                    if (CSS(M4,IN) > 1e10) then
                                        stop "Stopping 1"
                                    endif   
26                              continue  
                            end if
                        ELSE
                            BL(6)=BL(6)-QX
                            IF(HEAT) BL(72)=BL(72)-QX*TT(IN)*HT(JJ,6)
                            IF(SOLUTE)then
                                do 27 M5=1,Nsol
                                    !      BL(39)=BL(39)-QX*CSS(M5,IN)
                                    BLSOL(M5,6)=BLSOL(M5,6)-QX*CC(M5,IN)
27                              continue  
                            end if
                        END IF
                    ELSE
                        !
                        !    SUM SOURCES AND SINKS
                        !     
                        IF((HEAT.AND.SOLUTE).OR.HEAT) THEN
                            BL(27)=BL(27)+Q(IN)*RHO(IN)
                        ELSE
                            BL(27)=BL(27)+Q(IN)
                        END IF  
                        if(NPV.ge.0) then
                            IF(HEAT.AND.NTYP(IN).NE.5) BL(93)=BL(93)+Q(IN)*TT(IN)*RHO(IN)&
                            *HT(JJ,6)  
                            IF(SOLUTE.AND.NTYP(IN).NE.5)then
                                do 28 M6=1, Nsol
                                    !      BL(60)=BL(60)+Q(IN)*CC(M6,IN)
                                    BLSOL(M6,27)=BLSOL(M6,27)+Q(IN)*CC(M6,IN)
28                              continue    
                            end if
                        end if
                    END IF
                end if
                !      if(cit.and.nctyp(in).ne.1) then
                !      SS=theta(IN)*(P(IN)-PXXX(IN))*HK(JJ,2)/HK(JJ,3)
                !      EO(IN)=E(IN)+VOL*(((THETA(IN)+SS)*RHO(IN)*HT(JJ,6)+&
                !      HT(JJ,3))/DELT)
                !      IF(JFLAG1.EQ.1) EO(IN)=0.5D0*EO(IN)
                !      end if
                !
                !  the following was moved from vtsetup, so that AO, etc
                !   would not be updated until a final solution had been
                !   reached
                !
                if(cit.and.nhtyp(in).ne.1) then
                    AO(IN)=A(IN)
                    BO(IN)=B(IN)
                    CO(IN)=C(IN)
                    DO(IN)=D(IN)
                        SS=theta(IN)*(P(IN)-PXXX(IN))*HK(JJ,2)/HK(JJ,3)
                        !      SS1=HT(JJ,4)*THETA(IN)
                        SS1 = 0.0D0
                        !
                        !******************
                        !  following change made 7-3-04 to correct dctheta/dt 
                        !   calculation - see written notes
                        !
                        !******************
                        !      if(jflag1.ne.1.or.ntyp(IN).ne.1) then
                        !      SS=THETA(IN)+SS-THLST(IN)
                        !      end if
                        !*****************
                        EO(IN)=E(IN)+VOL*(SS1+((THETA(IN)+SS)*RHO(IN)*HT(JJ,6)&
                        +HT(JJ,3))/DELT)
                        IF(JFLAG1.EQ.1) THEN
                            AO(IN)=0.5D0*AO(IN)
                            BO(IN)=0.5D0*BO(IN)
                            CO(IN)=0.5D0*CO(IN)
                            DO(IN)=0.5D0*DO(IN)
                                EO(IN)=0.5D0*EO(IN)
                            end if
                        end if
21  CONTINUE
    !
    !   ACCUMULATE VALUES FOR TOTAL ELAPSED SIMULATION TIME
    !
    if (cit) then
        if(jflag1.eq.1) then
            bltemp69 = bl(69)
            bltemp72 = bl(72)
            bltemp75 = bl(75)
            bltemp78 = bl(78)
            bltemp91 = bl(91)
        else
            bltemp1 = 0.5d0*(bl(69)+bltemp69)
            bltemp69 = bl(69)
            bl(69) = bltemp1
            bltemp1 = 0.5d0*(bl(72)+bltemp72)
            bltemp72 = bl(72)
            bl(72) = bltemp1
            bltemp1 = 0.5d0*(bl(75)+bltemp75)
            bltemp75 = bl(75)
            bl(75) = bltemp1
            bltemp1 = 0.5d0*(bl(78)+bltemp78)
            bltemp78 = bl(78)
            bl(78) = bltemp1
            bltemp1 = 0.5d0*(bl(91)+bltemp91)
            bltemp91 = bl(91)
            bl(91) = bltemp1
        end if
        IF (SOLUTE) THEN
            do 30 N=1,Nsol
                if(JFLAG2.eq.1) then
                    bltemp36(N) = BLSOL(N,3)
                    bltemp39(N) = BLSOL(N,6)
                    bltemp42(N) = BLSOL(N,9)
                    bltemp45(N) = BLSOL(N,12)
                    bltemp60(N) = BLSOL(N,27)
                else
                    bltemp1 = 0.5d0*(BLSOL(N,3)+bltemp36(N))
                    bltemp36(N) = BLSOL(N,3)
                    BLSOL(N,3) = bltemp1
                    bltemp1 = 0.5d0*(BLSOL(N,6)+bltemp39(N))
                    bltemp39(N) = BLSOL(N,6)
                    BLSOL(N,6) = bltemp1
                    bltemp1 = 0.5d0*(BLSOL(N,9)+bltemp42(N))
                    bltemp42(N) = BLSOL(N,9)
                    BLSOL(N,9) = bltemp1
                    bltemp1 = 0.5d0*(BLSOL(N,12)+bltemp45(N))
                    bltemp45(N) = BLSOL(N,12)
                    BLSOL(N,12) = bltemp1
                    bltemp1 = 0.5d0*(BLSOL(N,27)+bltemp60(N))
                    bltemp60(N) = BLSOL(N,27)
                    BLSOL(N,27) = bltemp1
                end if
30          continue
        END IF
    end if
    BL(24)=ETOUT
    BL(21)=ETOUT1
    BL(30)=BL(29)/DELT
    BL(15)=BL(3)+BL(9)
    BL(18)=BL(6)+BL(12)
    DO 31 I=2,26,3
        BL(I)=DELT*BL(I+1)
31  CONTINUE
    BL(19)=BL(19)+BL(20)
    BL(22)=BL(22)+BL(23)
    BL(1)=BL(1)+BL(2)
    BL(4)=BL(4)+BL(5)
    BL(10)=BL(10)+BL(11)
    BL(13)=BL(13)+BL(14)
    BL(7)=BL(7)+BL(8)
    BL(16)=BL(16)+BL(17)
    BL(25)=BL(25)+BL(26)
    BL(28)=BL(28)+BL(29)
    BL(32)=BL(14)+BL(17)+BL(26)-BL(29) + bcmf
    BL(33)=BL(32)/DELT
    BL(31)=BL(31)+BL(32)
    bcmft = bcmft + bcmf
    bcmfr = bcmf/delt
    bl29IT = bl29IT + bl29I
    bl29OT = bl29OT + bl29O
    IF(HEAT) THEN
        !
        !   TRANSPORT MASS BALANCE COMPONENTS
        !
        !     BL(94)=BL(94)+BL(95)
        BL(96)=BL(95)/DELT
        BL(87)=BL(69)+BL(75)+BL(81)
        BL(90)=BL(72)+BL(78)+BL(84)
        DO 40 I=68,92,3
            BL(I)=DELT*BL(I+1)
40      CONTINUE
        BL(82)=BL(82)+BL(83)
        BL(79)=BL(79)+BL(80)
        BL(91)=BL(91)+BL(92)
        BL(94)=BL(94)+BL(95)
        BL(70)=BL(70)+BL(71)
        BL(67)=BL(67)+BL(68)
        BL(76)=BL(76)+BL(77)
        BL(85)=BL(85)+BL(86)
        BL(73)=BL(73)+BL(74)
        BL(88)=BL(88)+BL(89)
        BL(98)=BL(86)+BL(89)+BL(92)-BL(95)+ bcmh
        BL(99)=BL(98)/DELT
        BL(97)=BL(97)+BL(98)
        bcmht = bcmht + bcmh
        bcmhr = bcmh/delt
        bl95IT = bl95IT + bl95I
        bl95OT = bl95OT + bl95O
        bl95T = bl95T
    END IF
    IF(SOLUTE) THEN
        !
        !   TRANSPORT MASS BALANCE COMPONENTS
        !
        do 50 N=1,Nsol
            BLSOL(N,28)=BLSOL(N,28)+BLSOL(N,29)
            BLSOL(N,30)=BLSOL(N,29)/DELT
            BLSOL(N,21)=BLSOL(N,3)+BLSOL(N,9)+BLSOL(N,15)
            BLSOL(N,24)=BLSOL(N,6)+BLSOL(N,12)+BLSOL(N,18)
            DO 41 I=2,26,3
                BLSOL(N,I)=DELT*BLSOL(N,I+1)
41          CONTINUE
            BLSOL(N,16)=BLSOL(N,16)+BLSOL(N,17)
            BLSOL(N,13)=BLSOL(N,13)+BLSOL(N,14)
            BLSOL(N,25)=BLSOL(N,25)+BLSOL(N,26)
            BLSOL(N,1)=BLSOL(N,1)+BLSOL(N,2)
            BLSOL(N,4)=BLSOL(N,4)+BLSOL(N,5)
            BLSOL(N,10)=BLSOL(N,10)+BLSOL(N,11)
            BLSOL(N,19)=BLSOL(N,19)+BLSOL(N,20)
            BLSOL(N,7)=BLSOL(N,7)+BLSOL(N,8)
            BLSOL(N,22)=BLSOL(N,22)+BLSOL(N,23)
            BLSOL(N,32)=BLSOL(N,20)+BLSOL(N,23)+BLSOL(N,26) &
            -BLSOL(N,29)+ BLSOL(N,35) + bcmt(N)
            BLSOL(N,33)=BLSOL(N,32)/DELT
            BLSOL(N,31)=BLSOL(N,31)+BLSOL(N,32)
            BLSOL(N,36)=BLSOL(N,35)/DELT
            BLSOL(N,34)=BLSOL(N,34)+BLSOL(N,35)
            bcmtt(N) = bcmtt(N) + bcmt(N)
            bcmtr(N) = bcmt(N)/delt
            bl62IT (N)= bl62IT(N) + bl62I(N)
            bl62OT (N)= bl62OT (N)+ bl62O(N)
50      continue     
    END IF
    !
    !   WRITE RESULTS TO FILE 9
    !
    !      IF(F9P) then
    !       if(ktim.eq.1) then
    !        if(o13p) then
    !         write(09,4002) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
    !         write(09,4002) '      ',(label9(mb9(im),2), im=1,nmb9)
    !         write(09,4002) '      ',(label9(mb9(im),3), im=1,nmb9)
    !        else
    !         write(09,4001) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
    !         write(09,4001) '      ',(label9(mb9(im),2), im=1,nmb9)
    !         write(09,4001) '      ',(label9(mb9(im),3), im=1,nmb9)
    !        end if
    !       end if
    !       if(.not.o9p.or.jplt.eq.1) then
    !        do 42 IM = 1,NMB9
    !         if(dabs(BL(MB9(IM))).lt.elimit1) then
    !          dum(IM) = elimit2
    !         else
    !          dum(IM) = BL(MB9(IM))
    !         end if
    ! 42      continue
    !        if(o13p) then
    !         WRITE(09,4003) STIM,(BL(MB9(IM)),IM=1,NMB9)
    !         WRITE(09,4003) STIM,(dum(IM),IM=1,NMB9)
    !        else
    !         WRITE(09,4000) STIM,(dum(IM),IM=1,NMB9)
    !         WRITE(09,4000) STIM,(BL(MB9(IM)),IM=1,NMB9)
    !        end if
    !       end if
    !      end if
    !
    !   revision May 2016 for output to mass balance summary file 9
    !
    IF(F9P) then
        if(ktim.eq.1) then
            j91 = 0
            j92 = 0
            j93 = 0
            j94 = 0
            do i = 1, nmb9
                i1 = mb9(i)
                if (i1.lt.34) then
                    j91 = j91 + 1
                    indexBL(j91) = i1
                    j93 = j93 + 1
                    indexFLOW(j93) = i1
                else
                    if (HEAT) then
                        if (i1.lt.61) then
                            j91 = j91 + 1
                            indexBL(j91) = i1 + 33
                        else
                            if (i1.gt.66) then
                                j91 = j91 + 1
                                indexBL(j91) = i1 + 27
                            end if
                        end if
                        j94 = j94 + 1 
                        indexHT(j94) = i1           
                    end if
                    if (SOLUTE) then
                        j92 = j92 + 1
                        if(i1.lt.61) then
                            indexBLSOL(j92) = i1 - 33
                        else
                            if (i1.gt.66) then
                                indexBLSOL(j92) = i1 -39
                            end if
                        end if
                    end if
                end if
            end do
            !
            !           WRITE LABELS
            !
            if (.not.SOLUTE) then
                if (o13p) then
                    write(09,4002) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
                    write(09,4002) '      ',(label9(mb9(im),2), im=1,nmb9)
                    write(09,4002) '      ',(label9(mb9(im),3), im=1,nmb9)
                    write(09,4002) '      '
                else
                    write(09,4001) ' TIME ',(label9(mb9(im),1), im=1,nmb9)
                    write(09,4001) '      ',(label9(mb9(im),2), im=1,nmb9)
                    write(09,4001) '      ',(label9(mb9(im),3), im=1,nmb9)
                    write(09,4001) '      '
                end if
            else
                if (O13p) then
                    write(09,4004) ' TIME ',(label9(indexFLOW(im),1), im=1,j93), &
                    (label9(indexHT(im),1), im=1,j94), &
                    ((label9SOL(im3,1), im3=34,36),(label9SOL(indexBLSOL(im2),1)&
                    , im2=1,j92), im1=1,nsol)
                    write(09,4004) '      ',(label9(indexFLOW(im),2), im=1,j93), &
                    (label9(indexHT(im),2), im=1,j94), &
                    ((label9SOL(im3,2), im3=34,36),(label9SOL(indexBLSOL(im2),2)&
                    , im2=1,j92), im1=1,nsol)
                    write(09,4004) '      ',(label9(indexFLOW(im),3), im=1,j93), &
                    (label9(indexHT(im),3), im=1,j94), &
                    ((label9SOL(im3,3), im3=34,36),(label9SOL(indexBLSOL(im2),3)&
                    , im2=1,j92), im1=1,nsol)
                    write(09,4004) '      ',(' ', im=1,j91), ((COMPNAME(im1),&
                    im2=1,j92+3),im1=1,nsol)
                else
                    write(09,4001) ' TIME ',(label9(indexFLOW(im),1), im=1,j93), &
                    (label9(indexHT(im),1), im=1,j94), &
                    ((label9SOL(im3,1), im3=34,36),(label9SOL(indexBLSOL(im2),1),&
                    im2=1,j92), im1=1,nsol)
                    write(09,4001) '      ',(label9(indexFLOW(im),2), im=1,j93), &
                    (label9(indexHT(im),2), im=1,j94), &
                    ((label9SOL(im3,2), im3=34,36),(label9SOL(indexBLSOL(im2),2),&
                    im2=1,j92), im1=1,nsol)
                    write(09,4001) '      ',(label9(indexFLOW(im),3), im=1,j93), &
                    (label9(indexHT(im),3), im=1,j94), &
                    ((label9SOL(im3,3), im3=34,36),(label9SOL(indexBLSOL(im2),3),&
                    im2=1,j92), im1=1,nsol)
                    write(09,4001) '      ',(' ', im=1,j91), ((COMPNAME(im1),&
                    im2=1,j92+3),im1=1,nsol)
                end if
            end if
        end if
        if(.not.o9p.or.jplt.eq.1) then
            do 42 IM = 1,j91
                if(dabs(BL(indexBL(IM))).lt.elimit1) then
                    dum(IM) = elimit2
                else
                    dum(IM) = BL(indexBL(IM))
                end if
42          continue
            IF (SOLUTE) then
                do 43 im1 = 1,nsol
                    do 43 IM = 1,j92
                        if(dabs(BLSOL(im1,indexBLSOL(IM))).lt.elimit1) then
                            BLSOL(im1,indexBLSOL(IM)) = elimit2
                        end if
43              continue
            end if
            if(o13p) then
                if (.not.SOLUTE) then
                    WRITE(09,4003) STIM,(dum(IM),IM=1,j91)
                else
                    WRITE(09,4003) STIM,(dum(IM),IM=1,j91), &
                    ((BLSOL(im1,im3),im3=34,36),  &
                    (BLSOL(im1,indexBLSOL(im2)),im2=1,j92),im1=1,nsol)
                end if
            else
                if (.not.SOLUTE) then
                    WRITE(09,4000) STIM,(dum(IM),IM=1,j91)
                else
                    WRITE(09,4000) STIM,(dum(IM),IM=1,j91), &
                    ((BLSOL(im1,im3),im3=34,36),  &
                    (BLSOL(im1,indexBLSOL(im2)),im2=1,j92),im1=1,nsol)
                end if       
            end if
        end if   
    end if        
    !
    !  revision Aug 2008 to print boundary segment fluxes
    !
    if(f7p) then
        if (ktim.eq.1) then
            if (o13p) then
                write (7,4014)
            else
                write (7,4011)
            end if
        end if
        do 46 ib1 = 1,numBF
            iflag7 = 0
            do 45 ib2 = 1,numcellsBF(ib1)
                in1 = nodenum(ib1,ib2)
                if(ntyp(in1).eq.1) then
                    iflag7 = 1
                    !          qx = qt(in1)
                    if(SOLUTE) then
                        qx = qs(in1)
                        !qx = vsflx1(in1)
                    else
                        qx = qt(in1)
                    end if
                    currentBF(ib1,1) = currentBF(ib1,1) - qx
                    if (HEAT) then
                        if (qt(in1).lt.0.0) then
                            currentBF(ib1,2) = currentBF(ib1,2) - qx*TS(in1)
                        else
                            currentBF(ib1,2) = currentBF(ib1,2) - qx*TT(in1)
                        end if
                    end if
                else
                    if (ntyp(in1).eq.2.or.ntyp(in1).eq.7) then
                        iflag7 = 1
                        currentBF(ib1,1) = currentBF(ib1,1) + qq(in1)
                        if (HEAT) then
                            if (qq(in1).lt.0.0) then
                                currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*TT(in1)
                            else
                                currentBF(ib1,2) = currentBF(ib1,2) + qq(in1)*TS(in1)
                            end if
                        end if
                    end if
                end if
45          continue
            bl_flux = currentBF(ib1,1)*delt
            totalBF(ib1,1) = totalBF(ib1,1) + bl_flux
            if(nctyp(in1).eq.1.or.nctyp(in1).eq.2) iflag7 = 1
            !
            !  revision 10-15-10 for centered in time
            !
            if (CIT) then
                if (jflag1.eq.1) then
                    bl_mass = currentBF(ib1,2)
                    currentBF(ib1,4) = bl_mass
                    bl_mass = bl_mass + currentBF(ib1,3)
                else
                    bltemp1 = currentBF(ib1,2)
                    bl_mass = 0.5*(bltemp1 + currentBF(ib1,4)) + currentBF(ib1,3)
                    currentBF(ib1,4) = bltemp1
                end if
            else
                bl_mass = currentBF(ib1,2) + currentBF(ib1,3)
            end if
            bltemp1 = bl_mass*delt
            totalBF(ib1,2) = totalBF(ib1,2) + bltemp1
            !
            !  end revision 10-15-10
            !
            !       bl_mass = currentBF(ib1,2)*delt
            !        totalBF(ib1,2) = totalBF(ib1,2) + bl_mass
            if((iflag7.eq.1).and.(.not.o9p.or.jplt.eq.1)) then
                if(dabs(totalBF(ib1,1)).lt.elimit1)totalBF(ib1,1)=elimit2
                if(dabs(bl_flux).lt.elimit1) bl_flux = elimit2
                if(dabs(currentBF(ib1,1)).lt.elimit1)currentBF(ib1,1)=elimit2
                if(dabs(bltemp1).lt.elimit1)bltemp1 = elimit2
                if(dabs(bl_mass).lt.elimit1) bl_mass = elimit2
                if(dabs(totalBF(ib1,2)).lt.elimit1)totalBF(ib1,2)=elimit2
                if (o13p) then
                    write(7,4013) stim,idBF(ib1),totalBF(ib1,1),bl_flux, &
                    currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
                else
                    write(7,4012) stim,idBF(ib1),totalBF(ib1,1),bl_flux, &
                    currentBF(ib1,1),totalBF(ib1,2),bltemp1,bl_mass
                end if   
            end if
46      continue
    end if
    !
    !  end Aug 2008 revision
    !
    IF(.NOT.F6P.AND.JPLT.NE.1.AND.JSTOP.NE.1.AND.JFLAG.NE.1) GO TO 51
    !
    !    WRITE RESULTS OF MASS BALANCE TO FILE 6
    !
    do 47 m = 13,72
        if(dabs(bl(m)).lt.elimit1) bl(m) = elimit2
47  continue
    WRITE (06,4010) KTIM,KP,STIM,TUNIT,ZUNIT,ZUNIT,ZUNIT,TUNIT,(BL(M),&
    M=1,12)
    WRITE(06,4020) (BL(M),M=13,27),bcmft,bcmf,bcmfr,(bl(m),m=28,33)
    IF(HEAT) WRITE(06,4030) HUNX,HUNX,HUNX,TUNIT,(BL(M),M=67,93),&
    bcmht,bcmh,bcmhr,(BL(M), M=94,99)
    IF(SOLUTE)THEN
        DO 230 N=1,Nsol
            SCOMPNAME(N)=COMPNAME(N)
            WRITE(06,4031)SCOMPNAME(N)
            WRITE(06,4032) CUNX,CUNX,CUNX,TUNIT,(BLSOL(N,I),I=1,27),&
            (BLSOL(N,I),I=34,36),bcmtt(N),bcmt(N),bcmtr(N), &
            (BLSOL(N,I),I=28,33)  
230     CONTINUE       
    END IF  
    WRITE(06,4040)
51  CONTINUE
    jflag1 = jflag
    jflag2 = jflag
    RETURN
4000 FORMAT(1pe14.6,7300(1PE11.3))
4003 FORMAT(1pe18.10,7300(1PE21.13))
4001 format(a14,1X,7300a11)
4002 format(a18,1X,7300a21)
4004 format(a18,1X,7300(a11,10x))
4010 FORMAT(21X,10(1H-),1X,'MASS BALANCE SUMMARY FOR TIME STEP', &
    I9,1X,10(1H-)/25X,'RECHARGE PERIOD NUMBER ',I9/25X, &
    'TOTAL ELAPSED SIMULATION TIME = ',1PE14.6,1X,A4 &
    //2X,128('+')/2X,'+',126X,'+'/ &
2   X,'+',90X,' TOTAL THIS',10X,'RATE THIS',6X,'+'/2X,'+', &
33  X,'VOLUMETRIC FLOW BALANCE', &
18  X,'TOTAL   ',9X,'TIME STEP',11X,' TIME STEP',5X,'+'/ &
2   X,'+',72X,A4,'**3',13X,A4,'**3',11X,A4,'**3/',A4,4X,'+'/ &
2   X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES', &
1   X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',11X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+')
4011 FORMAT('     TIME      BNDY    WATER      WATER      WATER', &
    '      SOLUTE     SOLUTE     SOLUTE'/,15X,'FACE     FLUX', &
    '       FLUX       FLUX       FLUX       FLUX       FLUX',/ &
23  X,'TOTAL      TIME STEP   RATE      TOTAL      TIME STEP', &
    '   RATE')
4012 FORMAT(1pe14.6,i6,73(1PE11.3))
4013 FORMAT(1pe18.10,i6,73(1PE21.13))
4014 FORMAT(5x,'TIME',11x,'BNDY',4x,3('WATER',16x),1x,3('HEAT',17x),/ &
20  x,'FACE',5x,6('FLUX',17x),/,28x,2('TOTAL',16x,'TIME STEP',13x,'RATE',16x))
4020 FORMAT(1H ,1X,'+',40X,'TOTAL FLUX INTO DOMAIN --  ',2(1PE15.5,5X), &
1   PE15.5,4X,'+'/2X,'+',38X,'TOTAL FLUX OUT OF DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',51X,'EVAPORATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &  
2   X,'+',49X,'TRANSPIRATION --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/  &
2   X,'+',38X,'TOTAL EVAPOTRANSPIRATION', &
1   X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',30X,'      FLUID FROM BOUNDARY CHANGE --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',30X,'CHANGE IN FLUID STORED IN DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',42X,'FLUID VOLUME BALANCE' &
    ,1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',126X,'+')
4030 FORMAT(2X,'+',126X,'+',/,2X,'+',35X,'ENERGY MASS BALANCE', &
72  X,'+',/,2X,'+',74X,A4,16X,A4,14X,A4,'/',A4,5X,'+',/, &
2   X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', & 
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES', &
1   X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',11X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ , &
2   X,'+',25X,'          CONDUCTIVE FLUX INTO DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/2X, &
    '+',23X,'          CONDUCTIVE FLUX OUT OF DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/, &
1   H ,1X,'+',40X,'TOTAL FLUX INTO DOMAIN --  ',2(1PE15.5,5X), &
1   PE15.5,4X,'+'/2X,'+',38X,'TOTAL FLUX OUT OF DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',38X,'TOTAL EVAPOTRANSPIRATION', &
1   X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
    '  +',35X,'ENERGY FROM BOUNDARY CHANGE', &
    ' --',1PE17.5,2(1PE20.5),4X,'+'/ &
2   X,'+',29X,'CHANGE IN ENERGY STORED IN DOMAIN --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',43X,'ENERGY MASS BALANCE' &
    ,1X,'--  ',2(1PE15.5,5X),1PE15.5,4X,'+'/2X,'+',126X,'+') 
4031 FORMAT(A10)       
4032 FORMAT(2X,'+',126X,'+',/,2X,'+',35X,'SOLUTE MASS BALANCE', & 
72  X,'+',/,2X,'+',74X,A4,16X,A4,14X,A4,'/',A4,5X,'+',/, &
2   X,'+',4X,'FLUX INTO DOMAIN ACROSS SPECIFIED PRESSURE HEAD', &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   X,'+',2X,'FLUX OUT OF DOMAIN ACROSS SPECIFIED PRESSURE HEAD' &
1   X,'BOUNDARIES --  ',2(1PE15.5,5X),1PE15.5,4X,'+'/ &
2   x,'+',13X,'FLUX INTO DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --' &
    ,'  ', &
2   (1PE15.5,5X),1PE15.5,4x,'+',/,2X,'+',11X, &
    'FLUX OUT OF DOMAIN ACROSS SPECIFIED FLUX BOUNDARIES --  ', &
2   (1PE15.5,5X),1PE15.5,4X,'+'/,2X,'+',25X, &
    'DIFFUSIVE/DISPERSIVE FLUX INTO DOMAIN --  ',2(1PE15.5,5X),1PE15.5 &
    ,4X,'+'/2X,'+',23X,'DIFFUSIVE/DISPERSIVE FLUX OUT OF DOMAIN --', &
1   PE17.5,2(1PE20.5),4X,'+'/'  +',40X,'TOTAL FLUX INTO DOMAIN --', & 
1   PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL FLUX OUT OF DOMAIN --', &
1   PE17.5,2(1PE20.5),4X,'+'/'  +',38X,'TOTAL EVAPOTRANSPIRATION --', &
1   PE17.5,2(1PE20.5),4X,'+'/'  +',21X,'CHANGE IN SOLUTE DUE TO', &
1   x,'CHEMICAL REACTION --', &
1   PE17.5,2(1PE20.5),4X,'+'/'  +',35X,'SOLUTE FROM BOUNDARY CHANGE', &
    ' --',1PE17.5,2(1PE20.5),4X,'+'/ &
    '  +',29X,'CHANGE IN SOLUTE STORED IN', &
    ' DOMAIN --',1PE17.5,2(1PE20.5),4X,'+'/'  +',43X, &
    'SOLUTE MASS BALANCE --',1PE17.5,2(1PE20.5),4X,'+'/'  +',126X,'+')
4040 FORMAT( 2X,128('+'))
    END
    DOUBLE PRECISION FUNCTION VSFLX1(IN)
    !******
    !VSFLX1
    !******
    !   PURPOSE: TO COMPUTE INTERCELL MASS FLUX RATES FOR DIRICHLET
    !   BOUNDARY NODES
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use kcon
    use press
    use hcon
    use equat
    use temp
    use pit
    use isdumm
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/WGT/WUS,WDS
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    !----------------------------------------------------------------------
    !
    !
    !   COMPUTE FLUXES ON ALL FOUR SIDES OF EACH CONSTANT HEAD NODE
    !
    JM1=IN-1
    JP1=IN+1
    NP1=IN+NLY
    NM1=IN-NLY
    !
    !   COMPUTE A,B,C,D
    !
    IF(WUS.EQ.0.0D0) THEN
        IF(HEAT)THEN
            A1=HKLL(IN)*DSQRT(HCND(NM1)*RHO(NM1)*HCND(IN)*RHO(IN))
            B1=HKTT(IN)*DSQRT(HCND(JM1)*RHO(JM1)*HCND(IN)*RHO(IN))
            C1=HKLL(NP1)*DSQRT(HCND(NP1)*RHO(NP1)*HCND(IN)*RHO(IN))
            D1=HKTT(JP1)*DSQRT(HCND(JP1)*RHO(JP1)*HCND(IN)*RHO(IN))
        ELSE  
            A1=HKLL(IN)*DSQRT(HCND(NM1)*HCND(IN))
            B1=HKTT(IN)*DSQRT(HCND(JM1)*HCND(IN))
            C1=HKLL(NP1)*DSQRT(HCND(NP1)*HCND(IN))
            D1=HKTT(JP1)*DSQRT(HCND(JP1)*HCND(IN))
        END IF
    ELSE
        IF(P(NM1).GT.P(IN).AND.HX(NM1).NE.0.0D0) THEN
            ALA=WUS
            BTA=WDS
        ELSE
            ALA=WDS
            BTA=WUS
        END IF
        IF(P(JM1).GT.P(IN).AND.HX(JM1).NE.0.0D0) THEN
            ALB=WUS
            BTB=WDS
        ELSE
            ALB=WDS
            BTB=WUS
        END IF
        IF(P(NP1).GT.P(IN).AND.HX(NP1).NE.0.0D0) THEN
            ALC=WUS
            BTC=WDS
        ELSE
            ALC=WDS
            BTC=WUS
        END IF
        IF(P(JP1).GT.P(IN).AND.HX(JP1).NE.0.0D0) THEN
            ALD=WUS
            BTD=WDS
        ELSE
            ALD=WDS
            BTD=WUS
        END IF

        !
        !   DETERMINE FLUXES
        !     
        IF(HEAT)THEN
            A1=(ALA*HCND(NM1)*RHO(NM1)+BTA*HCND(IN)*RHO(IN))*HKLL(IN)
            B1=(ALB*HCND(JM1)*RHO(JM1)+BTB*HCND(IN)*RHO(IN))*HKTT(IN)
            C1=(ALC*HCND(NP1)*RHO(NP1)+BTC*HCND(IN)*RHO(IN))*HKLL(NP1)
            D1=(ALD*HCND(JP1)*RHO(JP1)+BTD*HCND(IN)*RHO(IN))*HKTT(JP1)
        ELSE  
            A1=(ALA*HCND(NM1)+BTA*HCND(IN))*HKLL(IN)
            B1=(ALB*HCND(JM1)+BTB*HCND(IN))*HKTT(IN)
            C1=(ALC*HCND(NP1)+BTC*HCND(IN))*HKLL(NP1)
            D1=(ALD*HCND(JP1)+BTD*HCND(IN))*HKTT(JP1)
        END IF
    END IF

    if(ntyp(in).eq.1) then
        if(ntyp(nm1).eq.1) a1 = 0.0d0
        if(ntyp(jm1).eq.1) b1 = 0.0d0
        if(ntyp(np1).eq.1) c1 = 0.0d0
        if(ntyp(jp1).eq.1) d1 = 0.0d0
    end if
    QL=-A1*(P(IN)-P(NM1))
    QA=-B1*(P(IN)-P(JM1))
    QR=-C1*(P(IN)-P(NP1))
    QB=-D1*(P(IN)-P(JP1))
    !
    !    COMPUTE NET FLUX IN (+) OR OUT (-)
    !
    VSFLX1=QL+QR+QA+QB
    RETURN
    END FUNCTION VSFLX1
    SUBROUTINE VSOUTP
    !*****
    !VSOUTP
    !******
    !
    !   PURPOSE: TO OUTPUT RESULTS AFTER EACH TIME STEP.
    !
    !-----------------------------------------------------------------------
    !
    !        SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use mprop
    use press
    use jtxx
    use dumm
    use dumm3
    use trxx
    use trxxh
    use trxv
    use plott
    use rpropsh
    use scon
    use disch
    use PRICON
    use vs2dt_rm
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/JCON/JSTOP,JFLAG,jflag1
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX
    common/elimit/elimit1,elimit2
    LOGICAL HEAT,SOLUTE
    COMMON/TRANSTYPE/HEAT,SOLUTE
    COMMON/TCON1/NIS,NIS1,NIS3
    integer :: io11p
    !-------------------------------------------------------------------
    !
    !   OUTPUT RESULTS TO FILE 11 AT EACH TIME STEP
    !
    IF(JSTOP.GT.1) RETURN
    if(.not.o11p.or.jplt.eq.1) then
        IF(F11P) THEN
            IF(.not.(TRANS.OR.VPNT).AND..NOT.SSTATE) CALL VTVELO

            DO 10 J=1,NOBS
                N=IJOBS(J)
                NPRCHOBS(N)=1
                I=N/NLY+1
                J1=MOD(N,NLY)
                IF(HX(N).NE.0.0D0) THEN
                    if(dabs(p(n)).lt.elimit1) p(n) = elimit2
                    IF(HEAT)THEN
                        if(dabs(TT(n)).lt.elimit1) TT(n) = elimit2
                    END IF
                    IF(SOLUTE)THEN
                        DO 11 M=1,Nsol
                            if(dabs(cc(M,n)).lt.elimit1) cc(M,n) = elimit2  
11                      continue          
                    END IF  
                    if(dabs(vx(n)).lt.elimit1) vx(n) = elimit2
                    if(dabs(vz(n)).lt.elimit1) vz(n) = elimit2
                    if(dabs(q(n)).lt.elimit1) q(n) = elimit2
                    PPR=HK(JTEX(N),3)
                    IF(PPR.EQ.0.0D0)PPR=1.0D0
                    SAT=THETA(N)/PPR
                    IF(CS1.EQ.1.0D0) THEN
                        Z1=DZZ(J1)
                    ELSE
                        Z1=DZZ(J1)*CS1+RX(I)*CS2
                    END IF
                    PHD=P(N)+Z1
                    if (o13p) then
                        IF(HEAT.AND.SOLUTE) THEN
                            WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
                            vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
                        else if(HEAT.AND.(.NOT.SOLUTE))then 
                            WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
                            vx(n),vz(n),q(n)
                        else if((.NOT.HEAT).AND.SOLUTE)then  
                            WRITE(11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
                            vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
                        ELSE
                            WRITE (11,4021) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
                            vx(n),vz(n),q(n)
                        END IF
                    else
                        IF(HEAT.AND.SOLUTE) THEN
                            WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
                            vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
                        else if(HEAT.AND.(.NOT.SOLUTE))then 
                            WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT,TT(N), &
                            vx(n),vz(n),q(n)
                        else if((.NOT.HEAT).AND.SOLUTE)then 
                            WRITE(11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
                            vx(n),vz(n),q(n),(CC(M,N),M=1,Nsol)
                        ELSE
                            WRITE (11,4020) STIM,n,RX(I),DZZ(J1),P(N),PHD,THETA(N),SAT, &
                            vx(n),vz(n),q(n)
                        END IF
                    end if
                END IF
10          CONTINUE
        end if
    END IF
    IF(KTIM.EQ.0)  GO TO 20
    !
    !    WRITE TIME STEP HEADER TO FILE 6
    !
    !    WRITE MAXIMUM HEAD CHANGE EACH TIME STEP TO FILE 7
    !
    !      IF(F7P) THEN
    !      WRITE(07,4040) KTIM,STIM,NIT,NIT1,NIS1
    !     WRITE(07,4030) (DHMX(M2),M2=1,NIT)
    !      END IF
    WRITE(06,4040) KTIM,STIM,NIT,NIT1,NIT3,NIS1
    IF(JSTOP.EQ.1.OR.JPLT.EQ.1) GO TO 20
    IF(.NOT.PRNT.AND.JFLAG.EQ.0) RETURN
20  WRITE (6,4050) TITL,STIM,TUNIT,KTIM
    !
    !    PRINT SOLUTION FOR CURRENT TIME STEP
    !
    IF(JPLT.EQ.1) THEN
        !     if (f8p) then
        !
        !   WRITE PRESSURE HEADS TO FILE 8 AT OBSERVATION TIMES.
        !
        WRITE (8,4000) STIM,TUNIT
        !       if (o12p) then
        !      if (heat.and.solute) then
        !       write (12) stim, p, tt,cc
        !      else if(heat.and.(.not.solute))then
        !      write (12) stim, p, tt
        !      else if((.not.heat).and.solute)then
        !        write (12) stim, p,cc
        !     else
        !      write (12) stim, p
        !     end if
        !     end if 
        DO 40 J=1,NLY
            DO 30 N=1,NXR
                IN=NLY*(N-1)+J
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(N)*CS2
                END IF
                DUM(IN)=P(IN)+Z1
                if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
30          continue
            if(o13p) then
                WRITE(8,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
            else
                WRITE(8,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
            end if
40      continue
        !
        !  WRITE TEMPERATURE TO FILE 8
        !
        IF(HEAT) THEN
            DO 50 J=1,NLY
                do 45 N=1,NXR
                    IN = NLY*(N-1)+J
                    DUM(IN) = TT(IN)
                    if(dabs(dum(in)).lt.elimit1) dum(in) = elimit2
45              continue
                if (o13p) then
                    WRITE(08,4011) (DUM(N),N=J,NNODES-NLY+J,NLY)
                else
                    WRITE(08,4010) (DUM(N),N=J,NNODES-NLY+J,NLY)
                end if
50          CONTINUE
        END IF
        !      end if

        !
        !  WRITE CONCENTRATION TO FILE 8
        !
        !      IF(SOLUTE) THEN
        !      use dumm3Alloc
        !     DO 51 J=1,NLY   
        !      do 46 N=1,NXR
        !      IN = NLY*(N-1)+J
        !      DO 43 M=1,Nsol  
        !      DUM3(M,IN)= CC(M,IN)
        !      if(dabs(DUM3(M,IN)).lt.elimit1) DUM3(M,IN) = elimit2
        ! 43   continue       
        ! 46   continue
        ! 51   continue
        !      do 52, K=1,NLY 
        !      do 52, M=1,Nsol  
        !      if (o13p) then  
        !       WRITE(08,4011) (DUM3(M,N),N=K,NNODES-NLY+K,NLY)
        !      else
        !       WRITE(08,4010) (DUM3(M,N),N=K,NNODES-NLY+K,NLY)
        !     end if
        !52  CONTINUE 
        !     use dumm3Dealloc    
        !      END IF
    END IF
    !      end if     
    !
    !    PRINT TOTAL HEADS
    !
    IF(HPNT) THEN
        WRITE (6,4060)
        CALL VSOUT(1,P)
    END IF
    !
    !  PRINT PRESSURE HEADS
    !
    IF(PPNT) THEN
        !      IF(JPLT.NE.1.or..not.f8p) THEN
        DO 60 J=2,NLYY
            DO 60 N=2,NXRR
                IN=NLY*(N-1)+J
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(N)*CS2
                END IF
                DUM(IN)=P(IN)+Z1
                IF(HX(IN).EQ.0.0D0)DUM(IN)=0.0D0
                THEAD(IN)=DUM(IN)
60      CONTINUE
        !      END IF
        WRITE (6,4070)
        CALL VSOUT(1,DUM)
    END IF
    !
    !  PRINT SATURATIONS
    !
    IF(SPNT) THEN
        DO 70 J=2,NLYY
            DO 70 N=2,NXRR
                IN=NLY*(N-1)+J
                TTX=HK(JTEX(IN),3)
                IF(TTX.EQ.0.0D0) THEN
                    DUM(IN)=0.0D0
                ELSE
                    DUM(IN)=THETA(IN)/TTX
                END IF
                SATUR(IN)=DUM(IN)
70      CONTINUE
        WRITE (6,4080)
        CALL VSOUT(2,SATUR)
    END IF
    !
    !  PRINT MOISTURE CONTENTS
    !
    IF(THPT) THEN
        WRITE (6,4090)
        CALL VSOUT(2,THETA)
    END IF
    !
    !  PRINT VELOCITIES
    !
    IF(VPNT.AND.KTIM.GT.0) THEN
        if(nxr.gt.3) then
            WRITE(06,4100)
            CALL VSOUT(1,VX)
        end if
        if(nly.gt.3) then
            WRITE(06,4110)
            CALL VSOUT(1,VZ)
        end if
    END IF
    !
    !  PRINT temperature
    !
    IF(HEAT) THEN
        WRITE(6,4120)
        CALL VSOUT(2,TT)
    END IF
    !
    !  PRINT CONCENTRATIONS
    !
    IF(SOLUTE) THEN
        WRITE(6,4121)
        CALL VSOUTS(1,CC)
        if (o11p) then
            io11p = 1
        else
            io11p = 0
        endif
        call FH_WriteFiles(rm_id, 1, io11p, NPRCHXZ(1), NPRCHOBS(1))
    END IF      
    CONTINUE
    RETURN
4000 FORMAT(/,8H TIME = ,E15.6,1X,A4/)
4010 FORMAT(99999(1PE15.7))
4011 FORMAT(99999(1PE21.13))
4020 FORMAT(1pe14.6,1x,i8,2x,100(1x,1PE12.5))
4021 FORMAT(1pe18.10,1x,i8,2x,100(1PE21.13))
    !
    !following change made 6/29/09 for Marie S to print
    !  3 digits in exponent
    !
    ! 4020 FORMAT(1pe14.6,1x,i8,2x,12(1x,1PE12.4E3))
    ! 4021 FORMAT(1pe18.10,1x,i8,2x,12(1PE21.12E3))
4030 FORMAT(7E11.4)
4040 FORMAT(' TIME STEP ',I9,'  TIME = ',E14.6,'  NIT = ',I5, &
    '  NIT1 = ',I5,'  NIT3 = ',I5,'  NIS1 = ',I5)
4050 FORMAT(6X,A80/5X,20HTOTAL ELAPSED TIME =,1PE14.6,1X,A4/5X, &
10  HTIME STEP ,I9,//)
4060 FORMAT(1H ,50X,10HTOTAL HEAD)
4070 FORMAT(1H ,50X,13HPRESSURE HEAD)
4080 FORMAT(1H ,50X,10HSATURATION)
4090 FORMAT(1H ,50X,16HMOISTURE CONTENT)
4100 FORMAT(51X,'X-VELOCITY')
4110 FORMAT(51X,'Z-VELOCITY')
4120 FORMAT(51X,'TEMPERATURE')
4121 FORMAT(51X,'CONCENTRATION')
    END
    SUBROUTINE VSOUT(IV,VPRNT)
    !*****
    !VSOUT
    !*****
    !
    !    PURPOSE: TO PRINT TWO DIMENSIONAL ARRAYS
    !
    !-----------------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    !
    use press
    use rspac
    use kcon
    use dumm1
    use trxxh
    use trxv
    use mprop
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT 
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX 
    common/elimit/elimit1,elimit2
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,  &
    o13p,F14P,F15P,F16P,F17P,F18P,F19P
    LOGICAL THPT,SPNT,PPNT,HPNT,VPNT
    COMMON/LOG4/THPT,SPNT,PPNT,HPNT,VPNT
    DIMENSION VPRNT(1)
    !
    !-------------------------------------------------------------------
    !
    !!@@include 'd_dumm1Alloc.inc'
    allocate(DUM1(NNODES))
    WRITE (06,4000) ZUNIT,ZUNIT
    WRITE (06,4010)(RX(K),K=2,NXRR)
    DO 30 J=2,NLYY
        DO 10 N=2,NXRR
            !      IN=NLY*(N)-(J-1)
            IN=NLY*(N-1)+J
            DUM1(N)=VPRNT(IN)
            IF(HX(IN).EQ.0.0D0) DUM1(N)=0.0D0
            if(dabs(dum1(n)).lt.elimit1) dum1(n) = elimit2
10      CONTINUE
        IF(IV.GT.1) GO TO 20
        WRITE (06,4020) DZZ(J),(DUM1(N),N=2,NXRR)
        !      IF((VPRNT(IN).EQ.VX(IN)).OR.(VPRNT(IN).EQ.VZ(IN)))THEN
        !      IF(J.EQ.2)WRITE (17,*) 
        !      WRITE (17,4021) (DUM1(N),N=2,NXRR)
        !      END IF
        !      IF(VPRNT(IN).EQ.TT(IN))THEN
        !      IF(J.EQ.2)WRITE (16,*)  
        !      WRITE (16,4021) (DUM1(N),N=2,NXRR)
        !      END IF 
        !      IF(VPRNT(IN).EQ.THETA(IN))THEN
        !      IF(J.EQ.2)WRITE (18,*)  
        !      WRITE (18,4021) (DUM1(N),N=2,NXRR)
        !      END IF
        !      IF((VPRNT(IN).EQ.P(IN)).OR.(VPRNT(IN).EQ.THEAD(IN)))THEN
        !      IF(J.EQ.2)WRITE (14,*)  
        !      WRITE (14,4021) (DUM1(N),N=2,NXRR) 
        !      END IF
        !      IF(VPRNT(IN).EQ.SATUR(IN)) THEN
        !      IF(J.EQ.2)WRITE (19,*)  
        !      WRITE (19,4021) (DUM1(N),N=2,NXRR) 
        !      END IF  
        GO TO 30
20      WRITE (06,4030) DZZ(J),(DUM1(N),N=2,NXRR)
        !      IF((VPRNT(IN).EQ.VX(IN)).OR.(VPRNT(IN).EQ.VZ(IN)))THEN
        !      IF(J.EQ.2)WRITE (17,*)  
        !      WRITE (17,4031) (DUM1(N),N=2,NXRR)
        !      END IF
        !      IF(VPRNT(IN).EQ.TT(IN))THEN
        !      IF(J.EQ.2)WRITE (16,*) 
        !      WRITE (16,4031) (DUM1(N),N=2,NXRR) 
        !      END IF
        !      IF(VPRNT(IN).EQ.THETA(IN))THEN
        !      IF(J.EQ.2)WRITE (18,*)  
        !      WRITE (18,4021) (DUM1(N),N=2,NXRR)
        !      END IF
        !      IF((VPRNT(IN).EQ.P(IN)).OR.(VPRNT(IN).EQ.THEAD(IN)))THEN
        !      IF(J.EQ.2)WRITE (14,*)  
        !      WRITE (14,4031) (DUM1(N),N=2,NXRR) 
        !      END IF
        !      IF(VPRNT(IN).EQ.SATUR(IN))THEN
        !      IF(J.EQ.2)WRITE (19,*)  
        !      WRITE (19,4031) (DUM1(N),N=2,NXRR)   
        !      END IF  
30  CONTINUE
    !!@@include 'd_dumm1Dealloc.inc'
    deallocate(DUM1)
    RETURN
4000 FORMAT(1H ,1X,5HZ, IN/2X,A4,20X,20HX OR R DISTANCE, IN ,A4)
4010 FORMAT(1H ,9X,99999(F11.3)/(9X,13(F9.2)))
4020 FORMAT(1X,F9.3,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
4021 FORMAT(1X,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
4030 FORMAT(1X,F9.3,99999(1X,F10.4)/(9X,13F9.3))
4031 FORMAT(1X,99999(1X,F10.4)/(9X,13F9.3))
    END
    SUBROUTINE VSOUTS(IV,VPRNTS)
    !XXXXXXXXXXXXXXXXXXXXXXXXX
    !
    !VSOUTS
    !******
    !      PURPOSE: TO PRINT TWO DIMENSIONAL ARRAY
    !-------------------------------------------------------
    !
    use rspac
    use kcon
    use dumm2
    use compnam
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    CHARACTER*80 TITL
    CHARACTER*6 ZUNIT,CUNX,HUNX
    CHARACTER*7 TUNIT 
    CHARACTER*10 SCOMPNAME(50)
    COMMON/SCHAR/TITL,ZUNIT,TUNIT,CUNX,HUNX 
    common/elimit/elimit1,elimit2
    LOGICAL F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,o13p, &
    F14P,F15P,F16P,F17P,F18P,F19P
    COMMON/LOG2/F7P,F11P,F8P,F9P,F6P,PRNT,o9p,o11p,o12p,  &
    o13p,F14P,F15P,F16P,F17P,F18P,F19P
    DIMENSION VPRNTS(Nsol,NNODES)
    !!@@include 'd_dumm2Alloc.inc'
    allocate(DUM2(Nsol,NNODES))
    !-----------------------------------------------------------------      
    WRITE (06,4000) ZUNIT,ZUNIT 
    WRITE (06,4010) (RX(K),K=2,NXRR) 
    DO 30 M=1,Nsol
        SCOMPNAME(M)=COMPNAME(M)  
        DO 30 J=2,NLYY
            DO 10 N=2,NXRR 
                !      IN=NLY*(N)-(J-1)
                IN=NLY*(N-1)+J
                DUM2(M,N)=VPRNTS(M,IN) 
                IF(HX(IN).EQ.0.0D0) DUM2(M,N)=0.d0 
10          CONTINUE 
            IF(IV.GT.1) GO TO 20 
            IF(J.EQ.2) then
                WRITE (06,4001)SCOMPNAME(M)
                !        WRITE (15,*)
            end if
            WRITE (06,4020) DZZ(J),(DUM2(M,N),N=2,NXRR)
            !      WRITE (15,4021)(DUM2(M,K),K=2,NXRR) 
            GO TO 30 
20          CONTINUE
            IF(J.EQ.2) then
                WRITE (06,4001) COMPNAME(M)
                !      WRITE (15,*)
            end if
            WRITE (06,4030) DZZ(J),(DUM2(M,N),N=2,NXRR)
            !      WRITE (15,4031)(DUM2(M,K),K=2,NXRR) 
30  CONTINUE 
    !!@@include 'd_dumm2Dealloc.inc'
    deallocate(DUM2)
    return
4000 FORMAT(1H ,1X,5HZ, IN/2X,A4,20X,20HX OR R DISTANCE, IN ,A4) 
4001 FORMAT(A10)
4010 FORMAT(1H ,9X,99999(F11.3)/(9X,13(F9.2)))
4020 FORMAT(1X,F9.3,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
4021 FORMAT(1X,99999(1X,1PE10.3)/(9X,13(1PE9.2)))
4030 FORMAT(1X,F9.3,99999(1X,F10.4)/(9X,13F9.3))
4031 FORMAT(1X,99999(F9.3)/(9X,13F9.3))
    END      
    SUBROUTINE VSPOND(IFET,IFET1,IFET2)
    !******
    !CVSPOND
    !******
    !
    !  UPDATED 10-88
    !
    !   PURPOSE:  TO DETERMINE IF PONDING OR UNPONDING HAS OCCURRED, AND
    !             IF SO TO CHANGE BOUNDARY CONDITIONS AT THOSE NODES FROM
    !              NEUMAN TO DIRICHLET OR VICE VERSA
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use press
    use disch
    use equat
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/PND/POND
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    COMMON/TCON1/NIS,NIS1,NIS3
    !
    !--------------------------------------------------------------------
    !
    !   IFET1 INDICATES WHETHER THERE ARE ANY NEUMAN BOUNDARIES REMAINING
    !   IFET2 INDICATES WHETHER ANY SPECIFIC FLUX NODES HAVE BEEN CONVERTED
    !     TO SPECIFIED HEAD NODES.  BECAUSE OF THE CAPILLARY BARRIER
    !     EFFECT, THESE NODES MAY NEED TO REVERT TO SPECIFIED FLUX NODES.
    !   IFET INDICATES WHETHER PONDING OCCURRED OR DISAPPEARED
    !
    IF(IFET1.EQ.0 .AND. IFET2 .EQ. 0) RETURN
    IFET=0
    IFET1=0
    IFET2=0
    IF(CS1.EQ.1.0D0) THEN
        DZ1=DZZ(2)
    ELSE
        IF(CS2.LT.0.0D0) THEN
            DZ1=DZZ(2)*CS1+RX(NXRR)*CS2
        ELSE
            DZ1=DZZ(2)*CS1+RX(2)*CS2
        END IF
    END IF
    DO 20 I=2,NXRR
        DO 10 J=2,NLYY
            IN=NLY*(I-1)+J
            IF(HX(IN).NE.0.0D0) THEN
                IF(NTYP(IN).EQ.2.AND.QQ(IN).GT.0.0D0) THEN
                    IFET1=1
                    IF(CS1.EQ.1.0D0) THEN
                        Z1=DZZ(J)
                    ELSE
                        Z1=DZZ(J)*CS1+RX(I)*CS2
                    END IF
                    IF(POND.GE.0.0D0) THEN
                        !
                        !    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
                        !
                        DZ2=POND-Z1
                    ELSE
                        DZ2=-DMIN1(Z1,DZ1-POND)
                    END IF
                    IF(P(IN).GT.DZ2) THEN
                        !
                        !   IF COMPUTED HEAD EXCEEDS MAXIMUM THEN SET P=DZ2
                        !    AND CHANGE BOUNDARY TYPE TO CONSTANT HEAD
                        !
                        P(IN)=DZ2
                        NTYP(IN)=1
                        IFET=1
                        IFET2=1
                        WRITE(6,4000) J,I,KTIM,NIT
                    END IF
                ELSE
                    IF(NTYP(IN).EQ.1.AND.QQ(IN).GT.0.0D0) THEN
                        IFET2=1
                        !
                        !  change 6/09 to prevent reconverting if p is not less
                        !   than DZ2
                        !
                        IF(CS1.EQ.1.0D0) THEN
                            Z1=DZZ(J)
                        ELSE
                            Z1=DZZ(J)*CS1+RX(I)*CS2
                        END IF
                        IF(POND.GE.0.0D0) THEN
                            !
                            !    DZ2 IS MAXIMUM ALLOWABLE TOTAL HEAD
                            !
                            DZ2=POND-Z1
                        ELSE
                            DZ2=-DMIN1(Z1,DZ1-POND)
                        END IF
                        if (p(in).lt.DZ2) then
                            !
                            !  end 6/09 change
                            !
                            JP1=IN+1
                            IM1=IN+NLY
                            IP1=IN-NLY
                            TEST=(P(IN)-P(JP1))*D(IN)
                            IF(HX(IM1).NE.0.0D0) TEST=TEST+(P(IN)-P(IM1))*C(IN)
                            IF(HX(IP1).NE.0.0D0) TEST=TEST+(P(IN)-P(IP1))*A(IN)
                            TEST=TEST/QQ(IN)
                            IF (TEST .GE. 1.01D0)THEN
                                !
                                !  IF FLUX FROM THE CONVERTED NODE IS GREATER THAN THE SPECIFIED
                                !  FLUX RATE, THE NODE IS RECONVERTED TO A SPECIFIED FLUX NODE.
                                !
                                NTYP(IN)=2
                                IFET=1
                                IFET1=1
                                WRITE(06,4010)J,I,KTIM,NIT
                            END IF
                        end if
                    END IF
                END IF
                GO TO 20
            END IF
10      CONTINUE
20  CONTINUE
    RETURN
4000 FORMAT(//,6X,17H PONDING AT NODE ,2I5,17H DURING TIME STEP, &
    I9,'  ITERATION ',I5)
4010 FORMAT(//,6X,' PONDING ENDED AT NODE ',2I5, &
    ' DURING TIME STEP ',I9,'  ITERATION ',I5)
    END
    SUBROUTINE VSSFAC
    !******
    !VSSFAC
    !******
    !
    !  REVISED 10-88
    !
    !    PURPOSE:  TO COMPUTE POSITION OF SEEPAGE FACE BOUNDARIES
    !
    !     HEIGHT OF SEEPAGE FACE IS LOWERED IF THERE IS FLUX INTO SYSTEM
    !     THRU FACE.
    !    HEIGHT IS RAISED IF PRESSURE HEADS ARE POSITIVE ABOVE FACE.
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use press
    use spfc
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    !
    !-------------------------------------------------------------------
    !
    DO 90 K=1,NFCS
        NFX=NFC(K)
        JFST=0
        JLST=JLAST(K)
        !
        !   CHECK FOR POSITIVE PRESSURES ABOVE SEEPAGE FACE
        !
        DO 10 J=NFX,1,-1
            IN=JSPX(1,J,K)
            JJ=JSPX(2,J,K)
            NN=JSPX(3,J,K)
            IF(CS1.EQ.1.0D0) THEN
                Z1=DZZ(JJ)
            ELSE
                Z1=DZZ(JJ)*CS1+RX(NN)*CS2
            END IF
            PTMP=P(IN)+Z1
            IF(PTMP.LT.0.0D0) GO TO 10
            JFST=J
            GO TO 20
10      CONTINUE
20      CONTINUE
        !
        !   CHECK FOR FLOW INTO DOMAIN THROUGH SEEPAGE FACE
        !
        IF(JFST.GT.JLST) GO TO 60
        DO 40 I=JLST,1,-1
            IN=JSPX(1,I,K)
            IM1=IN-NLY
            JM1=IN-1
            IP1=IN+NLY
            JP1=IN+1
            IF(HX(IM1).EQ.0.0D0) THEN
                IF(HX(IP1).NE.0.0D0.AND.P(IP1).LT.P(IN)) GO TO 30
            END IF
            IF(HX(JM1).EQ.0.0D0) THEN
                IF(HX(JP1).NE.0.0D0.AND.P(JP1).LT.P(IN)) GO TO 30
            END IF
            IF(HX(IP1).EQ.0.0D0) THEN
                IF(HX(IM1).NE.0.0D0.AND.P(IM1).LT.P(IN)) GO TO 30
            END IF
            IF(HX(JP1).EQ.0.0D0) THEN
                IF(HX(JM1).NE.0.0D0.AND.P(JM1).LT.P(IN)) GO TO 30
            END IF
            GO TO 50
30          NTYP(IN)=3
40      CONTINUE
        I=0
50      IF(I.EQ.JLST) GO TO 60
        !
        !   RESET SEEPAGE FACE HEIGHT AND BOUNDARIES
        !
        JLAST(K)=I
        GO TO 80
60      IF(JFST.EQ.JLST) GO TO 80
        DO 70 I=1,JFST
            IN=JSPX(1,I,K)
            JJ=JSPX(2,I,K)
            NN=JSPX(3,I,K)
            IF(CS1.EQ.1.0D0) THEN
                Z1=DZZ(JJ)
            ELSE
                Z1=DZZ(JJ)*CS1+RX(NN)*CS2
            END IF
            NTYP(IN)=1
            P(IN)=-Z1
70      CONTINUE
        JLAST(K)=JFST
80      CONTINUE
90  CONTINUE
    END
    SUBROUTINE VSEVAP
    !******
    !VSEVAP
    !******
    !
    !  PURPOSE: TO COMPUTE SURFACE EVAPORATION RATES
    !
    !
    !------------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use hcon
    use press
    use disch
    use ptet
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    !
    !-----------------------------------------------------------------
    !
    ETOUT1=0.0D0
    do 6 i = nly,nnodes
        q(i) = 0.0d0
6   continue
    IF(SRES.EQ.0.0D0) RETURN
    DO 10 N=2,NXRR
        ETR = 0.0D0
        dzEvapCells = 0.0D0
        nIndex = nly*(n - 1)
        AREA=DXR(N)
        IF(RAD)AREA=PI2*RX(N)*DXR(N)
        PETT=PEV*AREA
        DO 7 J=2,NLYY
            IN = nIndex + J
            IF(NTYP(IN).EQ.5) then
                dzEvapCells = dzEvapCells + delz(j)
            end if
7       continue
        DO 8 J=2,NLYY
            IN = nIndex + J
            IF(NTYP(IN).EQ.5) THEN
                !
                !    COMPUTE TEMPORARY EVAP RATE, CHECK AGAINST MAX AND
                !    CORRECT IF NECESSARY
                !
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(N)*CS2
                END IF
                PTMP=P(IN)+Z1
                HKX=HCND(IN)*HX(IN)
                EV=HKX*SRES*(HA-PTMP)*AREA*delz(j)/dzEvapCells
                IF(EV.GT.0.0D0) EV=0.0D0
                Q(IN)=EV
                ETR = ETR + Q(IN)
            end if
8       continue
        if (ETR.lt.pett) then
            r1 = pett/ETR
            ETR = PETT
            DO 9 J=2,NLYY
                IN = nIndex + J
                IF(NTYP(IN).EQ.5) q(in) = q(in)*r1
9           continue
        end if
        ETOUT1=ETOUT1+ETR
10  CONTINUE
    RETURN
    END
    SUBROUTINE VSPLNT
    !******
    !VSPLNT
    !******
    !
    !   THIS SUBROUTINE COMPUTES ACTUAL ET AS A FUNCTION OF A ROOT
    !        ACTIVITY FUNCTION, HYDRAULIC CONDUCTIVITY OF THE SOIL,
    !        AND THE DIFFERENCE IN PRESSURE HEAD BETWEEN THE ROOTS AND
    !        THE SOIL
    !
    ! ----------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use rspac
    use kcon
    use press
    use disch
    use hcon
    use ptet
    use dumm
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    !
    !   SUM TRANSPIRATION FOR EACH COLUMN
    !
    ETOUT=0.0D0
    if(.not.bcit) then
        do 6 i = nly,nnodes
            q(i) = 0.0d0
6       continue
    end if
    IF(PET.GE. 0.0D0)RETURN
    DO 50 I=2,NXRR
        ETR=0.0D0
        AREA=DXR(I)
        IF (RAD) AREA=PI2*RX(I)*DXR(I)
        PETT=AREA*PET
        iIndex = nly*(i-1)
        DO 10 J=2,NLYY
            !
            !   COMPUTE TRANSPIRATION FOR EACH NODE IN COLUMN
            !
            IN=iIndex+J
            IF(NTYP(IN).EQ.0.AND.HX(IN).GT.0.0D0) THEN
                VOL=AREA*DELZ(J)
                IF(DPTH(IN).GT.RTDPTH) GO TO 20
                !
                !   TRANSPIRATION IS ZERO IF NTYP IS NOT 0, NODE IS DEEPER
                !   THAN RTDPTH, OR PRESSURE IS LESS THAN HROOT
                !
                IF(CS1.EQ.1.0D0) THEN
                    Z1=DZZ(J)
                ELSE
                    Z1=DZZ(J)*CS1+RX(I)*CS2
                END IF
                PTMP=P(IN)+Z1
                IF(PTMP.LE.HROOT) THEN
                    dum(IN)=0.0D0
                ELSE
                    HXX=HCND(IN)*HX(IN)*RT(IN)*VOL
                    !
                    !   Q IS TRANSPIRATION FOR EACH NODE.  ETR IS TOTAL FOR COLUMN
                    !
                    dum(IN)=(HROOT-PTMP)*HXX
                    ETR=ETR+dum(IN)
                END IF
            END IF
10      CONTINUE
20      continue
        ETR1 = ETR
        IF(ETR.LT.PETT) THEN
            !
            !   IF TOTAL TRANSPIRATION FOR COLUMN IS GREATER
            !   THAN POTENTIAL THEN ADJUST TRANSPIRATION VALUES
            !
            R1=PETT/ETR
            ETR1=PETT
        end if
        DO 30 K=2,J
            IN=iIndex+K
            IF(HX(IN).GT.0.0D0.AND.NTYP(IN).EQ.0) THEN
                IF(DPTH(IN).GT.RTDPTH) GO TO 40
                if(etr.lt.pett) then
                    Q(IN)= Q(IN) + dum(IN)*R1
                else
                    Q(IN) = Q(IN) + dum(in)
                end if
            END IF
30      CONTINUE
40      CONTINUE
        ETOUT=ETOUT+ETR1
50  CONTINUE
    RETURN
    END
    SUBROUTINE VSPET
    !*****
    !VSPET
    !*****
    !
    !   PURPOSE: TO COMPUTE VALUES OF PEV,SRES,HA,PET,RTDPTH,RTBOT,RTTOP,
    !             AND HROOT FOR EVAPORATION AND TRANSPIRATION CALCULATIONS.
    !             VALUES ARE DETERMINED BY LINEAR INTERPOLATION IN TIME
    !            BETWEEN EVAPOTRANSPIRATION PERIODS.
    !
    !------------------------------------------------------------------
    !
    !    SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use ptet
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    !
    !--------------------------------------------------------------
    !
    npv1 = npv
    if(npv.lt.0) npv = -npv
    IF (NPV.EQ.1) THEN
        !
        !   IF ONLY 1 PERIOD THEN ALL VALUES ARE CONSTANT
        !
        IF(BCIT) THEN
            PEV=-PEVAL(1)
            SRES=RDC(1,1)
            HA=RDC(2,1)
        END IF
        IF(ETSIM) THEN
            PET=-PTVAL(1)
            RTDPTH=RDC(3,1)
            RTBOT=RDC(4,1)
            RTTOP=RDC(5,1)
            HROOT=RDC(6,1)
        END IF
    ELSE
        !
        !   DETERMINE WHICH PERIOD TO USE
        !
        ETCYC1=NPV*ETCYC
        SITY=DMOD(STIM,ETCYC1)
        I=(SITY/ETCYC)+2
        if (i.gt.npv) i = 1
        IF(I.EQ.1) THEN
            K=NPV
        ELSE
            K=I-1
        END IF
        !
        !   LINEARLY INTERPOLATE
        !
        FRPER=(DMOD(SITY,ETCYC))/ETCYC
        IF (BCIT) THEN
            PEV=-PEVAL(K)-(PEVAL(I)-PEVAL(K))*FRPER
            SRES=RDC(1,K)+(RDC(1,I)-RDC(1,K))*FRPER
            HA=RDC(2,K)+(RDC(2,I)-RDC(2,K))*FRPER
        END IF
        IF (ETSIM) THEN
            PET=-PTVAL(K)-(PTVAL(I)-PTVAL(K))*FRPER
            RTDPTH=RDC(3,K)+(RDC(3,I)-RDC(3,K))*FRPER
            RTBOT=RDC(4,K)+(RDC(4,I)-RDC(4,K))*FRPER
            RTTOP=RDC(5,K)+(RDC(5,I)-RDC(5,K))*FRPER
            HROOT=RDC(6,K)+(RDC(6,I)-RDC(6,K))*FRPER
        END IF
    END IF
    npv = npv1
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSRDF(Z1,Z2)
    !*****
    !VSRDF
    !*****
    !
    !     PURPOSE: TO DETERMINE THE ROOT ACTIVITY AT EACH NODE WITHIN
    !              THE ROOT ZONE FOR EACH TIME STEP
    !
    !
    !-------------------------------------------------------------------
    !
    use ptet
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !     include 'c_ptet.inc'
    !
    !------------------------------------------------------------
    !
    !
    !   LINEARLY INTERPOLATE USING DEPTH OF NODE AND MAXIMUM ROOT DEPTH
    !
    IF(RTDPTH.GT.Z1.AND.RTDPTH.GT.0.0D0)THEN
        IF(RTDPTH.GE.Z1+Z2)THEN
            ZZ=Z1+0.5D0*Z2
            ZZ1=1.0D0
        ELSE
            ZZ=(Z1+RTDPTH)*0.5D0
            ZZ1=(RTDPTH-Z1)/Z2
        END IF
        VSRDF=ZZ1*(ZZ*RTBOT+(RTDPTH-ZZ)*RTTOP)/RTDPTH
    ELSE
        VSRDF=0.0D0
    END IF
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSDTHUVG(P,I)
    ! ******
    !VSDTHUVG
    !******
    !
    !    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !
    !   VAN GENUCHTEN FUNCTION
    !
    !          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
    !          HK(I,2)=SPECIFIC STORAGE
    !          HK(I,3)=POROSITY
    !          HK(I,4)=ALPHA PRIME
    !          HK(I,5)=RESIDUAL MOISTURE CONTENT
    !          HK(I,6)=BETA PRIME
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSDTHUVG=0.0D0
    IF(P.GE.0.0D0)RETURN
    SE=HK(I,3)-HK(I,5)
    EN=HK(I,6)
    EM=2.0D0-1.0D0/EN
    !
    !   NOTE -- following change made 12/1/98 to change definition of van
    !           Genuchten alpha from original definition used in VS2DT.
    !           New definition corresponds to that given by van Genuchten
    !           (1980) in terms of inverse length.
    !
    !      ALPH=HK(I,4)
    ALPH=-1.0D0/HK(I,4)
    A=P/ALPH
    VSDTHUVG=-(EN-1.0D0)*SE*A**(EN-1.0D0)/(ALPH*(1.0D0+A**EN)**EM)
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHNVVG(V,I)
    !******
    !VSTHNVVG
    !******
    !
    !    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
    !    MOISTURE CONTENT
    !
    !    VAN GENUCHTEN FUNCTION
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/JCON/JSTOP,JFLAG,jflag1
    !      include 'c_rpropsh.inc'
    VSTHNVVG=0.0D0
    IF(V.GE.HK(I,3)) RETURN
    IF(V.GT.HK(I,5)) GO TO 10
    WRITE(6,4000) V,I
    jstop=6
    return
10  SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
    EN=HK(I,6)
    EM=1.0D0-1.0D0/EN
    !
    !   NOTE -- following change made 12/1/98 to change definition of van
    !           Genuchten alpha from original definition used in VS2DT.
    !           New definition corresponds to that given by van Genuchten
    !           (1980) in terms of inverse length.
    !
    !      ALPH=HK(I,4)
    ALPH=-1.0D0/HK(I,4)
    VSTHNVVG=ALPH*(1.0D0/SE**(1.0D0/EM)-1.0D0)**(1.0D0-EM)
    RETURN
4000 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
    ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
    'PROGRAM HALTED')
    END
    DOUBLE PRECISION FUNCTION VSTHUVG(P,I)
    !*****
    !VSTHUVG
    !*****
    !
    !    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !
    ! VAN GENUCHTEN FUNCTION
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSTHUVG=HK(I,3)
    IF(P .GE. 0.0D0)RETURN
    EN=HK(I,6)
    !     EM=-(1.0D0-1.0D0/EN)
    EM=(1.0D0-1.0D0/EN)
    A=HK(I,3)-HK(I,5)
    !
    !   NOTE -- following change made 12/1/98 to change definition of van
    !           Genuchten alpha from original definition used in VS2DT.
    !           New definition corresponds to that given by van Genuchten
    !           (1980) in terms of inverse length.
    !
    !      ALPH=HK(I,4)
    ALPH=-1.0D0/HK(I,4)
    VSTHUVG=HK(I,5)+A/(1.0D0+(P/ALPH)**EN)**EM
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUVG(P,I)
    !*****
    !VSHKUVG
    !*****
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !   VAN GENUCHTEN FUNCTION
    !
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rprop.inc'
    VSHKUVG=1.0D0
    IF(P.GE.0.0D0)RETURN
    EN=HK(I,6)
    EM=1.0D0-1.0D0/EN
    !
    !   NOTE -- following change made 12/1/98 to change definition of van
    !           Genuchten alpha from original definition used in VS2DT.
    !           New definition corresponds to that given by van Genuchten
    !           (1980) in terms of inverse length.
    !
    !      A=P/HK(I,4)
    A=-P*HK(I,4)
    TOP=A**EN
    DEN=(1.0D0+TOP)**(EM/2.0D0)
    !     TOP=1.0D0-TOP/A*(1.0D0+TOP)**(-EM)
    TOP=1.0D0-TOP/((1.0D0+TOP)**EM*A)
    VSHKUVG=TOP*TOP/DEN
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUVGH(P,TT,I)
    !*****
    !VSHKUVG
    !****
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !  VAN GENUCHTEN FUNCTION
    !
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    if (trans) then
        R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
        (TT+273.160D0-140.0D0)))     
        VSHKUVGH=R2
    else
        VSHKUVGH= 1.0D0
    end if
    IF(P.GE.0.0D0)RETURN
    EN=HK(I,6)
    EM=1.0D0-1.0D0/EN
    !
    !   NOTE -- following change made 12/1/98 to change definition of van
    !           Genuchten alpha from original definition used in VS2DH.
    !           New definition corresponds to that given by van Genuchten
    !           (1980) in terms of inverse length.
    !
    !      A=P/HK(I,4)
    A=-P*HK(I,4)
    TOP=A**EN
    DEN=(1.0D0+TOP)**(EM/2.0D0)
    !     TOP=1.0D0-TOP/A*(1.0D0+TOP)**(-EM)
    TOP=1.0D0-TOP/((1.0D0+TOP)**EM*A)
    VSHKUVGH=VSHKUVGH*TOP*TOP/DEN
    RETURN
    END

    DOUBLE PRECISION FUNCTION VSDTHUBC(P,I)
    !******
    !VSDTHUBC
    !******
    !
    !    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !
    !    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 PP.3-4
    !
    !          HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
    !          HK(I,2)=SPECIFIC STORAGE
    !          HK(I,3)=POROSITY
    !          HK(I,4)=BUBBLING PRESSURE
    !          HK(I,5)=RESIDUAL MOISTURE CONTENT
    !          HK(I,6)=LAMBDA
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSDTHUBC=0.0D0
    IF(P.GE.HK(I,4))RETURN
    VSDTHUBC=-((HK(I,3)-HK(I,5))*HK(I,6)*(HK(I,4)/P)**HK(I,6))/P
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHNVBC(V,I)
    !******
    !VSTHNVBC
    !******
    !
    !    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
    !    MOISTURE CONTENT
    !
    !    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 17 , PP.3-4
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/JCON/JSTOP,JFLAG,jflag1
    !      include 'c_rpropsh.inc'
    VSTHNVBC=HK(I,4)
    IF(V.GE.HK(I,3)) RETURN
    IF(V.GT.HK(I,5)) GO TO 1
    WRITE(6,100) V,I
100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
    ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
    'PROGRAM HALTED')
    jstop=6
    return
1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
    VSTHNVBC=HK(I,4)/(SE**(1.0D0/HK(I,6)))
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHUBC(P,I)
    !*****
    !VSTHUBC
    !*****
    !
    !    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
    !   PRESSURE: = POROSITY ELSEWHERE
    !
    !    BROOKS AND COREY, CSU HYDROLOGY PAPER NO.17, PP.3-4
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSTHUBC=HK(I,3)
    IF(P.GE.HK(I,4))RETURN
    VSTHUBC=HK(I,5)+(HK(I,3)-HK(I,5))*(HK(I,4)/P)**HK(I,6)
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUBC(P,I)
    !*****
    !VSHKUBC
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 3
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSHKUBC=1.0D0
    IF(P.GE.HK(I,4))RETURN
    VSHKUBC=(HK(I,4)/P)**(2.0D0+3.0D0*HK(I,6))
    IF(VSHKUBC.LT.1.D-38)VSHKUBC=0.0D0
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUBCH(P,TT,I)
    !*****
    !CVSHKUBCH
    !C*****
    !
    !   RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !    BROOKS AND COREY, CSU HYDROLOGY PAPER NO. 3
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    if (trans) then
        R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
        (TT+273.160D0-140.0D0)))
        VSHKUBCH=R2
    else
        VSHKUBCH = 1.0D0
    end if
    IF(P.GE.HK(I,4))RETURN
    VSHKUBCH=VSHKUBCH*(HK(I,4)/P)**(2.0D0+3.0D0*HK(I,6))
    IF(VSHKUBCH.LT.1.D-38)VSHKUBCH=0.0D0
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSDTHUHK(P,I)
    !******
    !VSDTHUHK
    !******
    !
    !    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !
    !   HAVERKAMP FUNCTION
    !
    !         HK(I,1)=SATURATED HYDRAULIC CONDUCTIVITY
    !          HK(I,2)=SPECIFIC STORAGE
    !          HK(I,3)=POROSITY
    !          HK(I,4)=A PRIME
    !          HK(I,5)=RESIDUAL MOISTURE CONTENT
    !          HK(I,6)=B PRIME
    !          HK(I,7)=ALPHA
    !          HK(I,8)=BETA
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSDTHUHK=0.0D0
    IF(P.GE.0.0D0)RETURN
    SE=HK(I,3)-HK(I,5)
    ALPH=HK(I,7)
    EM=HK(I,8)
    TOP=P/ALPH
    DEN=1.0D0+TOP**EM
    DEN=DEN*DEN
    VSDTHUHK=-SE*EM*TOP**(EM-1.0D0)/(ALPH*DEN)
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHNVHK(V,I)
    !******
    !VSTHNVHK
    !******
    !
    !    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
    !    MOISTURE CONTENT
    !
    !    HAVERKAMP FUNCTION
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/JCON/JSTOP,JFLAG,jflag1
    !      include 'c_rpropsh.inc'
    VSTHNVHK=0.0D0
    IF(V.GE.HK(I,3)) RETURN
    IF(V.GT.HK(I,5)) GO TO 1
    WRITE(6,100) V,I
100 FORMAT(/,'INITIAL MOISTURE CONTENT OF ',F7.3,'IS LESS THAN RES' &
    ,'IDUAL MOISTURE CONTENT FOR CLASS ',I4,/, &
    'PROGRAM HALTED')
    jstop=6
    return
1   SE=(V-HK(I,5))/(HK(I,3)-HK(I,5))
    VSTHNVHK=HK(I,7)*(1.0D0/SE-1.0D0)**(1.0D0/HK(I,8))
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHUHK(P,I)
    !******
    !VSTHUHK
    !******
    !
    !   MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !
    !  HAVERKAMP FUNCTION
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !     include 'c_rpropsh.inc'
    VSTHUHK=HK(I,3)
    IF(P .GE. 0.0D0)RETURN
    VSTHUHK=HK(I,5)+(HK(I,3)-HK(I,5))/((P/HK(I,7))**HK(I,8)+1.0D0)
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUHK(P,I)
    !*****
    !VSHKUHK
    !****
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !  HAVERKAMP FUNCTION
    !
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    VSHKUHK=1.0D0
    IF(P.GE.0.0D0)RETURN
    VSHKUHK=1.0D0/((P/HK(I,4))**HK(I,6)+1.0D0)
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUHKH(P,TT,I)
    !*****
    !VSHKUHKH
    !*****
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !
    !  HAVERKAMP FUNCTION
    !
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    if (trans) then
        R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
        (TT+273.160D0-140.0D0)))
        VSHKUHKH=R2
    else
        VSHKUHKH = 1.0D0
    end if
    IF(P.GE.0.0D0)RETURN
    VSHKUHKH=VSHKUHKH/((P/HK(I,4))**HK(I,6)+1.0D0)
    RETURN
    END     

    SUBROUTINE INTERP (P,I)
    !******
    !INTERP
    !******
    !
    !C   THIS SUBROUTINE PERFORMS LINEAR INTERPOLATION OF PRESSURE
    !   HEADS FOR RELATIVE HYDRAULIC CONDUCTIVITY (VSHKU), VOLUMETRIC
    !   MOISTURE CONTENT (VSTHU), AND MOISTURE CAPACITY (VSDTHU).
    !
    !
    !   TO USE THIS METHOD FOR EVALUATING THE NONLINEAR FUNCTIONS,
    !   THE USER MUST ENTER A TABLE OF PRESSURE HEADS
    !   AND VALUES OF RELATIVE
    !   CONDUCTIVITIES,AND MOISTURE CONTENTS
    !   WHICH CORRESPOND TO EACH PRESSURE HEAD INTO ARRAY HK ON
    !   B-7 CARDS FOR EACH TEXTURAL CLASS.  SET NPROP (CARD B-5) EQUAL
    !   TO 3*(NUMBER OF PRESSURE HEADS IN TABLE + 1).
    !   BEGINNING WITH HK(ITEX,4), ENTER ALL PRESSURE HEADS IN DESCENDING
    !   ORDER STARTING WITH THE HIGHEST VALUE,
    !   NEXT ENTER THE NUMBER 99,
    !   NEXT ENTER THE RELATIVE HYDRAULIC
    !   CONDUCTIVITY FOR EACH PRESSURE HEAD,
    !   NEXT ENTER THE NUMBER 99,
    !   NEXT ENTER THE VOLUMETRIC MOISTURE CONTENT FOR EACH PRESSURE
    !   HEAD, FINALLY ENTER THE NUMBER 99.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    !     IF (I2.GT.0) GO TO 1
    I2=4
    DO 2 J=I2,nprop
        IF (HK(I,J).LT.99.0D0) GO TO 2
        I3=J-I2+1
        I1=I3+I3
        GO TO 1
2   CONTINUE
1   IF(HK(I,I2).LE.P) THEN
        DELPP=0.0D0
        I5=I2
        I6=I2
    ELSE
        I4=I2+I3-2
        IF(HK(I,I4).GE.P)THEN
            I5=I4-1
            I6=I4
            DELPP=0.0D0
        ELSE
            !      I4=I4-1
            DO 3 J=I2+1,I4
                IF(HK(I,J).GT.P) GO TO 3
                I5=J-1
                I6=J
                DELPP=(P-HK(I,I6))/(HK(I,I5)-HK(I,I6))
                RETURN
3           CONTINUE
        END IF
    END IF
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUTAB (P,I)
    !*****
    !VSHKUTAB
    !*****
    !
    !  RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF PRESSURE HEAD
    !  DETERMINED BY LINEAR INTERPOLATION OF KR VS HP TABLE WHICH IS
    !   INPUT BY USER.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    CALL INTERP (P,I)
    IF(I5.EQ.I6)THEN
        VSHKUTAB=HK(I,I3+I5)
        RETURN
    ELSE
        VSHKUTAB=HK(I,I3+I6)+(HK(I,I3+I5)-HK(I,I3+I6))*DELPP
        RETURN
    END IF
    END
    DOUBLE PRECISION FUNCTION VSHKUTABH (P,TT,I)
    !*****
    !VSHKUTAB
    !*****
    !
    !   RELATIVE HYDRAULIC CONDUCTIVITY AS A FUNCTION OF PRESSURE HEAD
    !  DETERMINED BY LINEAR INTERPOLATION OF KR VS HP TABLE WHICH IS
    !   INPUT BY USER.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/ &
    (TT+273.160D0-140.0D0)))
    CALL INTERP (P,I)
    IF(I5.EQ.I6)THEN
        VSHKUTABH=R2*HK(I,I3+I5)
        RETURN
    ELSE
        VSHKUTABH=HK(I,I3+I6)+(HK(I,I3+I5)-HK(I,I3+I6))*DELPP
        VSHKUTABH=VSHKUTABH*R2
        RETURN
    END IF
    END
    DOUBLE PRECISION FUNCTION VSDTHUTAB(P,I)
    !******
    !VSDTHUTAB
    !******
    !
    !   MOISTURE CAPACITY AS A FUNCTION OF PRESSURE HEAD AS
    !   DETERMINED FROM TABLE OF THETA VS HP WHICH IS INPUT
    !   BY USER.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    CALL INTERP (P,I)
    IF (I5.EQ.I6) THEN
        VSDTHUTAB=0.0D0
        RETURN
    ELSE
        VSDTHUTAB=(HK(I,I1+I5)-HK(I,I1+I6))/(HK(I,I5)-HK(I,I6))
        RETURN
    END IF
    END
    DOUBLE PRECISION FUNCTION VSTHUTAB (P,I)
    !*****
    !VSTHUTAB
    !*****
    !
    !   VOLUMETRIC MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !   AS DETERMINED BY LINEAR INTERPOLATION OF THETA VS HP TABLE
    !   WHICH IS INPUT BY USER.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/hinterp/ DELPP,nprop,I1,I2,I3,I4,I5,I6
    IF (DELPP.EQ.0.0D0) THEN
        VSTHUTAB=HK(I,I1+I6)
    ELSE
        VSTHUTAB=HK(I,I1+I6)+(HK(I,I1+I5)-HK(I,I1+I6))*DELPP
    END IF
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHNVTAB(P,I)
    !******
    !VSTHNVTAB
    !******
    !
    !     NOTE -- THIS FUNCTION IS NOT OPERATIVE WHEN USING INTERPOLATION
    !             ROUTINES.  INITIAL CONDITIONS MUST BE INPUT IN TERMS OF
    !              PRESSURE HEADS NOT MOISTURE CONTENTS.
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/JCON/JSTOP,JFLAG,jflag1
    !     include 'c_rpropsh.inc'
    WRITE(6,100)
    jstop=7
    vsthnvtab=hk(i,3)
    return
100 FORMAT(5X,'INPUT OF MOISTURE CONTENT FOR INITIAL CONDITIONS IS ', &
    'NOT ALLOWED WHEN USING TABULAR DATA '/ &
5   X,'FOR MOISTURE RETENTION AND CONDUCTIVITY CURVES',/ &
5   X,'SIMULATION TERMINATED')
    END

    DOUBLE PRECISION FUNCTION VSDTHUOT(P,I)
    !******
    !VSDTHUOT
    !******
    !     
    !  modified for Rossi-Nimmo retention curve may 2006
    !
    !    FIRST DERIVATIVE OF MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD
    !         USER-SUPPLIED FUNCTION
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    COMMON/JCON/JSTOP,JFLAG,jflag1
    vsdthuot=0.0D0
    h = -p
    if (h.le.0.0D0) then
        return
    else
        if (h.le.hk(i,7)) then
            vsdthuot = hk(i,3)*hk(i,8)*(h+h)/hk(i,4)**2.0D0
        else
            if (h.le.hk(i,10)) then
                vsdthuot = hk(i,3)*(hk(i,4)**hk(i,6))*hk(i,6)*h**(-1.0D0-hk(i,6))
            else
                vsdthuot = hk(i,3)*hk(i,9)/h
            end if
        end if
    end if
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHNVOT(V,I)
    !******
    !VSTHNVOT
    !******
    !
    !  revised for Rossi-Nimmo 
    !
    !    INITIAL UNSATURATED PRESSURE HEAD AS A FUNCTION OF VOLUMETRIC
    !    MOISTURE CONTENT
    !        USER-SUPPLIED FUNCTION

    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    vsthnvot=0.0D0
    p = V
    if (p.ge.hk(i,3)) then
        return
    else
        if (p.ge.hk(i,11)) then
            vsthnvot = -((hk(i,4)**(2.0D0))*((-p/hk(i,3) + 1.0D0)/hk(i,8)))**(.50D0)
        else
            if (p.ge.hk(i,12)) then
                vsthnvot = -(hk(i,4)**hk(i,6)*hk(i,3)/p)**(1.0D0/hk(i,6))
            else
                vsthnvot = -hk(i,5)*exp(-p/(hk(i,3)*hk(i,9)))
            end if
        end if
    end if
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSTHUOT(P,I)
    !*****
    !VSTHUOT
    !*****
    !
    !  
    !  revised for Rossi-Nimmo
    !
    !    MOISTURE CONTENT AS A FUNCTION OF PRESSURE HEAD BELOW BUBBLING
    !   PRESSURE: = POROSITY ELSEWHERE
    !        USER-SUPPLIED FUNCTION

    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    vsthuot=hk(i,3)
    h = -p
    if (h.le.0.0D0) then
        return
    else
        if (h.le.hk(i,7)) then
            vsthuot = hk(i,3)*(1.0D0 - hk(i,8)*(h/hk(i,4))**2.0D0)
        else
            if (h.le.hk(i,10)) then
                vsthuot = hk(i,3)*(hk(i,4)/h)**hk(i,6)
            else
                if (h.le.hk(i,5)) then
                    vsthuot = hk(i,3)*hk(i,9)*log(hk(i,5)/h)
                else
                    vsthuout = 0.0D0
                end if
            end if
        end if
    end if
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUOT(P,I)
    !*****
    !VSHKUOT
    !*****
    !
    !  revised for Rossi-Nimmo
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !     USER-SUPPLIED FUNCTION
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !     include 'c_rpropsh.inc'
    vshkuot=1.0D0
    if (p.ge.hk(i,3)) then
        return
    else
        r1 = p/hk(i,3)
        if (p.lt.hk(i,12)) then
            xi3 = hk(i,9)*(exp(r1/hk(i,9)) - 1.0D0)/hk(i,5)
            vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        else
            if (p.le.hk(i,11)) then
                xi3 = hk(i,18) + (r1**hk(i,14) - hk(i,15))/(hk(i,4)*hk(i,14))        
                vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
            else
                xi3 = hk(i,19) + hk(i,16)*(hk(i,17) - (1.0D0 - r1)**(.50D0))
                vshkuot = r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
            end if
        end if
    end if
    RETURN
    END
    DOUBLE PRECISION FUNCTION VSHKUOTH(P,TT,I)
    !*****
    !VSHKUOTH
    !*****
    !
    !  revised for Rossi-Nimmo
    !
    !    RELATIVE HYDRAULIC CONDUCTIVITY WITH RESPECT TO PRESSURE HEAD
    !      USER-SUPPLIED FUNCTION
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_rpropsh.inc'
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    if (trans) then
        R2=10.0D0**(247.80D0*(1.0D0/(293.160D0-140.0D0)-1.0D0/&
        (CC+273.160D0-140.0D0)))
        VSHKUoth=R2
    else
        VSHKUoth = 1.0D0
    end if
    if (p.ge.hk(i,3)) then
        return
    else
        r1 = p/hk(i,3)
        if (p.lt.hk(i,12)) then
            xi3 = hk(i,9)*(exp(r1/hk(i,9)) - 1.0D0)/hk(i,5)
            vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
        else
            if (p.le.hk(i,11)) then
                xi3 = hk(i,18) + (r1**hk(i,14) - hk(i,15))/(hk(i,4)*hk(i,14))        
                vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
            else
                xi3 = hk(i,19) + hk(i,16)*(hk(i,17) - (1.0D0 - r1)**(.50D0))
                vshkuoth = vshkuoth*r1**(0.50D0)*xi3**(2.0D0)/hk(i,13)
            end if
        end if
    end if
    RETURN
    END
    SUBROUTINE VTVELO
    !******
    !VTVELO
    !******
    !
    !    ROUTINE TO CALCULATE VELOCITIES AT BOUNDARIES OF ADJACENT CELLS
    !    VX IS VELOCITY IN X-DIRECTION BETWEEN CURRENT NODE AND NODE TO
    !    THE LEFT.
    !    VZ IS VELOCITY IN Z-DIRECTION BETWEEN CURRENT NODE AND NODE
    !    ABOVE.
    !
    use rspac
    use kcon
    use mprop
    use press
    use hcon
    use trxx
    use trxv
    use temp
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/WGT/WUS,WDS
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    IF(HEAT) then
        RHOMAX=0.0D0
    end if
    DO 10 I=2,NXRR
        N1=NLY*(I-1)
        DO 10 J=2,NLYY
            N=N1+J
            !      VX(N)=0.0D0
            !      VZ(N)=0.0D0
            IF(HX(N).NE.0.0D0) THEN
                JM1=N-1
                IM1=N-NLY
                IF(HX(JM1).NE.0.0D0) THEN
                    !
                    !   CALCULATE VERTICAL VELOCITY
                    !
                    if(ntyp(n).eq.1.and.ntyp(jm1).eq.1) then
                        vz(n) = 0.0d0
                    else
                        if(heat)then
                            RHO2=VZ(N)
                        end if
                        AREA=DXR(I)
                        IF (RAD) AREA=PI2*RX(I)*DXR(I)
                        GRAD=P(JM1)-P(N)
                        THETA1=0.5D0*(THETA(N)+THETA(JM1))*AREA
                        IF(WUS.EQ.0.0D0) THEN
                            VZ(N)=HKTT(N)*DSQRT(HCND(N)*HCND(JM1))*GRAD/THETA1
                        ELSE
                            IF(P(JM1).GT.P(N))THEN
                                ALA=WUS
                                BTA=WDS
                            ELSE
                                ALA=WDS
                                BTA=WUS
                            END IF
                            VZ(N)=HKTT(N)*(ALA*HCND(JM1)+BTA*HCND(N))*GRAD/THETA1
                        END IF
                        if(heat) then
                            RHO2=DABS(RHO2-VZ(N))
                            IF(RHO2.GT.RHOMAX) RHOMAX=RHO2
                        end if
                    END IF
                ELSE
                    VZ(N)=0.0D0
                end if
                IF(HX(IM1).NE.0.0D0) THEN
                    !
                    !   CALCULATE HORIZONTAL VELOCITY
                    !
                    if(ntyp(n).eq.1.and.ntyp(im1).eq.1) then
                        vx(n) = 0.0d0
                    else
                        if(heat)then
                            RHO2=VX(N)
                        end if  
                        GRAD=P(IM1)-P(N)
                        AREA=DELZ(J)
                        IF (RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
                        THETA1=0.5D0*(THETA(N)+THETA(IM1))*AREA
                        IF(WUS.EQ.0.0D0) THEN
                            VX(N)=HKLL(N)*DSQRT(HCND(N)*HCND(IM1))*GRAD/THETA1
                        ELSE
                            IF(P(IM1).GT.P(N)) THEN
                                ALA=WUS
                                BTA=WDS
                            ELSE
                                ALA=WDS
                                BTA=WUS
                            END IF
                            VX(N)=HKLL(N)*(ALA*HCND(IM1)+BTA*HCND(N))*GRAD/THETA1
                        END IF
                        if(heat)then
                            RHO2=DABS(RHO2-VX(N))
                            IF(RHO2.GT.RHOMAX) RHOMAX=RHO2
                        end if  
                    END IF
                ELSE
                    VX(N)=0.0D0
                END IF
            end if
10  CONTINUE
    RETURN
    END
    SUBROUTINE VTDCOEF
    !*******
    !VTDCOEF
    !******
    !
    !    ROUTINE TO CALCULATE DISPERSION COEFFICIENTS AS FUNCTIONS
    !    OF DISPERSIVITIES AND VELOCITIES.  DIAGNOL TERMS ARE
    !   CONTAINED IN ARRAYS DX1 AND DZ1.  CROSS PRODUCT TERMS
    !    ARE IN DX2 AND DZ2
    !
    use rspac
    use kcon
    use mprop
    use jtxx
    use trxv
    use rpropsh
    use trxxh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    DO 10 I=2,NXRR
        N1=NLY*(I-1)
        DO 10 J=2,NLYY
            N=N1+J
            DX1(N)=0.0D0
            DX2(N)=0.0D0
            DZ1(N)=0.0D0
            DZ2(N)=0.0D0
            PEX=0.0D0
            PEZ=0.0D0
            IMX=0
            JMX=0
            IMZ=0
            JMZ=0
            IF(HX(N).NE.0.0D0) THEN
                N2=JTEX(N)
                AL=HT(N2,1)
                AT=HT(N2,2)
                !      DM=HS(N2,3)
                V1=VX(N)
                V2=VZ(N)
                JM1=N-1
                IM1=N-NLY
                JP1=N+1
                IP1=N+NLY
                IP2=IP1-1
                IM2=IM1+1
                IF(HX(JM1).NE.0.0D0) THEN
                    V3=0.25D0*(V1+VX(IP1)+VX(IP2)+VX(JM1))
                    V32=V3*V3
                    V22=V2*V2
                    VV2=V32+V22
                    !
                    !   CALCULATE DZ1 AND DZ2
                    !
                    N2=JTEX(JM1)
                    AL1=DSQRT(AL*HT(N2,1))
                    AT1=DSQRT(AT*HT(N2,2))
                    !      DM1=DSQRT(DM*HS(N2,3))
                    DM1=0.0D0
                    AREA=DXR(I)
                    IF(RAD) AREA=PI2*AREA*RX(I)
                    T1=0.5D0*(THETA(JM1)+THETA(N))
                    DD1=(DZZ(J)-DZZ(J-1))/AREA
                    T2=T1/DD1
                    IF(VV2.EQ.0.0D0) THEN
                        DZ1(N)=DM1
                    ELSE
                        VAVE=DSQRT(VV2)
                        DL=AL1*VAVE
                        DT=AT1*VAVE
                        DZ1(N)=(DL*V22+DT*V32)/VV2
                        !C#
                        IF(HX(IP2).GT.0.0D0 .AND.HX(IP1).GT.0.0D0) THEN
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
                                DD1=(RX(I+1)-RX(I-1))/AREA
                            ELSE
                                DD1=(RX(I+1)-RX(I))/AREA
                            END IF
                        ELSE
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
                                DD1=(RX(I)-RX(I-1))/AREA
                            ELSE
                                DD1=1.0D+14
                            END IF
                        END IF
                        !C#
                        DZ2(N)=T1*(DL-DT)*V2*V3/(DD1*VV2)
                    END IF
                    !
                    ! CALCULATE VERTICAL CELL PECLET NUMBER
                    !
                    IF(DZ1(N).LE.0.0D0) THEN
                        PE=0.0D0
                    ELSE
                        PE=DABS(VZ(N))*(DZZ(J)-DZZ(J-1))/DZ1(N)
                    END IF
                    DZ1(N)=T2*DZ1(N)
                    IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(N).eq.7) THEN
                        IF(PE.GT.PEZ) THEN
                            PEZ=PE
                            IMZ=I
                            JMZ=J
                        END IF
                    END IF
                END IF
                IF(HX(IM1).NE.0.0D0) THEN
                    V3=0.25D0*(V2+VZ(JP1)+VZ(IM1)+VZ(IM2))
                    V32=V3*V3
                    V12=V1*V1
                    VV2=V12+V32
                    !
                    !   CALCULATE DX1 AND DX2
                    !
                    N2=JTEX(IM1)
                    AL1=DSQRT(AL*HT(N2,1))
                    AT1=DSQRT(AT*HT(N2,2))
                    !      DM1=DSQRT(DM*HS(N2,3))
                    DM1=0.0D0
                    AREA=DELZ(J)
                    IF(RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
                    DD1=(RX(I)-RX(I-1))/AREA
                    T1=0.5D0*(THETA(IM1)+THETA(N))
                    T2=T1/DD1
                    IF(VV2.EQ.0.0D0) THEN
                        DX1(N)=DM1
                    ELSE
                        VAVE=DSQRT(VV2)
                        DL=AL1*VAVE
                        DT=AT1*VAVE
                        DX1(N)=(DL*V12+DT*V32)/VV2
                        !C#
                        IF(HX(JP1).GT.0.0D0 .AND.HX(JP1-NLY).GT.0.0D0) THEN
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
                                DD1=(DZZ(J+1)-DZZ(J-1))/AREA
                            ELSE
                                DD1=(DZZ(J+1)-DZZ(J))/AREA
                            END IF
                        ELSE
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
                                DD1=(DZZ(J)-DZZ(J-1))/AREA
                            ELSE
                                DD1=1.0D+14
                            END IF
                        END IF
                        !C#
                        DX2(N)=T1*(DL-DT)*V1*V3/(VV2*DD1)
                    END IF
                    !C
                    !C  CALCULATE HORIZONTAL CELL PECLET NUMBER
                    !C

                    IF(DX1(N).LE.0.0D0) THEN
                        PE=0.0D0
                    ELSE
                        PE=DABS(VX(N))*(RX(I)-RX(I-1))/DX1(N)
                    END IF
                    DX1(N)=DX1(N)*T2
                    IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2.or.ntyp(N).eq.7) THEN
                        IF(PE.GT.PEX) THEN
                            PEX=PE
                            IMX=I
                            JMX=J
                        END IF
                    END IF
                END IF
            END IF
10  CONTINUE
    !
    !  WRITE MAXIMUM CELL PECLET NUMBERS
    !
    !      WRITE(6,4000) PEX,JMX,IMX,PEZ,JMZ,IMZ
    RETURN
    ! 4000 FORMAT(4X,'  MAXIMUM CELL PECLET NUMBER  --  HORIZONTAL  ',E14.5,
    !     &'     ROW ',I4,'  COLUMN ',I4,/,38X,'VERTICAL    ',E14.5,
    !     &'     ROW ',I4,'  COLUMN ',I4)
    END
    SUBROUTINE VTDCOEFSOL
    !*******
    !VTDCOEFSOL
    !*******
    !
    !   ROUTINE TO CALCULATE DISPERSION COEFFICIENTS AS FUNCTIONS
    !    OF DISPERSIVITIES AND VELOCITIES.  DIAGNOL TERMS ARE
    !   CONTAINED IN ARRAYS DX1 AND DZ1.  CROSS PRODUCT TERMS
    !    ARE IN DX2 AND DZ2
    !
    use rspac
    use kcon
    use mprop
    use jtxx
    use trxv
    use rpropsh
    use trxx
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV   
    DO 10 I=2,NXRR
        N1=NLY*(I-1)
        DO 10 J=2,NLYY
            N=N1+J
            DXS1(N)=0.0D0
            DXS2(N)=0.0D0
            DZS1(N)=0.0D0
            DZS2(N)=0.0D0
            PEXS=0.0D0
            PEZS=0.0D0
            IMX=0
            JMX=0
            IMZ=0
            JMZ=0
            IF(HX(N).NE.0.0D0) THEN
                N2=JTEX(N)
                AL=HS(N2,1)
                AT=HS(N2,2)
                DM=HS(N2,3)
                V1=VX(N)
                V2=VZ(N)
                JM1=N-1
                IM1=N-NLY
                JP1=N+1
                IP1=N+NLY
                IP2=IP1-1
                IM2=IM1+1
                IF(HX(JM1).NE.0.0D0) THEN
                    V3=0.25D0*(V1+VX(IP1)+VX(IP2)+VX(JM1))
                    V32=V3*V3
                    V22=V2*V2
                    VV2=V32+V22
                    !
                    !   CALCULATE DZ1 AND DZ2
                    !
                    N2=JTEX(JM1)
                    AL1=DSQRT(AL*HS(N2,1))
                    AT1=DSQRT(AT*HS(N2,2))
                    DM1=DSQRT(DM*HS(N2,3))
                    AREA=DXR(I)
                    IF(RAD) AREA=PI2*AREA*RX(I)
                    T1=0.5D0*(THETA(JM1)+THETA(N))
                    DD1=(DZZ(J)-DZZ(J-1))/AREA
                    T2=T1/DD1
                    IF(VV2.EQ.0.0D0) THEN
                        DZS1(N)=DM1
                    ELSE
                        VAVE=DSQRT(VV2)
                        DL=AL1*VAVE
                        DT=AT1*VAVE
                        DZS1(N)=(DL*V22+DT*V32)/VV2+DM1
                        !C#
                        IF(HX(IP2).GT.0.0D0 .AND.HX(IP1).GT.0.0D0) THEN
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
                                DD1=(RX(I+1)-RX(I-1))/AREA
                            ELSE
                                DD1=(RX(I+1)-RX(I))/AREA
                            END IF
                        ELSE
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(IM1).GT.0.0D0) THEN
                                DD1=(RX(I)-RX(I-1))/AREA
                            ELSE
                                DD1=1.0D+14
                            END IF
                        END IF
                        !      DZS2(N)=T1*(DL-DT)*V2*V3/(DD1*VV2)
                    END IF
                    !C
                    !C  CALCULATE VERTICAL CELL PECLET NUMBER
                    !C
                    IF(DZS1(N).LE.0.0D0) THEN
                        PE=0.0D0
                    ELSE
                        PE=DABS(VZ(N))*(DZZ(J)-DZZ(J-1))/DZS1(N)
                    END IF
                    DZS1(N)=T2*DZS1(N)
                    IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2) THEN
                        IF(PE.GT.PEZS) THEN
                            PEZS=PE
                            IMZ=I
                            JMZ=J
                        END IF
                    END IF
                END IF
                IF(HX(IM1).NE.0.0D0) THEN
                    V3=0.25D0*(V2+VZ(JP1)+VZ(IM1)+VZ(IM2))
                    V32=V3*V3
                    V12=V1*V1
                    VV2=V12+V32
                    !C
                    !C   CALCULATE DX1 AND DX2
                    !C
                    N2=JTEX(IM1)
                    AL1=DSQRT(AL*HS(N2,1))
                    AT1=DSQRT(AT*HS(N2,2))
                    DM1=DSQRT(DM*HS(N2,3))
                    AREA=DELZ(J)
                    IF(RAD) AREA=PI2*AREA*(RX(I)-0.5D0*DXR(I))
                    DD1=(RX(I)-RX(I-1))/AREA
                    T1=0.5D0*(THETA(IM1)+THETA(N))
                    T2=T1/DD1
                    IF(VV2.EQ.0.0D0) THEN
                        DXS1(N)=DM1
                    ELSE
                        VAVE=DSQRT(VV2)
                        DL=AL1*VAVE
                        DT=AT1*VAVE
                        DXS1(N)=(DL*V12+DT*V32)/VV2+DM1
                        !C#
                        IF(HX(JP1).GT.0.0D0 .AND.HX(JP1-NLY).GT.0.0D0) THEN
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
                                DD1=(DZZ(J+1)-DZZ(J-1))/AREA
                            ELSE
                                DD1=(DZZ(J+1)-DZZ(J))/AREA
                            END IF
                        ELSE
                            IF(HX(IM1-1).GT.0.0D0 .AND.HX(JM1).GT.0.0D0) THEN
                                DD1=(DZZ(J)-DZZ(J-1))/AREA
                            ELSE
                                DD1=1.0D+14
                            END IF
                        END IF
                        !C#
                        DXS2(N)=T1*(DL-DT)*V1*V3/(VV2*DD1)
                    END IF
                    !C
                    !C  CALCULATE HORIZONTAL CELL PECLET NUMBER
                    !C
                    IF(DXS1(N).LE.0.0D0) THEN
                        PE=0.0D0
                    ELSE
                        PE=DABS(VX(N))*(RX(I)-RX(I-1))/DXS1(N)
                    END IF
                    DXS1(N)=DXS1(N)*T2
                    IF(NTYP(N).EQ.0.OR.NTYP(N).EQ.2) THEN
                        IF(PE.GT.PEXS) THEN
                            PEXS=PE
                            IMX=I
                            JMX=J
                        END IF
                    END IF
                END IF
            END IF
10  CONTINUE 
    !
    !  WRITE MAXIMUM CELL PECLET NUMBERS
    !

    !       WRITE(6,4000) PEXS,JMX,IMX,PEZS,JMZ,IMZ
    RETURN

    ! 4000 FORMAT(4X,'  MAXIMUM CELL PECLET NUMBER  --  HORIZONTAL  ',E14.5
    !     &'     ROW ',I4,'  COLUMN ',I4,/,38X,'VERTICAL    ',E14.5,
    !     &'     ROW ',I4,'  COLUMN ',I4)
    END

    SUBROUTINE VTSETUP
    !*******
    !VTSETUP
    !*******
    !
    !    ROUTINE TO ASSEMBLE MATRIX EQUATIONS FOR ADVECTION-DISPERSION
    !    EQUATIONS AND TO CALL MATRIX SOLVER.
    !
    use press
    use rspac
    use kcon
    use mprop
    use dumm
    use disch
    use equat
    use jtxx
    use trxxh
    use trxy1
    use rpropsh
    use ptet
    use scon
    use trxv
    use temp
    use pit
    use gmres1
    use trxx, only: nctyp
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
                                          stdout=>output_unit, &
                                          stderr=>error_unit
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/JCON/JSTOP,JFLAG,jflag1
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    logical solved, pmgmres_ilu_cr

    !............................................................................
    !      

    IF(jflag1.EQ.1) THEN
        DO 10 N=1,NNODES
            AO(N)=0.0D0
            BO(N)=0.0D0
            CO(N)=0.0D0
            DO(N)=0.0D0
                EO(N)=0.0D0
10      CONTINUE
        END IF
        !
        !   INITIALIZE VARIABLES
        !
        do 50 it=1,itmax
            DO 20 I=2,NXRR
                N1=NLY*(I-1)
                DO 20 J=2,NLYY
                    N=N1+J
                    A(N)=0.0D0
                    B(N)=0.0D0
                    C(N)=0.0D0
                    D(N)=0.0D0
                    E(N)=0.0D0
                    RHS(N)=0.0D0
                    if(it.eq.1) then
                        !        TTOLD(N)=TT(N)
                        IF(NTYP(N).EQ.1) then
                            if(nit3.eq.0) dum(n) = qt(n)
                            QT(N)=VSFLX1(N)
                        else
                            qt(n) = 0.0d0
                        end if
                    end if
                    !     end if
                    IF(HX(N).NE.0.0D0) THEN
                        N2=JTEX(N)
                        !      RHO1=RHO(N)
                        RHO(N)=VTRHO(TT(N),N2)
                        !      RHO2=DABS(RHO1-RHO(N))
                        !      IF(RHO2.GT.RHOMAX)RHOMAX=RHO2
                        !      RET(N)=VTRET(CC(N),N2)
                        !      ret(n)=0.0D0
                        IM1=N-NLY
                        JM1=N-1
                        JP1=N+1
                        IP1=N+NLY
                        IP2=IP1-1
                        IM2=IM1+1
                        IM3=IM1-1
                        IP3=IP1+1
                        IF(RAD) THEN
                            AREAX=PI2*DELZ(J)*(RX(I)-0.5D0*DXR(I))
                            AREAX1=PI2*DELZ(J)*(RX(I)+0.5D0*DXR(I))
                            AREAZ=PI2*DXR(I)*RX(I)
                        ELSE
                            AREAX=DELZ(J)
                            AREAX1=AREAX
                            AREAZ=DXR(I)
                        END IF
                        areax_kt = areax
                        areax1_kt = areax1
                        areaz_kt = areaz
                        VOL=AREAZ*DELZ(J)
                        AREAX=AREAX*0.5D0*(THETA(IM1)*RHO(IM1)+THETA(N)*RHO(N))
                        AREAX1=AREAX1*0.5D0*(THETA(IP1)*RHO(IP1)+THETA(N)*RHO(N))
                        AREAZ1=AREAZ*0.5D0*(THETA(JP1)*RHO(JP1)+THETA(N)*RHO(N))
                        AREAZ=AREAZ*0.5D0*(THETA(JM1)*RHO(JM1)+THETA(N)*RHO(N))
                        !
                        !   CALCULATE LHS OF MATRIX EQUATION
                        !
                        SS=THETA(N)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
                        E(N)=-DX1(N)*(RHO(N)+RHO(IM1))-DZ1(N)*(RHO(N)+RHO(JM1))&
                        -DX1(IP1)*(RHO(N)+RHO(IP1))-DZ1(JP1)*(RHO(N)+RHO(JP1))
                        !    &-VOL*(HT(N2,4)*(THETA(N)+RET(N)))
                        E(N)=0.5D0*E(N)
                        !
                        ! CHANGE ADDED 8-12-91 TO CORRECT STORAGE TERM
                        !
                        !      SS1=HT(N2,4)*(THETA(N)+RET(N))
                        !
                        !******************
                        !  following change made 7-3-04 to correct dctheta/dt 
                        !   calculation - see written notes
                        !
                        !******************
                        !      if(jflag1.ne.1.or.ntyp(n).ne.1) then
                        !       SS=THETA(N)+SS-THLST(N)
                        !      end if
                        !******************
                        TC=THERMC(THETA(N),N2)
                        TCA=0.0D0
                        TCB=0.0D0
                        TCC=0.0D0
                        TCD=0.0D0
                        !C#
                        A(N)=DX1(N)
                        B(N)=DZ1(N)
                        C(N)=DX1(IP1)
                        D(N)=DZ1(JP1)
                        !C#TOP
                        IF(HX(IM1).NE.0.0D0) THEN
                            !c      TCA=0.5D0*(THERMC(THETA(IM1),JTEX(IM1))+TC)*DELZ(J)/
                            TCA=0.5D0*(THERMC(THETA(IM1),JTEX(IM1))+TC)*AREAX_kt/&
                            (RX(I)-RX(I-1))
                            !C#    A(N)=0.5D0*(DX1(N)*(RHO(N)+RHO(IM1))+DZ2(N)-DZ2(JP1))
                            IF(.NOT.CIS) THEN
                                IF(VX(N).GT.0.0D0) THEN
                                    A(N)=A(N)+AREAX*VX(N)
                                ELSE
                                    E(N)=E(N)+AREAX*VX(N)
                                END IF
                            ELSE
                                VV=AREAX*0.5D0*VX(N)
                                A(N)=A(N)+VV
                                E(N)=E(N)+VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DX2(N)
                            IF(HX(IM3).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
                                IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
                                    B(N)=B(N)+TEMPP
                                    D(N)=D(N)-TEMPP
                                    RHS(N)=RHS(N)+TEMPP*(TT(IM2)-TT(IM3))
                                ELSE
                                    A(N)=A(N)-TEMPP
                                    B(N)=B(N)+TEMPP
                                    E(N)=E(N)-TEMPP
                                    RHS(N)=RHS(N)-TEMPP*TT(IM3)
                                END IF
                            ELSE
                                IF(HX(IM2).GT.0.0D0.AND.HX(JP1).GT.0.0D0) THEN
                                    A(N)=A(N)+TEMPP
                                    D(N)=D(N)-TEMPP
                                    E(N)=E(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*TT(IM2)
                                END IF
                                !C#
                            END IF
                        END IF
                        !c# Left      
                        IF(HX(JM1).NE.0.0D0) THEN
                            !c      TCB=0.5D0*(THERMC(THETA(JM1),JTEX(JM1))+TC)*DXR(I)/
                            TCB=0.5D0*(THERMC(THETA(JM1),JTEX(JM1))+TC)*AREAZ_kt/&
                            (DZZ(J)-DZZ(J-1))
                            !C#    B(N)=0.5D0*(DZ1(N)*(RHO(N)+RHO(JM1))+DX2(N)-DX2(IP1))
                            IF(.NOT.CIS) THEN
                                IF(VZ(N).GT.0.0D0) THEN
                                    B(N)=B(N)+AREAZ*VZ(N)
                                ELSE
                                    E(N)=E(N)+AREAZ*VZ(N)
                                END IF
                            ELSE
                                VV=0.5D0*AREAZ*VZ(N)
                                B(N)=B(N)+VV
                                E(N)=E(N)+VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DZ2(N)
                            IF(HX(IP2).GT.0.0D0.AND.HX(IP1).GT.0.0D0) THEN
                                IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
                                    A(N)=A(N)+TEMPP
                                    C(N)=C(N)-TEMPP
                                    RHS(N)=RHS(N)+TEMPP*(TT(IP2)-TT(IM3))
                                ELSE
                                    B(N)=B(N)+TEMPP
                                    C(N)=C(N)-TEMPP
                                    E(N)=E(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*TT(IP2)
                                END IF
                            ELSE
                                IF(HX(IM3).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
                                    A(N)=A(N)+TEMPP
                                    B(N)=B(N)-TEMPP
                                    E(N)=E(N)-TEMPP
                                    RHS(N)=RHS(N)-TEMPP*TT(IM3)
                                END IF
                            END IF
                            !C#
                        END IF
                        !C# BOTTOM      
                        IF(HX(IP1).NE.0.0D0) THEN
                            !c      TCC=0.5D0*(THERMC(THETA(IP1),JTEX(IP1))+TC)*DELZ(J)/
                            TCC=0.5D0*(THERMC(THETA(IP1),JTEX(IP1))+TC)*AREAX1_kt/&
                            (RX(I+1)-RX(I))
                            !C#    C(N)=0.5D0*(DX1(IP1)*(RHO(N)+RHO(IP1))-DZ2(N)+DZ2(JP1))
                            IF(.NOT.CIS) THEN
                                IF(VX(IP1).LT.0.0D0) THEN
                                    C(N)=C(N)-AREAX1*VX(IP1)
                                ELSE
                                    E(N)=E(N)-AREAX1*VX(IP1)
                                END IF
                            ELSE
                                VV=0.5D0*AREAX1*VX(IP1)
                                C(N)=C(N)-VV
                                E(N)=E(N)-VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DX2(IP1)
                            IF(HX(JP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
                                IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
                                    B(N)=B(N)-TEMPP
                                    D(N)=D(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*(TT(IP2)-TT(IP3))
                                ELSE
                                    C(N)=C(N)-TEMPP
                                    D(N)=D(N)+TEMPP
                                    E(N)=E(N)-TEMPP
                                    RHS(N)=RHS(N)-TEMPP*TT(IP3)
                                END IF
                            ELSE
                                IF(HX(IP2).GT.0.0D0.AND.HX(JM1).GT.0.0D0) THEN
                                    B(N)=B(N)-TEMPP
                                    C(N)=C(N)+TEMPP
                                    E(N)=E(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*TT(IP2)
                                END IF
                            END IF
                            !#
                        END IF
                        !C# RIGHT      
                        IF(HX(JP1).NE.0.0D0) THEN
                            !c      TCD=0.5D0*(THERMC(THETA(JP1),JTEX(JP1))+TC)*DXR(I)/
                            TCD=0.5D0*(THERMC(THETA(JP1),JTEX(JP1))+TC)*AREAZ_kt/&
                            (DZZ(J+1)-DZZ(J))
                            !C#    D(N)=0.5D0*(DZ1(JP1)*(RHO(N)+RHO(JP1))-DX2(N)+DX2(IP1))
                            IF(.NOT.CIS) THEN
                                IF(VZ(JP1).LT.0.0D0) THEN
                                    D(N)=D(N)-AREAZ1*VZ(JP1)
                                ELSE
                                    E(N)=E(N)-AREAZ1*VZ(JP1)
                                END IF
                            ELSE
                                VV=0.5D0*AREAZ1*VZ(JP1)
                                D(N)=D(N)-VV
                                E(N)=E(N)-VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DZ2(JP1)
                            IF(HX(IM2).GT.0.0D0.AND.HX(IM1).GT.0.0D0) THEN
                                IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
                                    A(N)=A(N)-TEMPP
                                    C(N)=C(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*(TT(IM2)-TT(IP3))
                                ELSE
                                    A(N)=A(N)-TEMPP
                                    D(N)=D(N)+TEMPP
                                    E(N)=E(N)+TEMPP
                                    RHS(N)=RHS(N)+TEMPP*TT(IM2)
                                END IF
                            ELSE
                                IF(HX(IP1).GT.0.0D0.AND.HX(IP3).GT.0.0D0) THEN
                                    C(N)=C(N)+TEMPP
                                    D(N)=D(N)-TEMPP
                                    E(N)=E(N)-TEMPP
                                    RHS(N)=RHS(N)-TEMPP*TT(IP3)
                                END IF
                            END IF
                            !C#
                        END IF
                        !      IF(Q(N).LT.0.) E(N)=E(N)+Q(N)*RHO(N)
                        IF(QQ(N).LT.0.0D0) E(N)=E(N)+QQ(N)*RHO(N)
                        IF(QT(N).GT.0.0D0) E(N)=E(N)-QT(N)
                        !C
                        !C  CENTERED-IN-TIME DIFFERENCING CAN BE USED ONLY AFTER THE
                        !C  FIRST TIME STEP IN ANY RECHARGE PERIOD.
                        !C
                        RHS(N) = RHS(N)*HT(N2,6)
                        IF(CIT.AND.JFLAG1.NE.1) THEN
                            FACT=0.5D0*HT(N2,6)
                            FACT1=0.5D0
                        ELSE
                            FACT=HT(N2,6)
                            FACT1=1.
                        END IF
                        A(N)=FACT*A(N)+FACT1*TCA
                        B(N)=FACT*B(N)+FACT1*TCB
                        C(N)=FACT*C(N)+FACT1*TCC
                        D(N)=FACT*D(N)+FACT1*TCD
                        E(N)=FACT*E(N)+fact1*(-TCA-TCB-TCC-TCD)
                        !c      END IF
                        E(N)=E(N)-VOL*(((THETA(N)+SS)*RHO(N)*HT(N2,6)+HT(N2,3))/DELT)
                    end if
                    !c
                    !c  above end if moved here 12/2010
                    !c
20          CONTINUE
            !C
            !C  BEGIN LOOP TO CALCULATE RHS AND CALL MATRIX SOLVER
            !C
            DO 30 I=2,NXRR
                N1=NLY*(I-1)
                DO 30 J=2,NLYY
                    N=N1+J
                    IM1=N-NLY
                    JM1=N-1
                    JP1=N+1
                    IP1=N+NLY
                    IP2=IP1-1
                    IM2=IM1+1
                    IM3=IM1-1
                    IP3=IP1+1
                    IF(RAD) THEN
                        VOL=PI2*DELZ(J)*DXR(I)*RX(I)
                    ELSE
                        VOL=DELZ(J)*DXR(I)
                    END IF
                    N2=JTEX(N)

                    if (ntyp(n).eq.1) then
                        RHS(N)=RHS(N)-VOL*(THETA(N)*RHO(N)*HT(N2,6)+HT(N2,3))&
                        *TTOLD(N)/DELT&
                        -A(N)*TT(IM1)-B(N)*TT(JM1)&
                        -C(N)*TT(IP1)-D(N)*TT(JP1)-E(N)*TT(N)
                    else
                        RHS(N)=RHS(N)-VOL*(THLST(N)*RHO(N)*HT(N2,6)+HT(N2,3))&
                        *TTOLD(N)/DELT&
                        -A(N)*TT(IM1)-B(N)*TT(JM1)&
                        -C(N)*TT(IP1)-D(N)*TT(JP1)-E(N)*TT(N)
                    end if
                    !#
                    IF (CIT.AND.JFLAG1.NE.1) RHS(N)=RHS(N)-AO(N)*TTOLD(IM1)-BO(N)&
                    *TTOLD(JM1)-CO(N)*TTOLD(IP1)-DO(N)*TTOLD(JP1)-EO(N)*TTOLD(N)
                    IF(QQ(N).GT.0.0D0.and.ntyp(n).ne.1) RHS(N)=RHS(N)-QQ(N)*TS(N)&
                    *RHO(N)*HT(N2,6)
                    IF(QT(N).LT.0.0D0.AND.NHTYP(N).EQ.0) then
                        if(cit.and.jflag1.ne.1) then
                            RHS(N)=RHS(N)+0.5d0*(dum(n)+QT(N))*TS(N)*HT(N2,6)
                        else
                            rhs(n) = rhs(n) + qt(n)*TS(n)*ht(n2,6)
                        end if
                    end if
                    IF(QT(N).LE.0.0D0.AND.NHTYP(N).EQ.2) RHS(N)=RHS(N)-TS(N)
30          CONTINUE
            NIT1=NIT1+1
            !
            !   CALL MATRIX SOLVER
            !
            !use_gmres_heat = .false.
            if (.not. use_gmres_heat) then
                CALL SLVSIP
            else  
                !   installing gmress solver. No need for iterating on heat equation
                !    first step is to move coefficients into storate gmres storage
                !    arrays. We need to reorder nodes, numbering only the active
                !    nodes.
                ! 
                !ia_gmr = 0
                !ja_gmr = 0
                !a_gmr = 0.0d0
                !xi = 0.0d0
                !rhs_gmr = 0.0d0
                n_order = 0
                nz_num = 0
                nly2 = nly - 2
                DO 300 I=2,NXRR
                    N1=NLY*(I-1)
                    DO 300 J=2,NLYY
                        N=N1+J
                        if(hx(n).eq.0.0d0.or.nhtyp(n).eq.1) then
                            n_order = n_order + 1
                            nz_num = nz_num + 1
                            a_gmr(nz_num) = 1.0d0
                            !       ia_gmr(nz_num) = n_order
                            ia_gmr(n_order) = nz_num
                            ja_gmr(nz_num) = n_order
                            rhs_gmr(n_order) = 0.0d0
                            xi(n_order) = 0.0d0
                        else
                            n_order = n_order + 1
                            nz_num = nz_num + 1
                            a_gmr(nz_num) = e(n)
                            !       ia_gmr(nz_num) = n_order
                            ia_gmr(n_order) = nz_num
                            ja_gmr(nz_num) = n_order
                            rhs_gmr(n_order) = rhs(n)
                            xi(n_order) = 0.0d0      
                            if(a(n).ne.0.0d0) then
                                nz_num = nz_num + 1
                                a_gmr(nz_num) = a(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order - nly2
                            end if
                            if(b(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = b(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order - 1
                            end if
                            if(c(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = c(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order +  nly2
                            end if
                            if(d(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = d(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order + 1
                            end if
                        end if
300             continue
                ia_gmr(n_order+1) = nz_num + 1
                itmax1 = itmax/10
                !      mr = n_order - 1
                !      mr = 200
                mr = MIN0(20,n_order-1)
                !call pmgmres_ilu_cr ( n, nz_num, ia, ja, a, x, rhs, itr_max, mr, &
                !   tol_abs, tol_rel )
                solved = pmgmres_ilu_cr ( n_order, nz_num, ia_gmr, ja_gmr, a_gmr, xi, rhs_gmr, itmax1, mr, &
                    eps2, eps2 )
                if (solved) then
                    n_order = 0
                    DO 301 I=2,NXRR
                        N1=NLY*(I-1)
                        DO 301 J=2,NLYY
                            N=N1+J
                            n_order = n_order + 1
                            if(hx(n).ne.0.0d0.and.nhtyp(n).ne.1) then
                                tt(n) = tt(n) + xi(n_order)
                            end if
301                 continue
                    ITEST = 0
                else
                    JSTOP=10
                    JFLAG=1
                    write(stderr,*) 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR HEAT'&
                        ,' TRANSPORT EQUATION '
                    WRITE(6,4000)
                    RETURN
                endif
            endif
            IF(ITEST.EQ.0) THEN
                if (it > itmax/2) write(stderr,*) '***Heat iterations: ', it
                write(stderr,*) "  Done with heat."
                RETURN
            END IF
50      CONTINUE
        WRITE(6,4000)
        IF (.NOT.ITSTOP) RETURN
        JSTOP=10
        JFLAG=1
        write(stderr,*) 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR HEAT '&
            ,' TRANSPORT EQUATION'
        !        WRITE(6,4010)
        RETURN
4000    FORMAT(' MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR HEAT TRANSPORT'&
        ,' EQUATION')
4010    FORMAT(' Simulation terminated')
    END
    SUBROUTINE VTSETUPSOL
    !*******
    !VTSETUPSOL
    !*******
    !
    !    ROUTINE TO ASSEMBLE MATRIX EQUATIONS FOR ADVECTION-DISPERSION
    !    EQUATIONS AND TO CALL MATRIX SOLVER.
    !
    use press
    use rspac
    use kcon
    use mprop
    use dumm
    use disch
    use equats
    use jtxx
    use trxx
    use trxy2
    use rpropsh
    use scon
    use trxv
    use temp
    use pit
    use ptet
    use tempcc
    use COMPNAM
    use react
    use gmres1
    use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, &
        stdout=>output_unit, &
        stderr=>error_unit
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    COMMON/JCON/JSTOP,JFLAG,jflag1
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    COMMON/TCON1/NIS,NIS1,NIS3
    COMMON/SCON1/ITESTS
    COMMON/JCONF/JFLAG2
    logical solved, pmgmres_ilu_cr
    !
    !...........................................................................
    !
    call VTSETUPSOL_PARALLEL
    return
    do 60 M=1,Nsol
        NIS1=0

        IF(jflag2.EQ.1) THEN
            DO 10 N=1,NNODES
                AOC(N)=0.0D0
                BOC(N)=0.0D0
                COC(N)=0.0D0
                DOC(N)=0.0D0
                EOC(N)=0.0D0
10          CONTINUE
        END IF
        !
        !   INITIALIZE VARIABLES
        !
        do 50 it=1,itmax
            DO 20 I=2,NXRR
                N1=NLY*(I-1)
                DO 20 J=2,NLYY
                    N=N1+J
                    AS(N)=0.0D0
                    BS(N)=0.0D0
                    CS(N)=0.0D0
                    DS(N)=0.0D0
                    ES(N)=0.0D0
                    RHSS(N)=0.0D0
                    if(it.eq.1) then
                        CCOLD(M,N)=CC(M,N)
                        IF(NTYP(N).EQ.1) then
                            dum(n) = qs(n)
                            QS(N)=VSFLX1(N)
                        else
                            qs(n) = 0.0d0
                        end if
                    end if
                    TempC(N)=CC(M,N)
                    !      WRITE(6,*)'TempC Before ########### ',M
                    !     CALL VSOUTS(1,TempC(N))
                    IF(HX(N).NE.0.0D0) THEN
                        N2=JTEX(N)
                        !      RHO1=RHO(N)
                        !      RHO(N)=VTRHO(CC(N),N2)
                        !      RHO2=DABS(RHO1-RHO(N))
                        !      IF(RHO2.GT.RHOMAX)RHOMAX=RHO2
                        !      RET(N)=VTRET(CC(N),N2)
                        !      ret(n)=0.0D0
                        IM1=N-NLY
                        JM1=N-1
                        JP1=N+1
                        IP1=N+NLY
                        IP2=IP1-1
                        IM2=IM1+1
                        IM3=IM1-1
                        IP3=IP1+1
                        IF(RAD) THEN
                            AREAX=PI2*DELZ(J)*(RX(I)-0.5D0*DXR(I))
                            AREAX1=PI2*DELZ(J)*(RX(I)+0.5D0*DXR(I))
                            AREAZ=PI2*DXR(I)*RX(I)
                        ELSE
                            AREAX=DELZ(J)
                            AREAX1=AREAX
                            AREAZ=DXR(I)
                        END IF
                        VOL=AREAZ*DELZ(J)
                        AREAX=AREAX*0.5D0*(THETA(IM1)+THETA(N))
                        AREAX1=AREAX1*0.5D0*(THETA(IP1)+THETA(N))
                        AREAZ1=AREAZ*0.5D0*(THETA(JP1)+THETA(N))
                        AREAZ=AREAZ*0.5D0*(THETA(JM1)+THETA(N))
                        !
                        !   CALCULATE LHS OF MATRIX EQUATION
                        !
                        SS=THETA(N)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
                        ES(N)=-DXS1(N)-DZS1(N)-DXS1(IP1)-DZS1(JP1)
                        !   &-VOL*(HT(N2,4)*(THETA(N)+RET(N)))
                        !
                        !  CHANGE ADDED 8-12-91 TO CORRECT STORAGE TERM
                        !
                        !      SS1=HT(N2,4)*(THETA(N)+RET(N))
                        !
                        !c******************
                        !  following change made 7-3-04 to correct dctheta/dt
                        !   calculation - see written notes
                        !
                        !******************
                        !      if(jflag1.ne.1.or.ntyp(n).ne.1) then
                        !       SS=THETA(N)+SS-THLST(N)
                        !     end if
                        !******************

                        !C#
                        AS(N)=DXS1(N)
                        BS(N)=DZS1(N)

                        CS(N)=DXS1(IP1)
                        DS(N)=DZS1(JP1)
                        !C#    TOP(n,j-1)
                        IF(HX(IM1).NE.0.0D0) THEN
                            !C#    A(N)=0.5D0*(DX1(N)*(RHO(N)+RHO(IM1))+DZ2(N)-DZ2(JP1))
                            IF(.NOT.CIS) THEN
                                IF(VX(N).GT.0.0D0) THEN
                                    AS(N)=AS(N)+AREAX*VX(N)
                                ELSE
                                    ES(N)=ES(N)+AREAX*VX(N)
                                END IF
                            ELSE
                                VV=AREAX*0.5D0*VX(N)
                                AS(N)=AS(N)+VV
                                ES(N)=ES(N)+VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DXS2(N)
                            IF(HX(IM3).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
                                IF(HX(IM2).GT.0.0D0 .AND. HX(JP1).GT.0.0D0) THEN
                                    BS(N)=BS(N)+TEMPP
                                    DS(N)=DS(N)-TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*(CC(M,IM2)-CC(M,IM3))
                                ELSE
                                    AS(N)=AS(N)-TEMPP
                                    BS(N)=BS(N)+TEMPP
                                    ES(N)=ES(N)-TEMPP
                                    RHSS(N)=RHSS(N)-TEMPP*CC(M,IM3)
                                END IF
                            ELSE
                                IF(HX(IM2).GT.0.0D0 .AND. HX(JP1).GT.0.0D0) THEN
                                    AS(N)=AS(N)+TEMPP
                                    DS(N)=DS(N)-TEMPP
                                    ES(N)=ES(N)+TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*CC(M,IM2)
                                END IF
                                !C#
                            END IF
                        END IF

                        !C#    left (n-1,j)
                        IF(HX(JM1).NE.0.0D0) THEN
                            !C#    B(N)=0.5D0*(DZ1(N)*(RHO(N)+RHO(JM1))+DX2(N)-DX2(IP1))
                            IF(.NOT.CIS) THEN
                                IF(VZ(N).GT.0.0D0) THEN
                                    BS(N)=BS(N)+AREAZ*VZ(N)
                                ELSE
                                    ES(N)=ES(N)+AREAZ*VZ(N)
                                END IF
                            ELSE
                                VV=0.5D0*AREAZ*VZ(N)
                                BS(N)=BS(N)+VV
                                ES(N)=ES(N)+VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DZS2(N)
                            IF(HX(IP2).GT.0.0D0 .AND. HX(IP1).GT.0.0D0) THEN
                                IF(HX(IM3).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
                                    AS(N)=AS(N)+TEMPP
                                    CS(N)=CS(N)-TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*(CC(M,IP2)-CC(M,IM3))
                                ELSE
                                    BS(N)=BS(N)+TEMPP
                                    CS(N)=CS(N)-TEMPP
                                    ES(N)=ES(N)+TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*CC(M,IP2)
                                END IF
                            ELSE
                                IF(HX(IM3).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
                                    AS(N)=AS(N)+TEMPP
                                    BS(N)=BS(N)-TEMPP
                                    ES(N)=ES(N)-TEMPP
                                    RHSS(N)=RHSS(N)-TEMPP*CC(M,IM3)
                                END IF
                            END IF
                            !C#
                        END IF

                        !C#  Bottom (n,j+1)
                        IF(HX(IP1).NE.0.0D0) THEN
                            !C#    C(N)=0.5D0*(DX1(IP1)*(RHO(N)+RHO(IP1))-DZ2(N)+DZ2(JP1))
                            IF(.NOT.CIS) THEN
                                IF(VX(IP1).LT.0.0D0) THEN
                                    CS(N)=CS(N)-AREAX1*VX(IP1)
                                ELSE
                                    ES(N)=ES(N)-AREAX1*VX(IP1)
                                END IF
                            ELSE
                                VV=0.5D0*AREAX1*VX(IP1)
                                CS(N)=CS(N)-VV
                                ES(N)=ES(N)-VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DXS2(IP1)
                            IF(HX(JP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
                                IF(HX(IP2).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
                                    BS(N)=BS(N)-TEMPP
                                    DS(N)=DS(N)+TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*(CC(M,IP2)-CC(M,IP3))
                                ELSE
                                    CS(N)=CS(N)-TEMPP
                                    DS(N)=DS(N)+TEMPP
                                    ES(N)=ES(N)-TEMPP
                                    RHSS(N)=RHSS(N)-TEMPP*CC(M,IP3)
                                END IF
                            ELSE
                                IF(HX(IP2).GT.0.0D0 .AND. HX(JM1).GT.0.0D0) THEN
                                    BS(N)=BS(N)-TEMPP
                                    CS(N)=CS(N)+TEMPP
                                    ES(N)=ES(N)+TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*CC(M,IP2)
                                END IF
                            END IF
                            !C#
                        END IF

                        !C#  right (n+1,j)
                        IF(HX(JP1).NE.0.0D0) THEN
                            !C#    D(N)=0.5D0*(DZ1(JP1)*(RHO(N)+RHO(JP1))-DX2(N)+DX2(IP1))
                            IF(.NOT.CIS) THEN
                                IF(VZ(JP1).LT.0.0D0) THEN
                                    DS(N)=DS(N)-AREAZ1*VZ(JP1)
                                ELSE
                                    ES(N)=ES(N)-AREAZ1*VZ(JP1)
                                END IF
                            ELSE
                                VV=0.5D0*AREAZ1*VZ(JP1)
                                DS(N)=DS(N)-VV
                                ES(N)=ES(N)-VV
                            END IF
                            !C#
                            TEMPP=0.5D0*DZS2(JP1)
                            IF(HX(IM2).GT.0.0D0 .AND. HX(IM1).GT.0.0D0) THEN
                                IF(HX(IP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
                                    AS(N)=AS(N)-TEMPP
                                    CS(N)=CS(N)+TEMPP
                                    !     CALL VSOUTS(1,TempC(N))
                                    RHSS(N)=RHSS(N)+TEMPP*(CC(M,IM2)-CC(M,IP3))
                                ELSE
                                    AS(N)=AS(N)-TEMPP
                                    DS(N)=DS(N)+TEMPP
                                    ES(N)=ES(N)+TEMPP
                                    RHSS(N)=RHSS(N)+TEMPP*CC(M,IM2)
                                END IF
                            ELSE
                                IF(HX(IP1).GT.0.0D0 .AND. HX(IP3).GT.0.0D0) THEN
                                    CS(N)=CS(N)+TEMPP
                                    DS(N)=DS(N)-TEMPP
                                    ES(N)=ES(N)-TEMPP
                                    RHSS(N)=RHSS(N)-TEMPP*CC(M,IP3)
                                END IF
                            END IF
                            !C#
                        END IF
                        if (NPV.ge.0) then
                            IF(Q(N).LT.0.0D0 .AND. NTYP(N) .NE. 5) ES(N)=ES(N)+Q(N)
                        end if
                        IF(QQ(N).LT.0.0D0) ES(N)=ES(N)+QQ(N)
                        IF(QS(N).GT.0.0D0) ES(N)=ES(N)-QS(N)
                        !C
                        !C  CENTERED-IN-TIME DIFFERENCING CAN BE USED ONLY AFTER THE
                        !C  FIRST TIME STEP IN ANY RECHARGE PERIOD.
                        !C

                        IF(CIT.AND.JFLAG2.NE.1) THEN
                            AS(N)=0.5D0*AS(N)
                            BS(N)=0.5D0*BS(N)
                            CS(N)=0.5D0*CS(N)
                            DS(N)=0.5D0*DS(N)
                            ES(N)=0.5D0*ES(N)
                        END IF
                        ES(N)=ES(N)-VOL*(THETA(N)+SS)/DELT
                    END IF
20          CONTINUE
            !     WRITE(6,*)'TempC Before ########### ',M
            !     CALL VSOUTS(1,TempC(N))

            !
            !  BEGIN LOOP TO CALCULATE RHS AND CALL MATRIX SOLVER
            !

            DO 30 I=2,NXRR
                N1=NLY*(I-1)
                DO 30 J=2,NLYY
                    N=N1+J
                    IM1=N-NLY
                    JM1=N-1
                    JP1=N+1
                    IP1=N+NLY
                    IP2=IP1-1
                    IM2=IM1+1
                    IM3=IM1-1
                    IP3=IP1+1
                    IF(RAD) THEN
                        VOL=PI2*DELZ(J)*DXR(I)*RX(I)
                    ELSE
                        VOL=DELZ(J)*DXR(I)
                    END IF
                    N2=JTEX(N)

                    if (ntyp(n).eq.1) then
                        RHSS(N)=RHSS(N)-VOL*THETA(N)*CCOLD(M,N)/DELT-AS(N)*CC(M,IM1)&
                            -BS(N)*CC(M,JM1)-CS(N)*CC(M,IP1)-DS(N)*CC(M,JP1)-ES(N)*CC(M,N)
                    else
                        RHSS(N)=RHSS(N)-VOL*THLST(N)*CCOLD(M,N)/DELT-AS(N)*CC(M,IM1)&
                            -BS(N)*CC(M,JM1)-CS(N)*CC(M,IP1)-DS(N)*CC(M,JP1)-ES(N)*CC(M,N)
                    end if
                    !C#
                    IF (CIT.AND.JFLAG2.NE.1) RHSS(N)=RHSS(N)-AOC(N)*CCOLD(M,IM1)&
                        -BOC(N)*CCOLD(M,JM1)-COC(N)*CCOLD(M,IP1)-DOC(N)*CCOLD(M,JP1)&
                        -EOC(N)*CCOLD(M,N)
                    IF(QQ(N).GT.0.0D0 .and. ntyp(n).ne.1) then
                        RHSS(N)=RHSS(N)-QQ(N)*CSS(M,N)
                    endif

                    IF(QS(N).LT.0.0D0 .AND. NCTYP(N).EQ.0) then
                        if(cit.and.jflag2.ne.1) then
                            RHSS(N)=RHSS(N)+0.5d0*(QS(N)+dum(n))*CSS(M,N)
                        else
                            RHSS(N) = RHSS(N)+ QS(N)*CSS(M,N)
                        end if
                    end if
                    IF(QS(N).LE.0.0D0 .AND.NCTYP(N).EQ.2)RHSS(N)=RHSS(N)-CSS(M,N)

30          CONTINUE

            NIS1=NIS1+1
            !
            !   CALL MATRIX SOLVER
            !
            if (.not. use_gmres_solute) then
                CALL SLVSIPSOL
                DO 31 I=2,NXRR
                    N1=NLY*(I-1)
                    DO 31 J=2,NLYY
                        N=N1+J
                        CC(M,N)=TempC(N)
31              CONTINUE
            else
                !   installing gmress solver. No need for iterating on solute equation
                !    first step is to move coefficients into storate gmres storage
                !    arrays. We need to reorder nodes.
                !
                ITESTS = 1
                ia_gmr = 0
                ja_gmr = 0
                a_gmr = 0.0d0
                xis = 0.0d0
                rhs_gmr = 0.0d0
                n_order = 0
                nz_num = 0
                nly2 = nly - 2
                DO 300 I=2,NXRR
                    N1=NLY*(I-1)
                    DO 300 J=2,NLYY
                        N=N1+J
                        if(hx(n).eq.0.0d0.or.nctyp(n).eq.1) then
                            n_order = n_order + 1
                            nz_num = nz_num + 1
                            a_gmr(nz_num) = 1.0d0
                            !       ia_gmr(nz_num) = n_order
                            ia_gmr(n_order) = nz_num
                            ja_gmr(nz_num) = n_order
                            rhs_gmr(n_order) = 0.0d0
                            xis(n_order) = 0.0d0
                        else
                            n_order = n_order + 1
                            nz_num = nz_num + 1
                            a_gmr(nz_num) = es(n)
                            !       ia_gmr(nz_num) = n_order
                            ia_gmr(n_order) = nz_num
                            ja_gmr(nz_num) = n_order
                            rhs_gmr(n_order) = rhss(n)
                            xis(n_order) = 0.0d0
                            if(as(n).ne.0.0d0) then
                                nz_num = nz_num + 1
                                a_gmr(nz_num) = as(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order - nly2
                            end if
                            if(bs(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = bs(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order - 1
                            end if
                            if(cs(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = cs(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order +  nly2
                            end if
                            if(ds(n).ne.0.0d0) then
                                nz_num = nz_num +1
                                a_gmr(nz_num) = ds(n)
                                !         ia_gmr(nz_num) = n_order
                                ja_gmr(nz_num) = n_order + 1
                            end if
                        end if
300             continue
                ia_gmr(n_order+1) = nz_num + 1
                itmax1 = itmax/10
                !      mr = n_order - 1
                !      mr = 200
                mr = MIN0(20,n_order-1)
                solved = pmgmres_ilu_cr ( n_order, nz_num, ia_gmr, ja_gmr, a_gmr, xis, rhs_gmr, itmax1, mr, &
                    eps3, eps3 )
                if(solved) then
                    n_order = 0
                    DO 301 I=2,NXRR
                        N1=NLY*(I-1)
                        DO 301 J=2,NLYY
                            N=N1+J
                            n_order = n_order + 1
                            if(hx(n).ne.0.0d0.and.nctyp(n).ne.1) then
                                cc(m,n) = cc(m,n) + xis(n_order)
                            end if
301                 continue
                    ITESTS = 0
                    write(stderr,*) "    ", compname(m)
                else
                    JSTOP=10
                    JFLAG=1
                    write(stderr,*) 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR SOLUTE'&
                        ,' TRANSPORT EQUATION '
                    WRITE(6,4000)
                    RETURN
                endif
            endif


            !C      WRITE(6,*)'TempC After ########### ',M
            !      CALL VSOUTS(1,TempC(N))
            IF(ITESTS.EQ.0) THEN
                IF (CIT) THEN
                    DO 40 I=2,NXRR
                        N1=NLY*(I-1)
                        DO 40 J=2,NLYY
                            N=N1+J
                            IF(HX(N).EQ.0.0D0) GO TO 40
                            if(nctyp(n).ne.1) then
                                AOC(N)=AS(N)
                                BOC(N)=BS(N)
                                COC(N)=CS(N)
                                DOC(N)=DS(N)
                            end if
                            IF(RAD) THEN
                                AREAZ=PI2*DXR(I)*RX(I)
                            ELSE
                                AREAZ=DXR(I)
                            END IF
                            VOL=AREAZ*DELZ(J)
                            N2=JTEX(N)
                            SS=theta(n)*(P(N)-PXXX(N))*HK(N2,2)/HK(N2,3)
                            !
                            !  CHANGE 8-12-91 FOR STORAGE
                            !
                            !      SS1=HT(N2,4)*(THETA(N)+RET(N))
                            !
                            !****************
                            !c  following change made 7-3-04 to correct dctheta/dt
                            !   calculation
                            !
                            !****************
                            !      if(jflag1.ne.1.or.ntyp(n).ne.1) then
                            !       SS=THETA(N)+SS-THLST(N)
                            !      end if
                            !****************
                            EOC(N)=ES(N)+VOL*(THETA(N)+SS)/DELT
                            IF(JFLAG1.EQ.1) THEN
                                if(nctyp(n).ne.1) then
                                    AOC(N)=0.5D0*AOC(N)
                                    BOC(N)=0.5D0*BOC(N)
                                    COC(N)=0.5D0*COC(N)
                                    DOC(N)=0.5D0*DOC(N)
                                end if
                                EOC(N)=0.5D0*EOC(N)
                            END IF
40                  CONTINUE
                END IF
                if (it > itmax/2) write(stderr,*) '***Solute iterations: ', it, compname(m)
                go to 60
            END IF

50      CONTINUE        
        WRITE(6,4000)
        IF (.NOT.ITSTOP) GO TO 60
        JSTOP=10
        JFLAG=1
        write(stderr,*) 'ERROR: MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR SOLUTE'&
        ,' TRANSPORT EQUATION '
        WRITE(6,4000)
        RETURN
60  CONTINUE 
    RETURN
4000 FORMAT('MAXIMUM NUMBER OF ITERATIONS EXCEEDED FOR SOLUTE '&
    ,' TRANSPORT EQUATION')
4010 FORMAT(' Simulation terminated')
    END
    DOUBLE PRECISION FUNCTION VTRHO(TT,I)
    !*****
    !VTRHO
    !*****
    !
    ! DENSITY AS A FUNCTION OF TEMPERATURE CC
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_rpropsh.inc'
    !c      VTRHO=HT(I,6)+HT(I,8)*(CC-HT(I,7))
    vtrho=1.0D0
    RETURN
    END
    DOUBLE PRECISION FUNCTION THERMC(TT,I)
    !*****
    !THERMC
    !*****
    !
    ! THERMAL CONDUCTIVITY AS FUNCTION OF THETA
    !
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    integer hydraulicFunctionType
    common/functiontype/ hydraulicFunctionType
    !c      include 'c_rpropsh.inc'
    if (hydraulicFunctionType.lt.3) then
        T1=HK(I,5)
    else
        T1 = 0.d0
    end if
    T2=HK(I,3)
    IF(TT.LE.T1) THEN
        THERMC=HT(I,4)
    ELSE
        IF(TT.GE.HK(I,3)) THEN
            THERMC=HT(I,5)
        ELSE
            W1=(TT-HK(I,5))/(HK(I,3)-T1)
            W2=1-W1
            THERMC=W1*HT(I,4)+W2*HT(I,5)
        END IF
    END IF
    RETURN
    END

    SUBROUTINE vsgrav_dr
    !******
    !CVSgrav_dr
    !******
    !C
    !  PURPOSE: TO COMPUTE flows from gravity drainage boundaries
    !
    !
    !------------------------------------------------------------------
    !
    !   SPECIFICATIONS FOR ARRAYS AND SCALARS
    !
    use kcon
    use hcon
    use disch
    use press
    use rspac
    use trxx
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)

    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    LOGICAL RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    COMMON/LOG1/RAD,BCIT,ETSIM,SEEP,ITSTOP,CIS,CIT,GRAV
    !
    !-----------------------------------------------------------------
    !
    DO 10 J=2,NLYY
        DO 10 N=2,NXRR
            IN=NLY*(N-1)+J
            IF(NTYP(IN).EQ.7) then
                AREA=DXR(N)
                IF(RAD)AREA=PI2*RX(N)*DXR(N)
                qq(in) = -hx(in)*hcnd(in)*AREA
            END IF
10  CONTINUE
    RETURN
    END



    !
    !   Following are subroutines that are required for connecting
    !  VS2DT fortran program to VS2DTI post processor
    !
    SUBROUTINE GETNX(NX)
    ! *** GET THE NUMBER OF CELLS IN THE X DIRECTION
    use iso_c_binding
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    integer(kind=C_LONG) :: NX
    NX = NXR
    RETURN
    END

    SUBROUTINE GETNZ(NZ)
    ! *** GET THE NUMBER OF CELLS IN THE Z DIRECTION
    use iso_c_binding
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    integer(kind=C_LONG) :: NZ
    NZ = NLY
    RETURN
    END

    SUBROUTINE GETDX(DX, NX)
    !C *** GET THE CELL SIZES IN THE X DIRECTION AND RETURN IT IN THE
    !C *** ARRAY DX PROVIDED BY THE CALLING PROGRAM
    use rspac
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_rspac.inc'
    DIMENSION DX(NX)
    DO 10 I=1, NX
        DX(I) = DXR(I)
10  CONTINUE
    RETURN
    END

    SUBROUTINE GETDZ(DZ, NZ)
    !C *** GET THE CELL SIZES IN THE Z DIRECTION AND RETURN IT IN THE
    !C *** ARRAY DZ PROVIDED BY THE CALLING PROGRAM
    use rspac
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_rspac.inc'
    DIMENSION DZ(NZ)
    DO 10 I=1, NZ
        DZ(I) = DELZ(I)
10  CONTINUE
    RETURN
    END

    !      SUBROUTINE GETCONC(C, N,NC)
    !!C *** GET THE CONCENTRATION ARRAY AND PUT IT IN C, WHICH IS PROVIDED
    !!C *** BY THE CALLING PROGRAM
    !      use trxx
    !      IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !!c      include 'c_trxx.inc'
    !      DIMENSION C(N,NC)
    !      DO 10 I=1,NC
    !      DO 10 N=1,Nsol  
    !         C(N,I) = CC(N,I)    
    !   10 CONTINUE
    !      RETURN
    !      END

    !!{{      
    SUBROUTINE GETCONC(IDX, C, NC)
    use trxx
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    DIMENSION C(NC)
    IF (ALLOCATED(CC) .AND. (IDX .LE. UBOUND(CC, 1))) THEN
        DO 10 I=1,NC
            C(I) = CC(IDX,I)    
10      CONTINUE
    END IF
    RETURN
    END

    SUBROUTINE GETCOMPCOUNT(N)
    use iso_c_binding
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    integer(kind=C_LONG) :: n
    N = Nsol
    RETURN
    END

    SUBROUTINE GETCOMP(IDX, NAME)
    USE COMPNAM
    INTEGER IDX
    CHARACTER(*) NAME
    IF (ALLOCATED(COMPNAME) .AND. (IDX .LE. UBOUND(COMPNAME, 1))) THEN
        NAME = TRIM(COMPNAME(IDX))//char(0)
    END IF
    RETURN
    END
    !!}}      

    !!{{      
    SUBROUTINE GETTEMP(C, NC)
    !C *** GET THE CONCENTRATION ARRAY AND PUT IT IN C, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use TRXXH
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_trxx.inc'
    DIMENSION C(NC)
    DO 10 I=1,NC
        C(I) = TT(I)    
10  CONTINUE
    RETURN
    END
    !!}}      

    SUBROUTINE GETKSAT(HX1, NN)
    !C *** GET THE SATURATED HYDRAULIC CONDUCTIVITY AND RETURN IT IN HX1, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use kcon
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_kcon.inc'
    DIMENSION HX1(NN)
    DO 10 I=1,NN
        HX1(I) = HX(I)
10  CONTINUE
    RETURN
    END

    SUBROUTINE GETTEX(JT, NN)
    !C *** GET THE TEXTURAL CLASS MAP AND RETURN IT IN JT, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use jtxx
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_jtxx.inc'
    DIMENSION JT(NN)
    DO 10 I=1,NN
        JT(I) = JTEX(I)
10  CONTINUE
    RETURN
    END
    SUBROUTINE GETMOIST(THETA1, NN)
    !C *** GET THE MOISTURE CONTENTS AND RETURN IT IN THETA1, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use mprop
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !      include 'c_mprop.inc'
    DIMENSION THETA1(NN)
    DO 10 I=1,NN
        THETA1(I) = THETA(I)
10  CONTINUE
    RETURN
    END

    SUBROUTINE GETSAT(SAT, NN)
    !C *** GET THE SATURATION AND RETURN IT IN SAT, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use mprop
    use jtxx
    use rpropsh
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_mprop.inc'
    !c      include 'c_jtxx.inc'
    !c      include 'c_rpropsh.inc'
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    DIMENSION SAT(NN)
    DO 70 J=2,NLYY
        DO 70 N=2,NXRR
            IN=NLY*(N-1)+J
            TTX=HK(JTEX(IN),3)
            IF(TTX.EQ.0.0D0) THEN
                SAT(IN)=0.0D0
            ELSE
                SAT(IN)=THETA(IN)/TTX
            END IF
70  CONTINUE
    RETURN
    END

    SUBROUTINE GETPHEAD(PHEAD, NN)
    !C *** GET THE PRESSURE HEAD AND RETURN IT IN PHEAD, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use press
    use rspac
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_press.inc'
    !c      include 'c_rspac.inc'
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    DIMENSION PHEAD(NN)
    DO 70 J=1,NLY
        DO 70 N=1,NXR
            IN=NLY*(N-1)+J
            IF(CS1.EQ.1.0D0) THEN
                Z1=DZZ(J)
            ELSE
                Z1=DZZ(J)*CS1+RX(N)*CS2
            END IF
            PHEAD(IN) = P(IN)+Z1
70  CONTINUE
    RETURN
    END

    SUBROUTINE GETSTIME(STIME)
    !C *** GET THE SIMULATION TIME AND RETURN IT IN STIME
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    STIME = STIM
    RETURN
    END

    SUBROUTINE GETSTEP(KTIME)
    !C *** GET THE TIME STEP AND RETURN IT IN KTIME
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    KTIME = KTIM
    RETURN
    END

    SUBROUTINE CLOSEIO
    !C *** CLOSE ALL IO UNITS
    USE PhreeqcRM
    USE vs2dt_rm
    IMPLICIT NONE
    CLOSE(2)
    CLOSE(5)
    CLOSE(6)
    CLOSE(7)
    CLOSE(8)
    CLOSE(9)
    CLOSE(10)
    CLOSE(11)
    CLOSE(12)
    CLOSE(13)
    !      CLOSE(14)
    !      CLOSE(15)
    !      CLOSE(16)
    !      CLOSE(17)
    !      CLOSE(18)
    !      CLOSE(19)
#ifdef USE_MPI
    status = RM_MpiWorkerBreak(rm_id)
#endif
    CALL FH_FinalizeFiles
    status = RM_CloseFiles(rm_id)
    status = RM_Destroy(rm_id)
#ifdef USE_MPI
    call MPI_FINALIZE(status)
#endif
    RETURN
    END

    SUBROUTINE RELEASEMEMORY
    use bf
    use compnam
    use coordin
    use disch
    use dumm
    use dumm1
    use dumm2
    use dumm3
    use equat
    use equats
    use hcon
    use idumm
    use ihdumm
    use isdumm
    use itemblo
    use itemtxb
    use itexs    
    use jtxx
    use kcon
    use mprop
    use phreecc
    use phreeqcrm
    use pit
    use plott
    use press
    use pricon
    use ptet
    use ptet
    use react
    use rpropsh
    use rspac
    use scon
    use sip
    use solindex
    use solmass
    use spfc
    use temp
    use tempcc
    use trxv
    use trxx
    use trxxh
    use trxy1
    use trxy2
    use vs2dt_rm
    use gmres1
    IMPLICIT NONE
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    DOUBLE PRECISION STIM, DSMAX
    INTEGER KTIM, NIT, NIT1, KP, NIT3
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    INTEGER NLY, NLYY, NXR, NXRR, NNODES, Nsol, Nodesol
    !!@@include 'd_cleanup.inc'
    if (allocated(A)) deallocate(A)
    if (allocated(ANIZ)) deallocate(ANIZ)
    if (allocated(AO)) deallocate(AO)
    if (allocated(AOC)) deallocate(AOC)
    if (allocated(AS)) deallocate(AS)
    if (allocated(B)) deallocate(B)
    if (allocated(BCMT)) deallocate(BCMT)
    if (allocated(BCMTR)) deallocate(BCMTR)
    if (allocated(BCMTT)) deallocate(BCMTT)
    if (allocated(BCSOL)) deallocate(BCSOL)
    if (allocated(BL62I)) deallocate(BL62I)
    if (allocated(BL62IT)) deallocate(BL62IT)
    if (allocated(BL62O)) deallocate(BL62O)
    if (allocated(BL62OT)) deallocate(BL62OT)
    if (allocated(BLSOL)) deallocate(BLSOL)
    if (allocated(BLTEMP36)) deallocate(BLTEMP36)
    if (allocated(BLTEMP39)) deallocate(BLTEMP39)
    if (allocated(BLTEMP42)) deallocate(BLTEMP42)
    if (allocated(BLTEMP45)) deallocate(BLTEMP45)
    if (allocated(BLTEMP60)) deallocate(BLTEMP60)
    if (allocated(BO)) deallocate(BO)
    if (allocated(BOC)) deallocate(BOC)
    if (allocated(BS)) deallocate(BS)
    if (allocated(C)) deallocate(C)
    if (allocated(CC)) deallocate(CC)
    if (allocated(CCAR)) deallocate(CCAR)
    if (allocated(CCBR)) deallocate(CCBR)
    if (allocated(CCOLD)) deallocate(CCOLD)
    if (allocated(CMIXFARC)) deallocate(CMIXFARC)
    if (allocated(CO)) deallocate(CO)
    if (allocated(COC)) deallocate(COC)
    if (allocated(COMPNAME)) deallocate(COMPNAME)
    if (allocated(CONC)) deallocate(CONC)
    if (allocated(CS)) deallocate(CS)
    if (allocated(CSS)) deallocate(CSS)
    if (allocated(CURRENTBF)) deallocate(CURRENTBF)
    if (allocated(D)) deallocate(D)
    if (allocated(DEL)) deallocate(DEL)
    if (allocated(DELZ)) deallocate(DELZ)
    if (allocated(DHMX)) deallocate(DHMX)
    if (allocated(DO)) deallocate(DO)
    if (allocated(DOC)) deallocate(DOC)
    if (allocated(DPTH)) deallocate(DPTH)
    if (allocated(DS)) deallocate(DS)
    if (allocated(DUM)) deallocate(DUM)
    if (allocated(DUM1)) deallocate(DUM1)
    if (allocated(DUM2)) deallocate(DUM2)
    if (allocated(DX1)) deallocate(DX1)
    if (allocated(DX2)) deallocate(DX2)
    if (allocated(DXR)) deallocate(DXR)
    if (allocated(DXS1)) deallocate(DXS1)
    if (allocated(DXS2)) deallocate(DXS2)
    if (allocated(DZ1)) deallocate(DZ1)
    if (allocated(DZ2)) deallocate(DZ2)
    if (allocated(DZS1)) deallocate(DZS1)
    if (allocated(DZS2)) deallocate(DZS2)
    if (allocated(DZZ)) deallocate(DZZ)
    if (allocated(E)) deallocate(E)
    if (allocated(EO)) deallocate(EO)
    if (allocated(EOC)) deallocate(EOC)
    if (allocated(ES)) deallocate(ES)
    if (allocated(ETA)) deallocate(ETA)
    if (allocated(FORWARD1)) deallocate(FORWARD1)
    if (allocated(HCND)) deallocate(HCND)
    if (allocated(HK)) deallocate(HK)
    if (allocated(HKLL)) deallocate(HKLL)
    if (allocated(HKTT)) deallocate(HKTT)
    if (allocated(HS)) deallocate(HS)
    if (allocated(HT)) deallocate(HT)
    if (allocated(HX)) deallocate(HX)
    if (allocated(IC1_REORDERED)) deallocate(IC1_REORDERED)
    if (allocated(IDBF)) deallocate(IDBF)
    if (allocated(IDUM)) deallocate(IDUM)
    if (allocated(IHDUM)) deallocate(IHDUM)
    if (allocated(IJOBS)) deallocate(IJOBS)
    if (allocated(INDSOL1)) deallocate(INDSOL1)
    if (allocated(INDSOL2)) deallocate(INDSOL2)
    if (allocated(ISDUM)) deallocate(ISDUM)
    if (allocated(ITBDUM)) deallocate(ITBDUM)
    if (allocated(ITDUM)) deallocate(ITDUM)
    if (allocated(ITEMBL)) deallocate(ITEMBL)
    if (allocated(ITEMTX)) deallocate(ITEMTX)
    if (allocated(ITEXSOL)) deallocate(ITEXSOL)
    if (allocated(JLAST)) deallocate(JLAST)
    if (allocated(JSPX)) deallocate(JSPX)
    if (allocated(JTEX)) deallocate(JTEX)
    if (allocated(NCTYP)) deallocate(NCTYP)
    if (allocated(NFC)) deallocate(NFC)
    if (allocated(NHTYP)) deallocate(NHTYP)
    if (allocated(NODENUM)) deallocate(NODENUM)
    if (allocated(NPRCHEM)) deallocate(NPRCHEM)
    if (allocated(NPRCHOBS)) deallocate(NPRCHOBS)
    if (allocated(NPRCHXZ)) deallocate(NPRCHXZ)
    if (allocated(NTYP)) deallocate(NTYP)
    if (allocated(NUMCELLSBF)) deallocate(NUMCELLSBF)
    if (allocated(P)) deallocate(P)
    if (allocated(PDUM)) deallocate(PDUM)
    if (allocated(PEVAL)) deallocate(PEVAL)
    if (allocated(PHREEC)) deallocate(PHREEC)
    if (allocated(PITT)) deallocate(PITT)
    if (allocated(PLTIM)) deallocate(PLTIM)
    if (allocated(POROSITY)) deallocate(POROSITY)
    if (allocated(PTVAL)) deallocate(PTVAL)
    if (allocated(PXXX)) deallocate(PXXX)
    if (allocated(Q)) deallocate(Q)
    if (allocated(QQ)) deallocate(QQ)
    if (allocated(QS)) deallocate(QS)
    if (allocated(QT)) deallocate(QT)
    if (allocated(RDC)) deallocate(RDC)
    if (allocated(RHO)) deallocate(RHO)
    if (allocated(RHOOLD)) deallocate(RHOOLD)
    if (allocated(RHS)) deallocate(RHS)
    if (allocated(RHSS)) deallocate(RHSS)
    if (allocated(RT)) deallocate(RT)
    if (allocated(RX)) deallocate(RX)
    if (allocated(SATUR)) deallocate(SATUR)
    if (allocated(TEMPC)) deallocate(TEMPC)
    if (allocated(THEAD)) deallocate(THEAD)
    if (allocated(THETA)) deallocate(THETA)
    if (allocated(THLST)) deallocate(THLST)
    if (allocated(TOTALBF)) deallocate(TOTALBF)
    if (allocated(TS)) deallocate(TS)
    if (allocated(TT)) deallocate(TT)
    if (allocated(TTOLD)) deallocate(TTOLD)
    if (allocated(V)) deallocate(V)
    if (allocated(VX)) deallocate(VX)
    if (allocated(VZ)) deallocate(VZ)
    if (allocated(XI)) deallocate(XI)
    if (allocated(XIS)) deallocate(XIS)
    if (allocated(XNODE)) deallocate(XNODE)
    if (allocated(ZNODE)) deallocate(ZNODE)
    if (allocated(A_GMR)) deallocate(A_GMR)
    if (allocated(IA_GMR)) deallocate(IA_GMR)
    if (allocated(JA_GMR)) deallocate(JA_GMR)
    if (allocated(RHS_GMR)) deallocate(RHS_GMR)
    
    if (rm_id .ge. 0) then
#ifdef USE_MPI
        status = RM_MpiWorkerBreak(rm_id)
#endif
        status = RM_CloseFiles(rm_id)
        status = RM_Destroy(rm_id)
#ifdef USE_MPI
        call MPI_FINALIZE(status)
#endif
    END IF

    ! INIT
    KTIM=0
    Nsol=0

    RETURN
    END

    SUBROUTINE GETFLOWMBERR(ERR)
    !C *** GET TOTAL AND RATE FLOW MASS BALANCE ERRORS AND RETURN IN ERR
    use scon
    use solmass
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c     include 'c_scon.inc'      
    COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
    bl95I,bl95IT,bl95o,bl95OT
    common/massb1/bcmf,bcmh, &
    bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
    !     common/massb2/label9
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    DIMENSION ERR(2)
    IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
    END IF
    FMB1 = BL(13)
    FMB2 = BL(16) + BL(25)
    FMB3 = bl29IT
    FMB4 = bl29OT
    FMB5 = BL(15)
    FMB6 = BL(18) + BL(27)
    FMB7 = bl29I/DELT
    FMB8 = bl29O/DELT
    E1 = FMB1 - FMB4
    E2 = -FMB2 + FMB3
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
    ELSE
        ERR(1) = 0
    END IF
    E1 = FMB5 - FMB8
    E2 = -FMB6 + FMB7
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
    ELSE
        ERR(2) = 0
    END IF
    RETURN
    END
    
    SUBROUTINE GETJSTEP(JSTP)
    COMMON/JCON/JSTOP,JFLAG,jflag1
    JSTP=JSTOP
    END    

    SUBROUTINE GETHEATTRANSMBERR(ERR)
    !C *** GET TOTAL AND RATE CHEMICAL MASS BALANCE ERRORS AND RETURN IN ERR
    use scon
    use solmass
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_scon.inc'
    COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
    bl95I,bl95IT,bl95o,bl95OT
    common/massb1/bcmf,bcmh, &
    bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    DIMENSION ERR(2)
    IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
    END IF
    TMB1 = BL(85)
    TMB2 = BL(88)+BL(91)
    TMB3 = bl95IT
    TMB4 = bl95OT
    TMB5 = BL(87)
    TMB6 = BL(90)+BL(93)
    TMB7 = bl95I/DELT
    TMB8 = bl95O/DELT
    E1 = TMB1 - TMB4
    E2 = -TMB2 + TMB3
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
    ELSE
        ERR(1) = 0
    END IF
    E1 = TMB5 - TMB8
    E2 = -TMB6 + TMB7
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
    ELSE
        ERR(2) = 0
    END IF
    RETURN
    END

    SUBROUTINE GETVX(VELX, NN)
    !C *** GET THE X VELOCITY AND RETURN IT IN VELX, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use kcon
    use trxv
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_kcon.inc'
    !c      include 'c_trxx.inc'
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    DIMENSION VELX(NN)
    IF(.NOT.TRANS) CALL VTVELO
    DO 70 J=1,NLY
        DO 70 N=1,NXR
            IN=NLY*(N-1)+J
            IF(HX(IN).EQ.0.0D0) THEN
                VELX(IN)=0.0D0
            ELSE
                VELX(IN)=(VX(IN)+VX(IN+NLY))/2
            END IF
70  CONTINUE
    RETURN
    END

    SUBROUTINE GETVZ(VELZ, NN)
    !C *** GET THE Z VELOCITY AND RETURN IT IN VELZ, WHICH IS PROVIDED
    !C *** BY THE CALLING PROGRAM
    use kcon
    use trxv
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_kcon.inc'
    !c      include 'c_trxx.inc'
    COMMON/ISPAC/NLY,NLYY,NXR,NXRR,NNODES,Nsol,Nodesol
    DIMENSION VELZ(NN)
    DO 70 J=1,NLY
        DO 70 N=1,NXR
            IN=NLY*(N-1)+J
            IF(HX(IN).EQ.0.0D0) THEN
                VELZ(IN)=0.0D0
            ELSE
                VELZ(IN)=(VZ(IN)+VZ(IN+1))/2
            END IF
70  CONTINUE
    RETURN
    END

    SUBROUTINE DOTRANS(IFLAG)
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    LOGICAL TRANS,TRANS1,TRANS2,SSTATE
    COMMON/TRXY/EPS1,EPS2,EPS3,TRANS,TRANS1,TRANS2,SSTATE,MB9(99),NMB9
    IF (TRANS) THEN
        IFLAG=1
    ELSE
        IFLAG=0
    ENDIF
    RETURN
    END

    SUBROUTINE GETSOLTRANSMBERR(ERR,N)
    !C *** GET TOTAL AND RATE CHEMICAL MASS BALANCE ERRORS AND RETURN IN ERR
    use scon
    use solmass
    IMPLICIT DOUBLE PRECISION (A-H,P-Z)
    !c      include 'c_scon.inc'
    COMMON/MASSB/BL(99),bcmft,bcmht,bl29I,bl29IT,bl29O,bl29OT, &
    bl95I,bl95IT,bl95o,bl95OT
    common/massb1/bcmf,bcmh, &
    bltemp69,bltemp72,bltemp75,bltemp78,bltemp91
    COMMON/TCON/STIM,DSMAX,KTIM,NIT,NIT1,KP,NIT3
    DIMENSION ERR(2)
    IF(KTIM.EQ.0) THEN
        ERR(1) = 0
        ERR(2) = 0
        RETURN
    END IF
    TMB1 = BLSOL(n,19)
    TMB2 = BLSOL(n,22) + BLSOL(n,25) + BLSOL(n,34)
    TMB3 = BL62IT(n)
    TMB4 = BL62OT(n)
    TMB5 = BLSOL(n,21)
    TMB6 = BLSOL(n,24) + BLSOL(n,27) + BLSOL(n,36)
    TMB7 = BL62I(n)/DELT
    TMB8 = BL62O(n)/DELT
    E1 = TMB1 - TMB4
    E2 = -TMB2 + TMB3
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(1) = 100 * (E1 - E2)/D
    ELSE
        ERR(1) = 0
    END IF
    E1 = TMB5 - TMB8
    E2 = -TMB6 + TMB7
    D = (E1 + E2)/2
    IF (D.NE.0) THEN
        ERR(2) = 100 * (E1 - E2)/D
    ELSE
        ERR(2) = 0
    END IF
    RETURN
    END

    SUBROUTINE DOHEAT(IFLAG)
    IMPLICIT NONE
    INTEGER IFLAG
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    IF (HEAT) THEN
        IFLAG=1
    ELSE
        IFLAG=0
    ENDIF
    RETURN
    END


    SUBROUTINE DOSOLUTE(IFLAG)
    IMPLICIT NONE
    INTEGER IFLAG
    LOGICAL HEAT,SOLUTE,FLOW
    COMMON/TRANSTYPE/HEAT,SOLUTE
    IF (SOLUTE) THEN
        IFLAG=1
    ELSE
        IFLAG=0
    ENDIF
    RETURN
    END
